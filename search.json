[{"title":"力扣每日一题3186-施咒的最大总伤害","url":"/2025/10/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983186-%E6%96%BD%E5%92%92%E7%9A%84%E6%9C%80%E5%A4%A7%E6%80%BB%E4%BC%A4%E5%AE%B3/","content":"题意给定 power 表示一堆咒语的伤害，若使用了伤害为 x 的咒语，则不再可以使用伤害为 x - 1, x - 2, x + 1, x + 2 的咒语。求可造成的最大伤害和。\n思路那也很明显就是一个 dp 题，对各个咒语进行排序并计数去重后显然有：\n\n进行一个双指针维护最大的 dp_j 即可 O(n) 完成\n实现class Solution {using ll = long long;public:    ll maximumTotalDamage(vector&lt;int&gt;&amp; power) {        ranges::sort(power);        vector&lt;array&lt;int, 2&gt;&gt; cnt;        int m = power.size();        for (int i = 0, j = 0; i &lt; m; i = j) {            for ( ; j &lt; m &amp;&amp; power[j] == power[i]; j++);            cnt.push_back({power[i], j - i});        }        int n = cnt.size();        vector&lt;ll&gt; f(n);        ll mx = 0;        int j = 0;        for (int i = 0; i &lt; n; i++) {            for ( ; cnt[i][0] - cnt[j][0] &gt; 2; j++) mx = max(mx, f[j]);            f[i] = mx + 1ll * cnt[i][0] * cnt[i][1];        }        for ( ; j &lt; n; j++) mx = max(mx, f[j]);        return mx;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3147-从魔法师身上吸取的最大能量","url":"/2025/10/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983147-%E4%BB%8E%E9%AD%94%E6%B3%95%E5%B8%88%E8%BA%AB%E4%B8%8A%E5%90%B8%E5%8F%96%E7%9A%84%E6%9C%80%E5%A4%A7%E8%83%BD%E9%87%8F/","content":"题意有 n 个魔法师站成一排，他们能量 energy 有正有负，同时给定正整数 k ，可以任选一个魔法师开始，吸收其能量后跳跃到当前位置 + k 处继续吸收，直到到达魔法师队伍外。求可以获得的最大能量。\n思路那很明显就是一个 dp 题，显然当前位置可得能量大于零才会进行考虑，这里我选择了递推，当当前位置可得能量大于零则将当前格所得能量推给 + k  处。\n实现class Solution {public:    int maximumEnergy(vector&lt;int&gt;&amp; energy, int k) {        int n = energy.size();        vector&lt;int&gt; f = energy;        for (int i = 0; i &lt; n; i++) {            if (f[i] &gt; 0 &amp;&amp; i + k &lt; n) f[i + k] += f[i];        }        int ans = INT_MIN;        for (int i = n - k; i &lt; n; i++) ans = max(ans, f[i]);        return ans;    }};\n\nclass Solution:    def maximumEnergy(self, energy: List[int], k: int) -&gt; int:        n = len(energy)        f = [0] * n        for i in range(n):            f[i] += energy[i]            if f[i] &gt; 0 and i + k &lt; n:                f[i + k] = f[i]        return max(f[n - k : ])\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题3494-酿造药水需要的最少总时间","url":"/2025/10/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983494-%E9%85%BF%E9%80%A0%E8%8D%AF%E6%B0%B4%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E6%80%BB%E6%97%B6%E9%97%B4/","content":"题意给定正整数数组 skill 和 mana，分别表示各巫师的能力与各药水的法力。对于第 i 个巫师处理第 j 个药水所需的时间为 skill[i] * mana[j]。\n必须按顺序酿造药水，且每个药水均需经过每个巫师的处理，同时药水在当前巫师完成工作后必须立即传递给下一巫师开始处理。\n求酿造好所有药水所需的最短时间。 \n思路某药水被某巫师处理完毕后必须立刻由下一巫师开始进行处理，因此各个时间需要同步。\n开一数组记录各个巫师处理完上一药水的时间，然后模拟处理每个药水的流程即可。\n实现class Solution {using ll = long long;public:    ll minTime(vector&lt;int&gt;&amp; skill, vector&lt;int&gt;&amp; mana) {        int n = skill.size(), m = mana.size();        vector&lt;ll&gt; t(n);        for (int i = 0; i &lt; m; i++) {            ll start = 0;            for (int j = 0; j &lt; n; j++) {                start = max(start, t[j]) + 1ll * skill[j] * mana[i];            }            t[n - 1] = start;            for (int j = n - 2; j &gt;= 0; j--) {                t[j] = t[j + 1] - 1ll * skill[j + 1] * mana[i];            }        }        return t.back();    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2300-咒语和药水的成功对数","url":"/2025/10/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982300-%E5%92%92%E8%AF%AD%E5%92%8C%E8%8D%AF%E6%B0%B4%E7%9A%84%E6%88%90%E5%8A%9F%E5%AF%B9%E6%95%B0/","content":"题意给定正整数数组 spells 和 potions 分别表示若干个咒语的强度和若干个药水的强度。同时给定正整数 success ，若咒语和药水的强度乘积大于等于 success 则视其为成功组合。求问每个咒语有多少个成功组合。\n思路对 potions 进行排序，找第一个与对应咒语乘积大于等于 success 的药水，其与其后的药水显然满足成功的条件。\n欲使得某整数与 x 乘积大于等于 success 显然该数应大于等于 ​\n因此进行一个排序后二分即可。\n实现class Solution {using ll = long long;public:    vector&lt;int&gt; successfulPairs(vector&lt;int&gt;&amp; spells, vector&lt;int&gt;&amp; potions, ll success) {        int n = spells.size(), m = potions.size();        vector&lt;int&gt; ans(n);        ranges::sort(potions);        for (int i = 0; i &lt; n; i++) {            ll need = (success + spells[i] - 1) / spells[i];            ans[i] = potions.end() - ranges::lower_bound(potions, need);        }        return ans;    }};\n\nclass Solution:    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -&gt; List[int]:        potions.sort()        m = len(potions)        return [m - bisect_left(potions, (success + x - 1) // x) for x in spells]\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题1488-避免洪水泛滥","url":"/2025/10/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981488-%E9%81%BF%E5%85%8D%E6%B4%AA%E6%B0%B4%E6%B3%9B%E6%BB%A5/","content":"题意有很多初始为空的湖，若该湖雨前为空则雨后满，若该湖雨前已满则雨后发生洪水。给定数组 rains ，若 rains[i] 非 0 表示当天湖 rains[i] 下雨，若 rains[i] 为 0 表示当天无雨可任选一个湖进行抽水。求问是否有抽水策略可使不发生洪水，返回对应方案。 \n思路那只需要记录每个湖上一次下雨的日期，以及还未安排抽水的日期，取第一个大于上次下雨的日期对该湖进行抽水即可。\n实现class Solution {public:    vector&lt;int&gt; avoidFlood(vector&lt;int&gt;&amp; rains) {        unordered_map&lt;int, int&gt; last;        set&lt;int&gt; st;        int n = rains.size();        vector&lt;int&gt; ans(n, -1);        for (int i = 0; i &lt; n; i++) {            if (rains[i] == 0) {                st.insert(i);                continue;            }            if (last.count(rains[i])) {                int l = last[rains[i]];                auto it = st.lower_bound(l);                if (it == st.end()) return {};                ans[*it] = rains[i];                st.erase(it);                last[rains[i]] = i;            } else {                last[rains[i]] = i;            }        }        for (auto i : st) ans[i] = 1;        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题778-水位上升的泳池中游泳","url":"/2025/10/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98778-%E6%B0%B4%E4%BD%8D%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B3%B3%E6%B1%A0%E4%B8%AD%E6%B8%B8%E6%B3%B3/","content":"题意给定 n * n 的数组 grid 表示矩形水池中各个位置的高度。在时刻 t 水池的水位为 t ，可以在相邻的高度小于等于 t 的格子中任意不耗时地移动。初始位于水池的左上角 (0, 0) ，求到达水池右下角 (n - 1, n - 1) 的最短时间。\n思路第一想法是进行一个二分，二分最短时间然后从起点进行一个 bfs/dfs ，仅能经过高度小于等于 x 的格子，查看是否可达终点。\n但是仔细一想这个过程是可以简化的：维护当前时刻，并用优先队列维护可达点，第一次到达终点的时刻即为答案。\n实现class Solution {static constexpr array&lt;int, 2&gt; to[] = {    {1, 0}, {-1, 0}, {0, 1}, {0, -1}};public:    int swimInWater(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {        int cur = 0;        int n = grid.size();        vector vis(n, vector&lt;bool&gt; (n));        priority_queue&lt;array&lt;int, 3&gt;, vector&lt;array&lt;int, 3&gt;&gt;, greater&lt;&gt;&gt; pq;        pq.push({grid[0][0], 0, 0});        while (!pq.empty()) {            auto [c, x, y] = pq.top();            pq.pop();            if (vis[x][y]) continue;            vis[x][y] = true;            cur = max(cur, c);            if (x == n - 1 &amp;&amp; y == n - 1) return cur;            for (auto [tx, ty] : to) {                int nx = x + tx, ny = y + ty;                if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n || vis[nx][ny]) continue;                pq.push({grid[nx][ny], nx, ny});            }        }        return -1;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题417-太平洋大西洋水流问题","url":"/2025/10/05/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98417-%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98/","content":"题意给定二维数组 heights 表示一个矩形海岛各处的高度。若相邻格子高度小于等于当前格子高度，则当前格子的水可以流向相邻格子。\n记海岛左侧与上侧为太平洋，右侧下侧为大西洋，求岛上有哪些格子的水可以同时流向太平洋与大西洋。\n思路这题的数据范围并不大，海岛的长宽均小于等于 200 ，那其实怎么做基本都可以接受的。\n这里我们以左侧与上侧为起点做一趟bfs，标记所有可达太平洋的格子；再以右侧与下侧为起点做一趟bfs，标记所有可达大西洋的格子；在返回被标记两次的格子即可。\n实现class Solution {static constexpr array&lt;int, 2&gt; to[] = {    {0, 1}, {0, -1}, {1, 0}, {-1, 0}};public:    vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; heights) {        int n = heights.size(), m = heights.back().size();        vector&lt;vector&lt;int&gt;&gt; ans;        vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt; (m));        vector&lt;vector&lt;bool&gt;&gt; vis(n, vector&lt;bool&gt; (m));        vector&lt;array&lt;int, 2&gt;&gt; q;        for (int i = 0; i &lt; n; i++) q.push_back({i, 0});        for (int i = 1; i &lt; m; i++) q.push_back({0, i});        for (int i = 0; i &lt; q.size(); i++) {            auto [x, y] = q[i];            if (vis[x][y]) continue;            f[x][y] |= 1;            vis[x][y] = true;            for (auto [tx, ty] : to) {                int nx = x + tx, ny = y + ty;                if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || vis[nx][ny]) continue;                if (heights[nx][ny] &gt;= heights[x][y]) q.push_back({nx, ny});            }        }        q.clear();        for (int i = 0; i &lt; n; i++) {q.push_back({i, m - 1}); fill(vis[i].begin(), vis[i].end(), false);}        for (int i = 0; i &lt; m - 1; i++) q.push_back({n - 1, i});        for (int i = 0; i &lt; q.size(); i++) {            auto [x, y] = q[i];            if (vis[x][y]) continue;            f[x][y] |= 2;            vis[x][y] = true;            for (auto [tx, ty] : to) {                int nx = x + tx, ny = y + ty;                if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || vis[nx][ny]) continue;                if (heights[nx][ny] &gt;= heights[x][y]) q.push_back({nx, ny});            }        }        for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; m; j++)                if (f[i][j] == 3) ans.push_back({i, j});        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题11-盛最多水的容器","url":"/2025/10/04/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9811-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","content":"题意给定数组 height 表示 x 轴上按次排序的各条垂线的高度，找出其中两条线使得它们与 x 轴构成的容器可装最多水。\n（具体的 height[i] = h 表示第 i 条线两端点为 (i, 0) 与 i, h）\n思路可装水的体积以两条线之间的距离为底，以两线较短边为高。即若选 i, j 两条边所组成的体积为 (j - i) * min(height[i], height[j])\n当取 height 两端点时有 (j - i) 取到最大值，此时我们考虑如何选择可能让体积变得更大：\n无论移动哪一条边 (j - i) 必然减小，故而必须使 min(height[i], height[j]) 变大才可能使得体积增大。若移动较长边 min(height[i], height[j]) 必然不变或减小，因此我们固定较长边枚举较短边。\n根据以上思路双指针遍历数组取最大作为答案即可。\n实现class Solution {public:    int maxArea(vector&lt;int&gt;&amp; height) {        int ans = 0;        for (int l = 0, r = height.size() - 1; l &lt; r; ) {            ans = max(ans, min(height[l], height[r]) * (r - l));            if (height[l] &lt; height[r]) l++;            else r--;        }        return ans;    }};\n\nclass Solution:    def maxArea(self, height: List[int]) -&gt; int:        ans = 0        l = 0        r = len(height) - 1        while l &lt; r:            ans = max(ans, min(height[l], height[r]) * (r - l))            if height[l] &lt; height[r]:                l += 1            else:                r -= 1        return ans\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题407-接雨水II","url":"/2025/10/03/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98407-%E6%8E%A5%E9%9B%A8%E6%B0%B4II/","content":"题意给定二维数组，表示各个单元格的高度，求所给几何体可以装多少水。\n思路大名鼎鼎的接雨水题，不过扩展到了三维情况。\n咱们先手玩一下，不难发现最外围一圈格子一定是无法接水的。而次外围的格子所能装的一定不超过相邻最外围格子的最小值。这样一直往里推，即可求出各个单元格所能装水的高度，为了每次取最小我们使用优先队列模拟即可。\n实现class Solution {static constexpr array&lt;int, 2&gt; to[] = {    {0, 1}, {0, -1}, {1, 0}, {-1, 0}};public:    int trapRainWater(vector&lt;vector&lt;int&gt;&gt;&amp; heightMap) {        int n = heightMap.size(), m = heightMap.back().size();        priority_queue&lt;array&lt;int, 3&gt;, vector&lt;array&lt;int, 3&gt;&gt;, greater&lt;&gt;&gt; pq;        for (int i = 0; i &lt; n; i++) {            pq.push({heightMap[i].front(), i, 0});            pq.push({heightMap[i].back(), i, m - 1});            heightMap[i][0] = heightMap[i][m - 1] = -1;        }        for (int i = 1; i &lt; m - 1; i++) {            pq.push({heightMap[0][i], 0, i});            pq.push({heightMap[n - 1][i], n - 1, i});            heightMap[0][i] = heightMap[n - 1][i] = -1;        }        int ans = 0;        while (!pq.empty()) {            auto [h, x, y] = pq.top();            pq.pop();            for (auto [tx, ty] : to) {                int nx = x + tx, ny = y + ty;                if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || heightMap[nx][ny] == -1) continue;                ans += max(0, h - heightMap[nx][ny]);                pq.push({max(heightMap[nx][ny], h), nx, ny});                heightMap[nx][ny] = -1;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3100-换水问题II","url":"/2025/10/02/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983100-%E6%8D%A2%E6%B0%B4%E9%97%AE%E9%A2%98II/","content":"题意初始有 numBottles 瓶水，每 numExchange 个空瓶可以换一瓶水，但每交换一瓶水 numExchage 会加 1 ，求最多可以喝多少瓶水。\n思路那和昨天是非常类似的，只是 numExchage 不再是定值。\n推公式变得难推很多，所以咱们就简单问题简单做，进行一个模拟就好。\n实现class Solution {public:    int maxBottlesDrunk(int numBottles, int numExchange) {        int ans = numBottles;        for ( ; numBottles &gt;= numExchange; ) {            ans++;            numBottles -= numExchange - 1;            numExchange++;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1518-换水问题","url":"/2025/10/01/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981518-%E6%8D%A2%E6%B0%B4%E9%97%AE%E9%A2%98/","content":"题意初始有 numBottles 瓶水，每 numExchange 个空瓶可以换一瓶水，问最多可以喝到多少瓶水。\n思路数据范围都是比较小的 1 &lt;= numBottles &lt;= 100, 2 &lt;= numExchange &lt;= 100 故而可以直接模拟（见cpp实现）\n当然也是可以推一下公式的：相当于每次减少 (numExchange - 1) 瓶水可以减少多少次。（见python实现）\n实现class Solution {public:    int numWaterBottles(int numBottles, int numExchange) {        int ans = numBottles;        for ( ; numBottles &gt;= numExchange; ) {            ans += numBottles / numExchange;            numBottles = numBottles / numExchange + numBottles % numExchange;        }        return ans;    }};\n\nclass Solution:    def numWaterBottles(self, numBottles: int, numExchange: int) -&gt; int:        return numBottles + (numBottles - 1) // (numExchange - 1)\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题2221-数组的三角和","url":"/2025/09/30/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982221-%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E8%A7%92%E5%92%8C/","content":"题意给定非负个位数数组 nums ，每次操作将 nums[i] = (nums[i] + nums[i + 1]) % 10 并将最后一个元素删除，直到数组只剩最后一个元素。求最后元素是什么。\n思路这题的数据范围并不大 1 &lt;= nums.size() &lt;= 1000 \n所以虽然确实有更加高级的做法，但有点太耗费脑子与时间了，咱们简单问题简单做，直接进行一个模拟就好。\n实现class Solution {public:    int triangularSum(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        for (int i = n - 1; i &gt;= 0; i--) {            for (int j = 0; j &lt; i; j++) {                nums[j] = nums[j] + nums[j + 1];                if (nums[j] &gt;= 10) nums[j] -= 10;            }        }        return nums[0];    }};\n\nclass Solution:    def triangularSum(self, nums: List[int]) -&gt; int:        for i in range(len(nums) - 1, -1, -1):            for j in range(i):                nums[j] = nums[j] + nums[j + 1]                if nums[j] &gt;= 10:                    nums[j] -= 10        return nums[0]\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题1039-多边形三角剖分的最低得分","url":"/2025/09/29/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981039-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E6%9C%80%E4%BD%8E%E5%BE%97%E5%88%86/","content":"题意给定长度为 n 的正整数数组 values ，表示一个凸多边形顺时针下各顶点的值。欲将其分割为 n - 2 个三角形，分割值为各三角形顶点值的积之和，求分隔值的最小。\n思路分割出一个三角形可以看作是三个顶点的合并，这样就可以将问题转换为了经典的区间dp。\n实现class Solution {public:    int minScoreTriangulation(vector&lt;int&gt;&amp; values) {        const int n = values.size();        vector f(n, vector&lt;int&gt; (n));        for (int len = 2; len &lt; n; len++) {            for (int i = 0, j = len; j &lt; n; i++, j++) {                f[i][j] = 1e9;                for (int k = i + 1; k &lt; j; k++) {                    f[i][j] = min(f[i][j], f[i][k] + f[k][j] + values[i] * values[j] * values[k]);                }            }        }        return f[0][n - 1];    }};\n\nclass Solution:    def minScoreTriangulation(self, values: List[int]) -&gt; int:        @cache        def dfs(i, j):            if i == j or i + 1 == j:                return 0            return min(dfs(i, k) + dfs(k, j) + values[i] * values[j] * values[k] for k in range(i + 1, j))        return dfs(0, len(values) - 1)\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题976-三角形的最大周长","url":"/2025/09/28/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98976-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF/","content":"题意给定正整数数组 nums ，返回其可以组成的最长周长的三角形的周长。\n思路根据三角形最短两边和大于第三边，显然排序过后最长周长的三条边是连续的，由此排序后枚举找到第一个满足构成三角形条件的三条连续边即可。\n实现class Solution {public:    int largestPerimeter(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        ranges::sort(nums, greater());        for (int i = 2; i &lt; n; i++) {            if (nums[i] + nums[i - 1] &gt; nums[i - 2]) return nums[i] + nums[i - 1] + nums[i - 2];        }        return 0;    }};\n\nclass Solution:    def largestPerimeter(self, nums: List[int]) -&gt; int:        nums.sort(reverse=True)        for i in range(2, len(nums)):            if nums[i] + nums[i - 1] &gt; nums[i - 2]:                return sum(nums[i - 2 : i + 1])        return 0\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题812-最大三角形面积","url":"/2025/09/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98812-%E6%9C%80%E5%A4%A7%E4%B8%89%E8%A7%92%E5%BD%A2%E9%9D%A2%E7%A7%AF/","content":"题意给定二维平面点集 points 返回其中可组成面积最大的三角形的面积。\n思路点集的大小不大 3 &lt;= points.size() &lt;= 50 故而之间枚举三个点即可。\n实现class Solution {public:    double largestTriangleArea(vector&lt;vector&lt;int&gt;&gt;&amp; points) {        auto cal = [](vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y, vector&lt;int&gt;&amp; z) -&gt; double {            return 0.5 * abs(x[0] * y[1] + y[0] * z[1] + z[0] * x[1] - x[0] * z[1] - y[0] * x[1] - z[0] * y[1]);        };        int n = points.size();        double ans = 0;        for (int i = 0; i &lt; n - 2; i++)            for (int j = i + 1; j &lt; n - 1;j ++)                for (int k = j + 1; k &lt; n; k++)                    ans = max(ans, cal(points[i], points[j], points[k]));        return ans;    }};\n\nclass Solution:    def largestTriangleArea(self, points: List[List[int]]) -&gt; float:        def cal(x, y, z):            return abs(x[0] * y[1] + y[0] * z[1] + z[0] * x[1] - x[0] * z[1] - y[0] * x[1] - z[0] * y[1]) / 2        return max(cal(x, y, z) for x, y, z in combinations(points, 3))\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题611-有效三角形的个数","url":"/2025/09/26/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98611-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/","content":"题意给定一个非负整数数组 nums ， 返回其中可以组成三角形的三条边的三元组个数。\n思路数据范围 1 &lt;= nums.size() &lt;= 1000\n可以考虑将边排序后，固定最短边，枚举次短边，最长边用一个指针维护，因为最短边固定 次短边按递增枚举 则其可以满足的最长边一定是递增的（三角形最短两边和大于最长边）\n注意这里给定数是非负整数，即含有0即可。\n实现class Solution {public:    int triangleNumber(vector&lt;int&gt;&amp; nums) {        ranges::sort(nums);        int ans = 0;        int n = nums.size();        for (int x = 0; x &lt; n - 2; x++) {            if (nums[x] == 0) continue;            for (int y = x + 1, z = x + 2; y &lt; n - 1; y++) {                for ( ; z &lt; n &amp;&amp; nums[x] + nums[y] &gt; nums[z]; z++);                ans += z - y - 1;            }        }        return ans;    }};\n\nclass Solution:    def triangleNumber(self, nums: List[int]) -&gt; int:        nums.sort()        ans = 0        n = len(nums)        for x in range(n - 2):            if nums[x] == 0:                continue            z = x + 2            for y in range(x + 1, n - 1):                while z &lt; n and nums[x] + nums[y] &gt; nums[z]:                    z += 1                ans += z - y - 1        return ans\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题120-三角形最小路径和","url":"/2025/09/25/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","content":"题意给定一个数字三角形，初始位于最上层顶点，每一步可以向正下或右下走一格，求到达最底层的最小路径和。\n思路那这是一道非常经典的dp问题了，每一个格子仅可能从其上或其左上的格子得来，因此其最小代价为其值加上可达其的格子的最小代价。注意边界的处理即可。\n实现class Solution {public:    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {        const int n = triangle.size();        for (int i = 1; i &lt; n; i++) {            for (int j = 1; j &lt; i; j++) {                triangle[i][j] += min(triangle[i - 1][j - 1], triangle[i - 1][j]);            }            triangle[i][0] += triangle[i - 1][0];            triangle[i][i] += triangle[i - 1][i - 1];        }        return ranges::min(triangle.back());    }};\n\nclass Solution:    def minimumTotal(self, triangle: List[List[int]]) -&gt; int:        for i in range(1, len(triangle)):            for j in range(1, i):                triangle[i][j] += min(triangle[i - 1][j - 1], triangle[i - 1][j])            triangle[i][0] += triangle[i - 1][0]            triangle[i][i] += triangle[i - 1][i - 1]        return min(triangle[-1])\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题166-分数到小数","url":"/2025/09/24/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98166-%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/","content":"题意给定分子分母，返回其表示的小数，若其有循环则将其循环节用 \"()\" 括起。\n思路模拟手算除法的操作即可，循环节的寻找可以通过使用哈希记录该余数是否出现过。\n实现class Solution {using ll = long long;public:    string fractionToDecimal(int numerator, int denominator) {        ll x = abs(1ll * numerator), y = abs(1ll * denominator);        string ans;        if (1ll * numerator * denominator &lt; 0) ans += '-';        ans += to_string(x / y);        if (x % y == 0) return ans;        ans += '.';        unordered_map&lt;ll, int&gt; rem;        ll r = x % y;        rem[r] = ans.size();        while (r) {            r *= 10;            ans += to_string(r / y);            r %= y;            if (rem.count(r)) {                int p = rem[r];                return ans.substr(0, p) + '(' + ans.substr(p) + ')';            }            rem[r] = ans.size();        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题165-比较版本号","url":"/2025/09/23/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98165-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/","content":"题意给定两个由 '.' 分割开的数字版本号，比较两个版本号的大小。\n思路将两个版本号每一部分转换为数字进行比较就好，只是这里需要注意题目给定的每个数字范围是 所有修订号都可以存储在 32 位整数 中 如果用cpp的话需要开 unsigned 或者 long long。\n实现class Solution {public:    int compareVersion(string version1, string version2) {        vector&lt;unsigned&gt; x, y;        unsigned t = 0;        for (const auto&amp; ch : version1) {            if (ch == '.') {                x.push_back(t);                t = 0;            }            else {                t += 10 * t + (ch - '0');            }        }        x.push_back(t);        t = 0;        for (const auto&amp; ch : version2) {            if (ch == '.') {                y.push_back(t);                t = 0;            }            else {                t += 10 * t + ch - '0';            }        }        y.push_back(t);        while (x.size() &lt; y.size()) x.push_back(0);        while (y.size() &lt; x.size()) y.push_back(0);        if (x &gt; y) return 1;        else if (x &lt; y) return -1;        return 0;    }};\n\nclass Solution:    def compareVersion(self, version1: str, version2: str) -&gt; int:        for i, j in zip_longest(version1.split('.'), version2.split('.'), fillvalue=0):            x = int(i)            y = int(j)            if (x &gt; y):                return 1            elif (x &lt; y):                return -1        return 0\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题3005-最大频率元素计数","url":"/2025/09/22/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983005-%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E5%85%83%E7%B4%A0%E8%AE%A1%E6%95%B0/","content":"题意给定数组 nums ，返回数组中具有最大频率的元素的总频率和。\n思路使用哈希记录每个数的出现频次，再找出最大频次及其和即可。\n实现class Solution {public:    int maxFrequencyElements(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; cnt(101);        for (auto x : nums) cnt[x]++;        int mx = 0, ans = 0;        for (int i = 0; i &lt;= 100; i++) {            if (cnt[i] &gt; mx) {                mx = cnt[i];                ans = cnt[i];            } else if (cnt[i] == mx) ans += cnt[i];        }        return ans;    }};\n\nclass Solution:    def maxFrequencyElements(self, nums: List[int]) -&gt; int:        cnt = [0] * 101        ans = mx = 0        for x in nums:            cnt[x] += 1            if cnt[x] &gt; mx:                mx = cnt[x]                ans = cnt[x]            elif cnt[x] == mx:                ans += cnt[x]        return ans\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题1912-设计电影租借系统","url":"/2025/09/21/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981912-%E8%AE%BE%E8%AE%A1%E7%94%B5%E5%BD%B1%E7%A7%9F%E5%80%9F%E7%B3%BB%E7%BB%9F/","content":"题意所有电影用数组 entries 表示，其中 entries[i] = [shop, movie, price] 分别表示对应商店 shop 有一份价格为 price 的电影 movie \n实现含如下功能的 MovieRentingSystem 类\n\nMovieRentingSystem(int n, vector&lt;vector&lt;int&gt;&gt;&amp; entries) 构造函数\nvector&lt;int&gt; search(int movie) 返回指定电影的未借出且最便宜的 5 个商店，不足 5 则全返回。按价格升序，若价格相同按商店编号升序排序。\nvoid rent(int shop, int movie) 将指定商店的指定电影借出\nvoid drop(int shop, int movie) 将指定电影归还到指定商店\nvector&lt;vector&lt;int&gt;&gt; report() 返回已借出的最便宜的 5 部电影，按 [shop, movie] 返回该借出电影的信息。不足 5 则全返回。按价格升序，若价格相同按商店编号升序，若商店编号相同按电影编号升序排序。\n\n保证所有输入合法，所有商店同一电影最多有一份。\n思路进行一个稍复杂的模拟即可。\n实现class MovieRentingSystem {using ll = long long;unordered_map&lt;ll, int&gt; price;unordered_map&lt;int, set&lt;array&lt;int, 2&gt;&gt;&gt; umovies;set&lt;array&lt;int, 3&gt;&gt; movies;public:    MovieRentingSystem(int n, vector&lt;vector&lt;int&gt;&gt;&amp; entries) {        for (const auto&amp; e : entries) {            int shop = e[0], m = e[1], p = e[2];            price[(1ll * shop) &lt;&lt; 32 | m] = p;            umovies[m].insert({p, shop});        }    }        vector&lt;int&gt; search(int movie) {        vector&lt;int&gt; ans;        for (const auto&amp; arr : umovies[movie]) {            ans.push_back(arr[1]);            if (ans.size() &gt;= 5) break;        }        return ans;    }        void rent(int shop, int movie) {        int p = price[(1ll * shop) &lt;&lt; 32 | movie];        umovies[movie].erase({p, shop});        movies.insert({p, shop, movie});    }        void drop(int shop, int movie) {        int p = price[(1ll * shop) &lt;&lt; 32 | movie];        movies.erase({p, shop, movie});        umovies[movie].insert({p, shop});    }        vector&lt;vector&lt;int&gt;&gt; report() {        vector&lt;vector&lt;int&gt;&gt; ans;        for (const auto&amp; [p, s, m] : movies) {            ans.push_back({s, m});            if (ans.size() &gt;= 5) break;        }        return ans;    }};/** * Your MovieRentingSystem object will be instantiated and called as such: * MovieRentingSystem* obj = new MovieRentingSystem(n, entries); * vector&lt;int&gt; param_1 = obj-&gt;search(movie); * obj-&gt;rent(shop,movie); * obj-&gt;drop(shop,movie); * vector&lt;vector&lt;int&gt;&gt; param_4 = obj-&gt;report(); */\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3508-设计路由器","url":"/2025/09/20/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983508-%E8%AE%BE%E8%AE%A1%E8%B7%AF%E7%94%B1%E5%99%A8/","content":"题意每个数据包包含以下内容 [source, destination, timestamp]\n实现 Router 类有如下功能：\n\nRouter(int memoryLimit) : 初始化，并设置固定内存限制，若未转发包数大于 memoryLimit 则不断丢弃最久的数据包\nbool addPacket(int source, int destination, int timestamp) 添加对应数据包，若已存在完全相同的数据包则添加失败，返回添加结果\nvector&lt;int&gt; forwardPacket() 按先入先出规则返回下一个未被丢弃的数据包\nint getCount(int destination, int startTime, int endTime) 返回尚未转发目的地为 destination 且 startTime &lt;= timeStamp &lt;= endTime 的数据包数量\n\n思路也同样没什么特别的，进行一个模拟就好。\n实现struct Ahash {    size_t operator()(const array&lt;int, 3&gt;&amp; arr) const noexcept {        size_t h1 = hash&lt;int&gt;{}(arr[0]);        size_t h2 = hash&lt;int&gt;{}(arr[1]);        size_t h3 = hash&lt;int&gt;{}(arr[2]);        size_t seed = h1;        seed ^= h2 + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);        seed ^= h3 + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);        return seed;    }};struct Aequal {    bool operator()(const array&lt;int, 3&gt;&amp; x, const array&lt;int, 3&gt;&amp; y) const noexcept {        return x == y;    }};class Router {private:    int limit;    unordered_set&lt;array&lt;int, 3&gt;, Ahash, Aequal&gt; ust;    unordered_map&lt;int, vector&lt;int&gt;&gt; dst2time;    unordered_map&lt;int, int&gt; dst2sz;    queue&lt;array&lt;int, 3&gt;&gt; q;public:    Router(int memoryLimit) {        limit = memoryLimit;        ust.clear();        dst2time.clear();        dst2sz.clear();    }        bool addPacket(int source, int destination, int timestamp) {        auto [it, ok] = ust.insert({source, destination, timestamp});        if (!ok) return ok;        dst2time[destination].push_back(timestamp);        q.push({source, destination, timestamp});        for ( ; q.size() &gt; limit; q.pop()) {            auto [source, destination, timestamp] = q.front();            ust.erase({source, destination, timestamp});            dst2sz[destination]++;        }        return ok;    }        vector&lt;int&gt; forwardPacket() {        if (q.empty()) return {};        auto [source, destination, timestamp] = q.front();        q.pop();        ust.erase({source, destination, timestamp});        dst2sz[destination]++;        return {source, destination, timestamp};    }        int getCount(int destination, int startTime, int endTime) {        if (!dst2time.count(destination)) return 0;        const auto&amp; vec = dst2time[destination];        int t = dst2sz[destination];        auto l = ranges::lower_bound(vec.begin() + t, vec.end(), startTime);        auto r = ranges::upper_bound(vec.begin() + t, vec.end(), endTime);        return r - l;    }};/** * Your Router object will be instantiated and called as such: * Router* obj = new Router(memoryLimit); * bool param_1 = obj-&gt;addPacket(source,destination,timestamp); * vector&lt;int&gt; param_2 = obj-&gt;forwardPacket(); * int param_3 = obj-&gt;getCount(destination,startTime,endTime); */\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3484-设计电子表格","url":"/2025/09/19/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983484-%E8%AE%BE%E8%AE%A1%E7%94%B5%E5%AD%90%E8%A1%A8%E6%A0%BC/","content":"题意实现一个电子表格，包含以下功能：\n\nSpereadsheet(int rows) 初始化一个有 26 列和 rows 行的表格，其中列编号为 A-Z 行编号为 1-rows\nsetCell(string cell, int value) 将格 cell 的值置为 value\nresetCell(string cell) 将格 cell 的值置为 0\ngetValue(string formula) 给定格式形如 =X+Y 的公式，若 X 为单元格则取对应单元格的值，若为数字则取对应数字值，返回 X + Y 的结果\n\n思路同样是没有什么特别的，进行一个模拟即可。\n实现class Spreadsheet {private:    unordered_map&lt;string, int&gt; data;public:    Spreadsheet(int rows) {        data.clear();    }        void setCell(string cell, int value) {        data[cell] = value;    }        void resetCell(string cell) {        data[cell] = 0;    }        int getValue(string formula) {        int plusloc = formula.find('+');        string x = formula.substr(1, plusloc - 1);        string y = formula.substr(plusloc + 1);        int a = isupper(x.front()) ? data[x] : stoi(x);        int b = isupper(y.front()) ? data[y] : stoi(y);        return a + b;    }};/** * Your Spreadsheet object will be instantiated and called as such: * Spreadsheet* obj = new Spreadsheet(rows); * obj-&gt;setCell(cell,value); * obj-&gt;resetCell(cell); * int param_3 = obj-&gt;getValue(formula); */\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3408-设计任务管理器","url":"/2025/09/18/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983408-%E8%AE%BE%E8%AE%A1%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8/","content":"题意实现一个任务管理器系统，有如下功能：\n\n初始化，给定三维数组 tasks 其内 [userId, taskId, priority] 分别表示该任务的用户id 任务id 优先级\n添加一个 userId, taskId, priority 的任务\n将任务id为 taskId 的任务优先级修改为 newPriority\n删除任务id为 taskId 的任务\n返回优先级最高，若有多任务优先级等高则返回任务id最高的任务的用户id\n\n思路那没什么特别的，就是按照题意模拟即可。\n实现class TaskManager {private:    unordered_map&lt;int, int&gt; id2prio;    unordered_map&lt;int, int&gt; id2uid;    priority_queue&lt;array&lt;int, 3&gt;&gt; pq;public:    TaskManager(vector&lt;vector&lt;int&gt;&gt;&amp; tasks) {        for (const auto&amp; t : tasks) {            int uid = t[0], tid = t[1], pri = t[2];            pq.push({pri, tid, uid});            id2prio[tid] = pri;            id2uid[tid] = uid;        }    }        void add(int userId, int taskId, int priority) {        pq.push({priority, taskId, userId});        id2prio[taskId] = priority;        id2uid[taskId] = userId;    }        void edit(int taskId, int newPriority) {        id2prio[taskId] = newPriority;        pq.push({newPriority, taskId, id2uid[taskId]});    }        void rmv(int taskId) {        id2prio[taskId] = id2uid[taskId] = -1;    }        int execTop() {        for ( ; !pq.empty(); pq.pop()) {            auto [pri, tid, uid] = pq.top();            if (pri == id2prio[tid]) {                pq.pop();                id2prio[tid] = -1;                return uid;            }        }        return -1;    }};/** * Your TaskManager object will be instantiated and called as such: * TaskManager* obj = new TaskManager(tasks); * obj-&gt;add(userId,taskId,priority); * obj-&gt;edit(taskId,newPriority); * obj-&gt;rmv(taskId); * int param_4 = obj-&gt;execTop(); */\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2349-设计数字容器系统","url":"/2025/09/17/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982349-%E8%AE%BE%E8%AE%A1%E6%95%B0%E5%AD%97%E5%AE%B9%E5%99%A8%E7%B3%BB%E7%BB%9F/","content":"题意实现一个数字容器系统，包含以功能\n\n在定下标处插入或替换一个数字\n返回给定数字的最小下标\n\n思路下标范围很大有 1 &lt;= index &lt;= 1e9 故而是不能直接数组模拟的，但是题目也明确了各个功能的调用总次数不超过 1e5 因此也无需太在意空间，直接使用哈希进行模拟即可。\n实现class NumberContainers {private:    unordered_map&lt;int, int&gt; loc;    unordered_map&lt;int, set&lt;int&gt;&gt; ump;public:    NumberContainers() {        loc.clear();        ump.clear();    }        void change(int index, int number) {        if (!loc.count(index)) {            loc[index] = number;            ump[number].insert(index);        } else {            ump[loc[index]].erase(index);            if (ump[loc[index]].empty()) ump.erase(loc[index]);            ump[number].insert(index);            loc[index] = number;        }    }        int find(int number) {        if (!ump.count(number)) return -1;        return *ump[number].begin();    }};/** * Your NumberContainers object will be instantiated and called as such: * NumberContainers* obj = new NumberContainers(); * obj-&gt;change(index,number); * int param_2 = obj-&gt;find(number); */\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2197-替换数组中的非互质数","url":"/2025/09/16/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982197-%E6%9B%BF%E6%8D%A2%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%9D%9E%E4%BA%92%E8%B4%A8%E6%95%B0/","content":"题意给定数组 nums ，当 nums 中存在任意两相邻数不互质时将这两数替换为这两数的 lcm， 返回不会再发生合并后的结果。\n思路显然合并的顺序是不会影响最终结果的：x, y 不互质意味着 gcd(x, y) &gt; 1 而两数的 lcm 实际上为两数的质因数分解后取各质因子的最高次幂，也就是说任意一个数 z 若可与 x 或 y 不互质，则其一定与 lcm(x, y) 不互质即 gcd(z, lcm(x, y)) &gt; 1。\n所以仅需一个栈进行维护即可。\n实现class Solution {public:    vector&lt;int&gt; replaceNonCoprimes(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; ans;        for (auto x : nums) {            while (!ans.empty() &amp;&amp; gcd(ans.back(), x) != 1) {                x = lcm(ans.back(), x);                ans.pop_back();            }            ans.push_back(x);        }        return ans;    }};\n\nclass Solution:    def replaceNonCoprimes(self, nums: List[int]) -&gt; List[int]:        ans = []        for x in nums:            while len(ans) &gt; 0 and gcd(x, ans[-1]) &gt; 1:                x = lcm(x, ans[-1])                ans.pop()            ans.append(x)        return ans\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题1935-可以输入的最大单词数","url":"/2025/09/15/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981935-%E5%8F%AF%E4%BB%A5%E8%BE%93%E5%85%A5%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E6%95%B0/","content":"题意给定字符串 brokenLetters 表示键盘破损的键位，以及多个由空格分隔的单词组成的字符串 text ，返回 text 中可以完整打出的单词数量。\n思路简单问题简单做，使用哈希记录破损键盘或直接遍历 brokenLetters 都是可以的，然后遍历每个单词判断其是否含破损键位即可。\n实现class Solution {public:    int canBeTypedWords(string text, string brokenLetters) {        array&lt;int, 26&gt; a;        a.fill(0);        for (const auto&amp; ch : brokenLetters) a[ch - 'a'] = 1;        int ans = 0, ok = 1;        const int n = text.size();        for (int i = 0; i &lt; n; i++) {            if (text[i] == ' ') {                ans += ok;                ok = 1;            }            else if (a[text[i] - 'a']) ok = 0;        }        return ans + ok;    }};\n\nclass Solution:    def canBeTypedWords(self, text: str, brokenLetters: str) -&gt; int:        ans = 0        for word in text.split():            if all(ch not in brokenLetters for ch in word):                ans += 1        return ans\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题966-元音拼写检查器","url":"/2025/09/14/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98966-%E5%85%83%E9%9F%B3%E6%8B%BC%E5%86%99%E6%A3%80%E6%9F%A5%E5%99%A8/","content":"题意给定单词表 wordlist 以及询问若干个 queries ，对于每个询问给出一个字符串 query\n\n若字符串 query 可以再 wordlist 中找到，则返回对应单词表中单词\n若字符串 query 忽视大小写差异后可在 wordlist 中找到，则返回单词表中第一个符合的单词w\n若字符串 query 忽视大小写且各元音字母可以任意替换为其他元音字母后可在 wordlist 中找到，则返回单词表中第一个符合的单词。\n\n思路维护三个哈希表即可：\n\n原单词表的哈希表\n将所有单词转为小写字母的对应单词表\n将所有单词转为小写且元音字母均替换为 '*' 后的对应单词表\n\n然后对询问做同样的处理并进行查询是否存在即可。\n实现class Solution {public:    vector&lt;string&gt; spellchecker(vector&lt;string&gt;&amp; wordlist, vector&lt;string&gt;&amp; queries) {        unordered_set&lt;string&gt; ori(wordlist.begin(), wordlist.end());        unordered_map&lt;string, vector&lt;string&gt;&gt; bigSmall;        unordered_map&lt;string, vector&lt;string&gt;&gt; vowel;        for (const auto&amp; s : wordlist) {            auto t = s;            for (auto&amp; ch : t) {                if (isupper(ch)) ch = char(ch - 'A' + 'a');            }            bigSmall[t].push_back(s);            for (auto&amp; ch : t) {                if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') ch = '*';            }            vowel[t].push_back(s);        }        vector&lt;string&gt; ans;        for (auto&amp; s : queries) {            if (ori.count(s)) {                ans.push_back(s);                continue;            }            for (auto&amp; ch : s) if (isupper(ch)) ch = char(ch - 'A' + 'a');            if (bigSmall.count(s)) {                ans.push_back(bigSmall[s].front());                continue;            }            for (auto&amp; ch : s) if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') ch = '*';            if (vowel.count(s)) {                ans.push_back(vowel[s].front());                continue;            }            ans.push_back(\"\");        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3541-找到频率最高的元音和辅音","url":"/2025/09/13/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983541-%E6%89%BE%E5%88%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84%E5%85%83%E9%9F%B3%E5%92%8C%E8%BE%85%E9%9F%B3/","content":"题意给定小写英文字符串，返回其中出现频次最高的元音字母和辅音字母的频次和。\n思路没什么特别的，只需记录每个字母的出现次数，然后找出现次数最多的元音辅音即可。\n实现class Solution:    def maxFreqSum(self, s: str) -&gt; int:        cnt = Counter(s)        u = v = 0        for i in range(26):            ch = chr(ord('a') + i)            if ch in \"aeiou\":                u = max(u, cnt[ch])            else:                v = max(v, cnt[ch])        return u + v\n\nclass Solution {public:    int maxFreqSum(string s) {        array&lt;int, 26&gt; cnt;        cnt.fill(0);        for (const auto&amp; ch : s) cnt[ch - 'a']++;        int u = 0, v = 0;        for (int i = 0; i &lt; 26; i++) {            char ch = i + 'a';            if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {                u = max(u, cnt[i]);            } else {                v = max(v, cnt[i]);            }        }        return u + v;    }};\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题3227-字符串元音游戏","url":"/2025/09/12/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983227-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%83%E9%9F%B3%E6%B8%B8%E6%88%8F/","content":"题意给定已字符串 s ，小明小红轮流进行游戏，小红先手：\n\n小红每次可以删除 s 中任意包含奇数个元音字符的子字符串\n小明每次可以删除 s 中任意包含偶数个元音字符的子字符串\n\n谁先无法行动则失败。\n判断小红是否必胜。\n思路简单手玩一下：\n若开局无元音字母，显然小明必胜。\n若开局有奇数个元音字母，小红可以直接删除整个字符串，小红胜。\n若开局有偶数个元音字母，小红可以将字符串删至仅含单元音字母，若此时无其他辅音字母则小红胜；若含其他字母小明仅可删除辅音字母，再到小红时小红可将剩余字符全删除，仍是小红胜。\n故而若字符串含元音字母则小红必胜。\n实现class Solution:    def doesAliceWin(self, s: str) -&gt; bool:        for ch in s:            if ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u':                return True        return False\n\nclass Solution {unordered_set&lt;char&gt; ust = {'a', 'e', 'i', 'o', 'u'};public:    bool doesAliceWin(string s) {        int n = 0;        for (const auto&amp; ch : s) {            if (ust.count(ch)) n++;        }        return n != 0;    }};\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题2785-将字符串中的元音字母排序","url":"/2025/09/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982785-%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D%E6%8E%92%E5%BA%8F/","content":"题意给定英文字符串，将其中辅音字母保持不动，元音字母按ASCII序进行排序。\n思路将其中元音字母及对应位置记录下来，排序后填回即可。\n实现class Solution {unordered_set&lt;char&gt; ust{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};public:    string sortVowels(string s) {        const int n = s.size();        vector&lt;int&gt; p;        vector&lt;char&gt; ch;        for (int i = 0; i &lt; n; i++) {            if (ust.count(s[i])) {                ch.push_back(s[i]);                p.push_back(i);            }        }        ranges::sort(ch);        for (int i = 0; i &lt; p.size(); i++) {            s[p[i]] = ch[i];        }        return s;    }};\n\nclass Solution:    def sortVowels(self, s: str) -&gt; str:        t = list(s)        vowels = \"aeiouAEIOU\"        p = []        ch = []        for i, c in enumerate(s):            if c in vowels:                p.append(i)                ch.append(c)        ch.sort()        for i, c in enumerate(ch):            t[p[i]] = c        return ''.join(t)\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题1733-需要教语言的最少人数","url":"/2025/09/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981733-%E9%9C%80%E8%A6%81%E6%95%99%E8%AF%AD%E8%A8%80%E7%9A%84%E6%9C%80%E5%B0%91%E4%BA%BA%E6%95%B0/","content":"题意有 n 种语言， m 个人，其中已知所有人已会的语言，同时知道某些人之间存在朋友关系。两两之间需要会任意同种语言才可交流。现欲教某些人同一种语言，使得所有朋友之间可以互相交流，求最少教几人。\n思路n 和 m 的范围都不是很大，均在 500 以内，那其实可以随便乱搞的。\n这里我是先找到所有存在无法交流朋友的人，枚举所教的语言，所需教的人即为 存在无法交流朋友的人 - 存在无法交流朋友且会该语言的人\n实现class Solution:    def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -&gt; int:        know = list(map(set, languages))                p = set()        for u, v in friendships:            if know[u - 1].isdisjoint(know[v - 1]):                p.add(u - 1)                p.add(v - 1)        ans = len(languages)        for i in range(1, n + 1):            ans = min(ans, len(p) - sum(i in know[x] for x in p))        return ans\n\nclass Solution {public:    int minimumTeachings(int n, vector&lt;vector&lt;int&gt;&gt;&amp; languages, vector&lt;vector&lt;int&gt;&gt;&amp; friendships) {        const int m = languages.size();        vector know(m, vector&lt;bool&gt; (n));        for (int i = 0; i &lt; m; i++) {            for (const auto&amp; x : languages[i]) {                know[i][x - 1] = true;            }        }        unordered_set&lt;int&gt; p;        for (const auto&amp; f : friendships) {            int u = f[0], v = f[1];            u--; v--;            bool need = true;            for (const auto&amp; x : languages[u]) {                if (know[v][x - 1]) {                    need = false;                    break;                }            }            if (need) {                p.insert(u);                p.insert(v);            }        }        int ans = m;        for (int i = 0; i &lt; n; i++) {            int t = 0;            for (const auto&amp; x : p) {                if (know[x][i]) t++;            }            ans = min(ans, int(p.size()) - t);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题2327-知道秘密的人数","url":"/2025/09/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982327-%E7%9F%A5%E9%81%93%E7%A7%98%E5%AF%86%E7%9A%84%E4%BA%BA%E6%95%B0/","content":"题意第 1 天有 1 个人知道了一个秘密，一个人在知道秘密的 forget 天后会遗忘这个秘密，同时一个人在知道秘密的 delay 天后未遗忘前会每天告诉一个新人这个秘密。求第 n 天后有多少人知道这个秘密。\n思路数据范围并不大 1 &lt;= n &lt;= 1000 那显然不是什么数学题不用推什么公式的。\n维护当前知道的人数、当前会每天告诉新人秘密的人数，以及每天新知道秘密的人数进行模拟即可。当前知道的人数 与 每天新知道秘密的人数 可以用 当前会每天告诉新人秘密的人数 更新，而 当前会每天告诉新人秘密的人数 可以通过 forget 天前与 delay 天前 新知道的人数更新。进行一个模拟即可。\n实现mod = 1000000007class Solution:    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -&gt; int:        f = [1] + [0] * (n - 1)        ans = 1        p = 0        for i in range(n):            if i &gt;= delay:                p += f[i - delay]            if i &gt;= forget:                p -= f[i - forget]                ans -= f[i - forget]            f[i] += p            ans += p        return (ans + mod) % mod\n\nclass Solution {static constexpr int mod = 1e9 + 7;public:    int peopleAwareOfSecret(int n, int delay, int forget) {        vector&lt;int&gt; f(n);        int ans = 1, p = 0;        f[0] = 1;        for (int i = 0; i &lt; n; i++) {            if (i &gt;= delay) {                p += f[i - delay];                if (p &gt;= mod) p -= mod;            }            if (i &gt;= forget) {                p -= f[i - forget];                p += mod;                if (p &gt;= mod) p -= mod;                ans -= f[i - forget];                ans += mod;                if (ans &gt;= mod) ans -= mod;            }            f[i] += p;            ans += p;            if (ans &gt;= mod) ans -= mod;        }        return (ans + mod) % mod;    }};\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题1317-将整数转换为两个无零整数的和","url":"/2025/09/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981317-%E5%B0%86%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%B8%A4%E4%B8%AA%E6%97%A0%E9%9B%B6%E6%95%B4%E6%95%B0%E7%9A%84%E5%92%8C/","content":"题意给定一个正整数 n 将其拆分为两个十进制下不含 0 的数的和。\n思路注意到数据范围并不大， 2 &lt;= n &lt;= 1e4 ，那咱们简单问题简单做进行一个枚举即可。\n实现class Solution {public:    vector&lt;int&gt; getNoZeroIntegers(int n) {        auto check = [](int x) -&gt; bool {            string s = to_string(x);            for (char ch : s) {                if (ch == '0') return false;            }            return true;        };        for (int i = 1; i &lt; n; i++) {            if (check(i) &amp;&amp; check(n - i)) return {i, n - i};        }        return {-1};    }};\n\nclass Solution:    def getNoZeroIntegers(self, n: int) -&gt; List[int]:        def check(x):            for ch in str(x):                if ch == '0':                    return False            return True        for i in range(1, n):            if check(i) and check(n - i):                return [i, n - i]        return -1\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题1304-和为零的 N 个不同整数","url":"/2025/09/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981304-%E5%92%8C%E4%B8%BA%E9%9B%B6%E7%9A%84-N-%E4%B8%AA%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0/","content":"题意给定整数 n 返回任意大小为 n 由不同整数组成且和为 0 的数组。\n思路比较简单的构造题，随便写写满足题意就可以了。\n实现class Solution {public:    vector&lt;int&gt; sumZero(int n) {        vector&lt;int&gt; ans(n);        for (int i = 0, t = 1; i &lt; n; i++) {            if (i &amp; 1) {                ans[i] = -(t++);            } else {                ans[i] = t;            }        }        if (n &amp; 1) ans[n - 1] = 0;        return ans;    }};\n\nclass Solution:    def sumZero(self, n: int) -&gt; List[int]:        ans = [0] * n        t = 1        for i in range(n):            if i &amp; 1:                ans[i] = -t                t += 1            else:                ans[i] = t        if n &amp; 1:            ans[-1] = 0        return ans\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题3495-使数组元素都变为零的最少操作次数","url":"/2025/09/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983495-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E9%83%BD%E5%8F%98%E4%B8%BA%E9%9B%B6%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","content":"题意给定一组询问 queries 每个询问给定两数 l, r 表示给出连续的整数数组 [l, r]，对于每个询问的每次操作，可以任选同一数组中的两个数 a, b 令 a = floor(a / 4), b = floor(b / 4) 。求将所有询问的数组中都变为 0 的最小操作次数之和。\n思路a = floor(a / 4) 等价于 a &gt;&gt;= 2 那么将 a 变为 0 的操作次数就是其二进制表示下的长度比二向上取整即 (a.bit_length() + 1) // 2 == a.bit_length() + 1 &gt;&gt; 1。\n但 [l, r] 的范围可能较大，不太好枚举，进行一个式子的推即可。\n实现def cal(x):    t = x.bit_length()    res = (t + 1 &gt;&gt; 1) * (x + 1 - (1 &lt;&lt; t &gt;&gt; 1))    res += sum((i + 1 &gt;&gt; 1) * (1 &lt;&lt; i &gt;&gt; 1) for i in range(1, t))    return resclass Solution:    def minOperations(self, queries: List[List[int]]) -&gt; int:       return sum(cal(r) - cal(l - 1) + 1 &gt;&gt; 1 for l, r in queries) \n\nclass Solution {using ll = long long;public:    long long minOperations(vector&lt;vector&lt;int&gt;&gt;&amp; queries) {        auto cal = [&amp;](int x) -&gt; ll {            int t = bit_width(unsigned(x));            ll res = 1ll * ((t + 1) &gt;&gt; 1) * (x + 1 - (1 &lt;&lt; t &gt;&gt; 1));            for (int i = 1; i &lt; t; i++) {                res += 1ll * ((i + 1) &gt;&gt; 1) * (1 &lt;&lt; i &gt;&gt; 1);            }            return res;        };        ll ans = 0;        for (const auto&amp; q : queries) {            ans += (cal(q[1]) - cal(q[0] - 1) + 1) &gt;&gt; 1;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题2749-得到整数零需要执行的最少操作数","url":"/2025/09/05/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982749-%E5%BE%97%E5%88%B0%E6%95%B4%E6%95%B0%E9%9B%B6%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0/","content":"题意给定两个整数 num1 与 num2 ，每一次操作可任选  令  。判断是否可以将 num1 减为 0 并求出最少操作次数。\n思路注意到 1 &lt;= num1 &lt;= 1e9 -1e9 &lt;= num2 &lt;= 1e9，显然最多的操作次数不会超过 40 次。对操作次数进行枚举即可。\n显然在操作 k 次后，剩余数转为二进制的 1 数量必须小于 k 且 剩余的数大于等于 k \n实现class Solution {using ll = long long;using ull = unsigned long long;public:    int makeTheIntegerZero(int num1, int num2) {        for (int k = 1; k &lt;= 40; k++) {            ll t = num1 - 1ll * num2 * k;            if (t &lt;= 0) break;            if (popcount(ull(t)) &lt;= k &amp;&amp; t &gt;= k) return k;        }        return -1;    }};\n\nclass Solution:    def makeTheIntegerZero(self, num1: int, num2: int) -&gt; int:        for k in range(1, 40):            t = num1 - k * num2            if t &lt;= 0:                break            if t.bit_count() &lt;= k and t &gt;= k:                return k        return -1\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题3516-找到最近的人","url":"/2025/09/04/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983516-%E6%89%BE%E5%88%B0%E6%9C%80%E8%BF%91%E7%9A%84%E4%BA%BA/","content":"题意给定三个整数表示三个人的位置，第一第二人均向第三人以相同速度走去而第三人不动，求谁先碰上第三人。\n思路没什么特别的，两人相遇时间显然可以用距离表示，比较第一第二人与第三人的距离即可。\n实现class Solution {public:    int findClosest(int x, int y, int z) {        int t = abs(x - z) - abs(y - z);        if (t &lt; 0) return 1;        else if (t == 0) return 0;        return 2;    }};\n\nclass Solution:    def findClosest(self, x: int, y: int, z: int) -&gt; int:        t = abs(x - z) - abs(y - z)        if t &lt; 0:            return 1        elif t == 0:            return 0        return 2\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题3027-人员站位的方案数II","url":"/2025/09/03/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983027-%E4%BA%BA%E5%91%98%E7%AB%99%E4%BD%8D%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0II/","content":"题意给定 n 个点，求有多少点对 (A, B) 满足 A 在 B 的左上角且以 AB 为对角线的矩形内无其他点。\n思路那和昨天的题是完全一样的，只是数据范围进行了增强 1 &lt;= n &lt;= 1000 ，那就没办法继续暴力了，使用昨日的cpp实现方法：按坐标进行排序即可。\n实现class Solution:    def numberOfPairs(self, points: List[List[int]]) -&gt; int:        points.sort(key=lambda p: (p[0], -p[1]))        ans = 0        for i, (x0, y0) in enumerate(points):            my = -inf            for (x1, y1) in points[i + 1 : ]:                if y1 &lt;= y0 and y1 &gt; my:                    my = y1                    ans += 1                if my &gt;= y0:                    break        return ans\n\nclass Solution {public:    int numberOfPairs(vector&lt;vector&lt;int&gt;&gt;&amp; points) {        ranges::sort(points, [&amp;](const auto&amp; x, const auto&amp; y) {            if (x[0] == y[0]) return x[1] &gt; y[1];            return x[0] &lt; y[0];        });        int ans = 0;        const int n = points.size();        for (int i = 0; i &lt; n; i++) {            int my = INT_MIN;            for (int j = i + 1; j &lt; n &amp;&amp; my &lt; points[i][1]; j++) {                if (points[j][1] &lt;= points[i][1] &amp;&amp; points[j][1] &gt; my) {                    my = points[j][1];                    ans++;                }            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题3025-人员站位的方案数I","url":"/2025/09/02/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983025-%E4%BA%BA%E5%91%98%E7%AB%99%E4%BD%8D%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0I/","content":"题意给定 n 个点，求有多少点对 (A, B) 满足 A 在 B 的左上角且以 AB 为对角线的矩形内无其他点。\n思路注意到数据范围很小 1 &lt;= n &lt;= 50 所以可以直接暴力判断（见python）实现。\n也可以对点的坐标进行排序判断（见cpp实现）。\n实现class Solution:    def numberOfPairs(self, points: List[List[int]]) -&gt; int:        ans = 0        for x0, y0 in points:            for x1, y1 in points:                if (x1 == x0 and y1 == y0) or (x1 &lt; x0 or y1 &gt; y0):                    continue                ans += 1                for x2, y2 in points:                    if (x0 == x2 and y0 == y2) or (x1 == x2 and y1 == y2):                        continue                    if x0 &lt;= x2 &lt;= x1 and y1 &lt;= y2 &lt;= y0:                        ans -= 1                        break        return ans\n\nclass Solution {public:    int numberOfPairs(vector&lt;vector&lt;int&gt;&gt;&amp; points) {        ranges::sort(points, [&amp;](const auto&amp; x, const auto&amp; y) {            if (x[0] == y[0]) return x[1] &gt; y[1];            return x[0] &lt; y[0];        });        int ans = 0;        const int n = points.size();        for (int i = 0; i &lt; n; i++) {            int my = INT_MIN;            for (int j = i + 1; j &lt; n &amp;&amp; my &lt; points[i][1]; j++) {                if (points[j][1] &lt;= points[i][1] &amp;&amp; points[j][1] &gt; my) {                    my = points[j][1];                    ans++;                }            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题1792-最大平均通过率","url":"/2025/09/01/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981792-%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E9%80%9A%E8%BF%87%E7%8E%87/","content":"题意给定每个班级的总人数以及通过考试的人数，同时给定 extraStudents 个保证可以通过考试的人数，需将这 extraStudents 个学生分配到各个班级，使得各班级的平均通过率最大。求最大班级平均通过率。\n思路可以发现给不同的班级分配必过学生对通过率的影响是不同的，那直接根据这个影响进行排序开贪即可。由于有多个额外学生，使用优先队列进行维护就好。\n实现class Solution {public:    double maxAverageRatio(vector&lt;vector&lt;int&gt;&gt;&amp; classes, int extraStudents) {        auto cmp = [&amp;](const auto&amp; x, const auto&amp; y) {            return 1ll * (x[1] - x[0]) * (y[1] + 1) * y[1] &lt; 1ll * (y[1] - y[0]) * (x[1] + 1) * x[1];        };        priority_queue&lt;array&lt;int, 2&gt;, vector&lt;array&lt;int, 2&gt;&gt;, decltype(cmp)&gt; pq(cmp);        for (const auto&amp; vec : classes) {            pq.push({vec[0], vec[1]});        }        while (extraStudents--) {            auto [x, y] = pq.top();            pq.pop();            pq.push({x + 1, y + 1});        }        double s = 0;        int n = classes.size();        while (!pq.empty()) {            auto [x, y] = pq.top();            pq.pop();            s += 1.0 * x / y;        }        return s / n;    }};\n\nclass Solution:    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -&gt; float:        pq = [(-((a + 1) / (b + 1) - a / b), a, b) for a, b in classes]        heapify(pq)        for _ in range(extraStudents):            _, a, b = pq[0]            a += 1            b += 1            heapreplace(pq, (-((a + 1) / (b + 1) - a / b), a, b))        return sum(a / b for _, a, b in pq) / len(pq)\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题37-解数独","url":"/2025/08/31/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9837-%E8%A7%A3%E6%95%B0%E7%8B%AC/","content":"题意给定保证仅有单个解的数独，找到其的解。\n思路这确实没什么好的做法，直接 dfs 开搜即可。\n实现class Solution {static constexpr int N = 9;public:    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {        bool row[N][N]= {};        bool col[N][N]= {};        bool t[3][3][N]= {};        vector&lt;array&lt;int, 2&gt;&gt; spaces;        for (int i = 0; i &lt; N; i++) {            for (int j = 0; j &lt; N; j++) {                if (board[i][j] == '.') spaces.push_back({i, j});                else {                    int x = board[i][j] - '1';                    row[i][x] = col[j][x] = t[i / 3][j / 3][x] = true;                }            }        }        const int n = spaces.size();        auto dfs = [&amp;](this auto&amp;&amp; self, int loc) -&gt; bool {            if (loc == n) return true;            auto [i, j] = spaces[loc];            for (int x = 0; x &lt; N; x++) {                if (row[i][x] || col[j][x] || t[i / 3][j / 3][x]) continue;                row[i][x] = col[j][x] = t[i / 3][j / 3][x] = true;                board[i][j] = char('0' + x + 1);                if (self(loc + 1)) return true;                row[i][x] = col[j][x] = t[i / 3][j / 3][x] = false;            }            return false;        };        dfs(0);    }};\n\nclass Solution:    def solveSudoku(self, board: List[List[str]]) -&gt; None:        N = 9        row = [0] * (N * N)        col = [0] * (N * N)        t = [0] * (3 * 3 * N)        spaces = []        for i, tmp in enumerate(board):            for j, x in enumerate(tmp):                if x == '.':                    spaces.append((i, j))                else:                    tmp = int(x) - 1                    row[i * N + tmp] = 1                    col[j * N + tmp] = 1                    t[i // 3 * 3 * N + j // 3 * N + tmp] = 1        n = len(spaces)        def dfs(loc):            if loc == n:                return True            i, j = spaces[loc]            for x in range(N):                if row[i * N + x] or col[j * N + x] or t[i // 3 * N * 3 + j // 3 * N + x]:                    continue                row[i * N + x] = col[j * N + x] = t[i // 3 * N * 3 + j // 3 * N + x] = 1                board[i][j] = str(x + 1)                if dfs(loc + 1):                    return True                row[i * N + x] = col[j * N + x] = t[i // 3 * N * 3 + j // 3 * N + x] = 0            return False        dfs(0)\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题36-有效的数独","url":"/2025/08/30/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9836-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/","content":"题意给定一个已经填了部分的数独，判断所填部分是否合法。\n思路就是简单模拟一下判断是否每行每列每九宫格无重即可。\n实现class Solution {static constexpr int N = 9;public:    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {        array&lt;int, 10&gt; vis;        for (int i = 0; i &lt; N; i++) {            vis.fill(0);            for (int j = 0; j &lt; N; j++) {                if (board[i][j] == '.') continue;                int&amp; t = vis[board[i][j] - '0'];                if (t) return false;                t++;            }            vis.fill(0);            for (int j = 0; j &lt; N; j++) {                if (board[j][i] == '.') continue;                int&amp; t = vis[board[j][i] - '0'];                if (t) return false;                t++;            }        }        for (int i = 0; i &lt; N; i += 3) {            for (int j = 0; j &lt; N; j += 3) {                vis.fill(0);                for (int x = 0; x &lt; 3; x++)                for (int y = 0; y &lt; 3; y++)                if (isdigit(board[i + x][j + y])) {                    int&amp; t = vis[board[i + x][j + y] - '0'];                    if (t) return false;                    t++;                }            }        }        return true;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3021-Alice和Bob玩鲜花游戏","url":"/2025/08/29/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983021-Alice%E5%92%8CBob%E7%8E%A9%E9%B2%9C%E8%8A%B1%E6%B8%B8%E6%88%8F/","content":"题意Alice 和 Bob 站在环形花环上回合游戏。Alice 和 Bob 之间顺时针有 x 朵花 逆时针有 y 朵花，每回合可任选一侧摘下一朵花，若某次行动后两者间一侧无花则该行动者胜利，Alice 先手。对于给定的数 n 和 m 有 1 &lt;= x &lt;= n 与 1 &lt;= y &lt;= m ，求有多少对 (x, y) 满足 Alice 必胜\n思路转换一下就是两堆牌轮流取一张，谁先取到某堆最后一张则胜利。那就是很经典的博弈问题了，我们先手玩一下：\n\n任意一堆为 0 ，那显然是该回合玩家失败（上一回合的玩家将某堆摸为0）\n两堆均为偶数，不论先手摸哪一堆，只要后手同样摸同一堆，局面就仍可保持为两堆偶直到某一堆为0，故而有先手必败\n一堆奇数一堆偶数，先手玩家只要选择偶数堆进行取牌，局面就会变为两堆偶即上一种情况也即为下一个玩家必败，故先手必胜\n两堆奇数，不论先手摸哪一堆，后手只要摸另一堆就会造成双偶数局面，故而有先手必败\n\n综上，合法开局 (x, y) 中有且仅有 x 与 y 一奇一偶时满足 Alice 必胜，进行计算对应数量即可。\n实现class Solution {using ll = long long;public:    long long flowerGame(int n, int m) {        return 1ll * (n + 1 &gt;&gt; 1) * (m &gt;&gt; 1) + 1ll * (n &gt;&gt; 1) * (m + 1 &gt;&gt; 1);    }};\n\nclass Solution:    def flowerGame(self, n: int, m: int) -&gt; int:        return (n + 1) // 2 * (m // 2) + n // 2 * ((m + 1) // 2)\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题3446-按对角线进行矩阵排序","url":"/2025/08/28/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983446-%E6%8C%89%E5%AF%B9%E8%A7%92%E7%BA%BF%E8%BF%9B%E8%A1%8C%E7%9F%A9%E9%98%B5%E6%8E%92%E5%BA%8F/","content":"题意给定方形矩阵，将其左下部分的对角线按非增排序（含中线），将其右上部分的对角线按非减排序。\n思路好像也没什么特别的做法与性质，就是列出每条对角线的数字按照对应规则排序后再放回即可。\n实现class Solution {public:    vector&lt;vector&lt;int&gt;&gt; sortMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {        const int n = grid.size();        for (int i = 0; i &lt; n; i++) {            vector&lt;int&gt; tmp;            for (int j = 0; i + j &lt; n; j++) tmp.push_back(grid[i + j][j]);            ranges::sort(tmp, greater());            for (int j = 0; i + j &lt; n; j++) grid[i + j][j] = tmp[j];        }        for (int i = 1; i &lt; n; i++) {            vector&lt;int&gt; tmp;            for (int j = 0; i + j &lt; n; j++) tmp.push_back(grid[j][i + j]);            ranges::sort(tmp);            for (int j = 0; i + j &lt; n; j++) grid[j][i + j] = tmp[j];        }        return grid;    }};\n\nclass Solution:    def sortMatrix(self, grid: List[List[int]]) -&gt; List[List[int]]:        n = len(grid)        for i in range(n):            tmp = [grid[i + j][j] for j in range(n - i)]            tmp.sort(reverse=True)            for j in range(n - i):                grid[i + j][j] = tmp[j]        for i in range(1, n):            tmp = [grid[j][i + j] for j in range(n - i)]            tmp.sort()            for j in range(n - i):                grid[j][i + j] = tmp[j]        return grid\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题3459-最长V形对角线段的长度","url":"/2025/08/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983459-%E6%9C%80%E9%95%BFV%E5%BD%A2%E5%AF%B9%E8%A7%92%E7%BA%BF%E6%AE%B5%E7%9A%84%E9%95%BF%E5%BA%A6/","content":"题意给定二维矩阵，对 V形对角线段 定义如下：\n\n线段必须从 1 开始，线段上数形如 1, 2, 0, 2, 0 ...\n沿某一对角线方向扩展，最多允许顺时针 90° 转变一次方向\n\n求矩阵内最长 V行对角线段 长度。\n思路那没有什么特别的性质，数据范围也比较合适 1 &lt;= n, m &lt;= 500 ，那就直接 dfs 搜索即可。\n实现class Solution {static constexpr array&lt;int, 2&gt; nxt[] = {    {1, 1}, {1, -1}, {-1, -1}, {-1, 1}};public:    int lenOfVDiagonal(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {        const int n = grid.size(), m = grid.front().size();        int ans = 0;        vector mem(2, vector (4, vector (n, vector&lt;int&gt; (m))));        auto dfs = [&amp;](this auto&amp;&amp; self, int x, int y, int to, int k, bool turn) -&gt; int {            auto [tx, ty] = nxt[to];            x += tx; y += ty;            if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || grid[x][y] != k) return 0;            int&amp; tmp = mem[turn][to][x][y];            if (tmp) return tmp;            tmp = self(x, y, to, k ^ 2, turn) + 1;            if (turn) {                tmp = max(tmp, self(x, y, (to + 1) % 4, k ^ 2, false) + 1);            }            return tmp;        };                for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; m; j++) {                if (grid[i][j] == 1) {                    for (int k = 0; k &lt; 4; k++) {                        ans = max(ans, dfs(i, j, k, 2, true) + 1);                    }                }            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3000-对角线最长的矩形的面积","url":"/2025/08/26/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983000-%E5%AF%B9%E8%A7%92%E7%BA%BF%E6%9C%80%E9%95%BF%E7%9A%84%E7%9F%A9%E5%BD%A2%E7%9A%84%E9%9D%A2%E7%A7%AF/","content":"题意给定一些矩形的长宽，求对角线最长的矩形的面积，若存在多个矩形对角线同长，返回对角线最长且面积最大的矩形面积。\n思路直接遍历矩阵进行计算比较即可，避免开方的耗时与精度问题直接使用对角线的平方进行比较就好。\n实现class Solution {public:    int areaOfMaxDiagonal(vector&lt;vector&lt;int&gt;&gt;&amp; dimensions) {        int mx = 0, mxspace = 0;        for (const auto&amp; vec : dimensions) {            int x = vec[0], y = vec[1];            int t = x * x + y * y;            if (t &gt; mx) {                mx = t;                mxspace = x * y;            } else if (t == mx) {                mxspace = max(mxspace, x * y);            }        }        return mxspace;    }};\n\nclass Solution:    def areaOfMaxDiagonal(self, dimensions: List[List[int]]) -&gt; int:        return max((x * x + y * y, x * y) for x, y in dimensions)[1]\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题498-对角线遍历","url":"/2025/08/25/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98498-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/","content":"题意给定矩阵，返回将矩阵按对角线遍历展开的结果。\n思路就是简单的模拟题，注意处理好边界即可。\n实现class Solution:    def findDiagonalOrder(self, mat: List[List[int]]) -&gt; List[int]:        n = len(mat)        m = len(mat[0])        ans = [0] * (m * n)        tot = 0        for i in range(0, n + m - 1):            mn = max(i - m + 1, 0)            mx = min(i, n - 1)            if i &amp; 1:                for j in range(mn, mx + 1):                    ans[tot] = mat[j][i - j]                    tot += 1            else:                for j in range(mx, mn - 1, -1):                    ans[tot] = mat[j][i - j]                    tot += 1        return ans\n\nclass Solution {public:    vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; mat) {        const int n = mat.size(), m = mat.front().size();        vector&lt;int&gt; ans(n * m);        for (int i = 0, tot = 0; i &lt; n + m - 1; i++) {            int mn = max(i - m + 1, 0);            int mx = min(i, n - 1);            if (i &amp; 1) {                for (int j = mn; j &lt;= mx; j++) ans[tot++] = mat[j][i - j];            } else {                for (int j = mx; j &gt;= mn; j--) ans[tot++] = mat[j][i - j];            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题1493-删掉一个元素以后全为1的最长子数组","url":"/2025/08/24/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981493-%E5%88%A0%E6%8E%89%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BB%A5%E5%90%8E%E5%85%A8%E4%B8%BA1%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84/","content":"题意给定 0/1 数组，需从中删除任意一个元素，求剩余元素中最长仅含 1 的子数组长度。\n思路可以考虑枚举删哪一个数，使用前后缀处理该数前后连续的 1 的个数即可（见cpp实现）。\n也可以考虑使用滑动窗口，我们必须删除一个数，那显然窗口内最多同时可以有一个 0 ，维护一下窗口的左右范围以及区间内 0 的个数即可（见 python实现）。\n实现class Solution:    def longestSubarray(self, nums: List[int]) -&gt; int:        l = cnt = ans = 0        for r, x in enumerate(nums):            if x == 0:                cnt += 1            while cnt &gt; 1:                if nums[l] == 0:                    cnt -= 1                l += 1            ans = max(r - l, ans)        return ans\n\nclass Solution {public:    int longestSubarray(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        vector&lt;int&gt; pre(n + 1);        for (int i = 0; i &lt; n; i++) {            if (nums[i]) pre[i + 1] = pre[i] + 1;        }        int ans = 0;        for (int i = n - 1, suf = 0; i &gt;= 0; i--) {            ans = max(ans, pre[i] + suf);            if (nums[i]) {                suf++;            } else {                suf = 0;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题3197-包含所有1的最小矩形面积II","url":"/2025/08/23/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983197-%E5%8C%85%E5%90%AB%E6%89%80%E6%9C%891%E7%9A%84%E6%9C%80%E5%B0%8F%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AFII/","content":"题意给定 0/1 矩阵，需找到 3 个不重叠且面积非零的矩形，将矩阵中所有 1 都包含在这三矩形中。求最小三矩形面积和。\n思路这里的数据范围是不大的 1 &lt;= n, m &lt;= 30 那直接进行枚举三个矩阵的边界然后使用昨天的贪心计算方法即可。这里可以注意到共有 6 种划分方法，但是其中 3 种可以通过旋转矩阵等价得来，因此可以稍稍偷懒一些。\n实现class Solution {public:    int minimumSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {        auto cal = [&amp;](int a, int b, int c, int d) -&gt; int {            int le = 100, lo = 100;            int hi = 0, ri = 0;            for (int i = a; i &lt; b; i++)                for (int j = c; j &lt; d; j++)                    if (grid[i][j]) {                        le = min(le, j);                        lo = min(lo, i);                        hi = max(hi, i);                        ri = max(ri, j);                    }                                return (hi - lo + 1) * (ri - le + 1);        };        auto rotate = [&amp;]() -&gt; void {            const int n = grid.size(), m = grid.front().size();            vector tmp(m, vector&lt;int&gt; (n));            for (int i = 0; i &lt; n; i++) {                for (int j = 0; j &lt; m; j++) {                    tmp[j][n - i - 1] = grid[i][j];                }            }            swap(tmp, grid);        };        int ans = 1e9;        auto work = [&amp;]() -&gt; void {            const int n = grid.size(), m = grid.front().size();            if (n &gt;= 3) {                for (int i = 1; i &lt; n; i++)                    for (int j = i + 1; j &lt; n; j++) {                        int tmp = cal(0, i, 0, m);                        tmp += cal(i, j, 0, m);                        tmp += cal(j, n, 0, m);                        ans = min(ans, tmp);                    }            }            if (n &gt;= 2 &amp;&amp; m &gt;= 2) {                for (int i = 1; i &lt; n; i++)                    for (int j = 1; j &lt; m; j++) {                        int tmp = cal(0, i, 0, m);                        tmp += cal(i, n, 0, j);                        tmp += cal(i, n, j, m);                        ans = min(ans, tmp);                        tmp = cal(i, n, 0, m);                        tmp += cal(0, i, 0, j);                        tmp += cal(0, i, j, m);                        ans = min(ans, tmp);                    }            }        };        work();        rotate();        work();        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3195-包含所有1的最小矩形面积I","url":"/2025/08/22/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983195-%E5%8C%85%E5%90%AB%E6%89%80%E6%9C%891%E7%9A%84%E6%9C%80%E5%B0%8F%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AFI/","content":"题意给定 0/1 矩阵，求包含所有 1 的最小矩阵面积。\n思路需要包含所有的 1 那找到最上、最下、最左最右的 1 的位置并以其为答案的边即可。\n实现class Solution {public:    int minimumArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {        const int n = grid.size(), m = grid.front().size();        int hi, lo = -1, le = m, ri = -1;        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; m; j++) {                if (grid[i][j]) {                    hi = i;                    if (lo == -1) lo = i;                    le = min(le, j);                    ri = max(ri, j);                }            }        }        return (hi - lo + 1) * (ri - le + 1);    }};\n\nclass Solution:    def minimumArea(self, grid: List[List[int]]) -&gt; int:        lo = inf        hi = -1        le = inf        ri = -1        for i, row in enumerate(grid):            for j, x in enumerate(row):                if x:                    lo = min(lo, i)                    le = min(le, j)                    hi = max(hi, i)                    ri = max(ri, j)        return (hi - lo + 1) * (ri - le + 1)\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题1504-统计全1子矩形","url":"/2025/08/21/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981504-%E7%BB%9F%E8%AE%A1%E5%85%A81%E5%AD%90%E7%9F%A9%E5%BD%A2/","content":"题意给定 m * n 的 0/1 矩阵，求其中全为 1 的子矩阵个数。\n思路好像很不好做啊，但是我们观察数据范围 1 &lt;= m, n &lt;= 150 那可以随便乱搞了。\n仔细一想，是不是可以转换为我们曾经做过的题：有 n 个任意高度宽为 1 的柱子并排，求矩阵面积和。这里我们可以枚举柱子的底部，高度则为纵向上连续的 1 的个数，那就很好做了。\n实现class Solution {public:    int numSubmat(vector&lt;vector&lt;int&gt;&gt;&amp; mat) {        const int n = mat.size(), m = mat.front().size();        vector&lt;int&gt; h(m);        int ans = 0;        for (int i = 0; i &lt; n; i++) {            vector&lt;array&lt;int, 3&gt;&gt; stk;            for (int j = 0, left = -1; j &lt; m; j++) {                if (mat[i][j]) {                    h[j]++;                    while (!stk.empty() &amp;&amp; stk.back()[0] &gt;= h[j]) stk.pop_back();                    if (stk.empty()) {                        int t = (j - left) * h[j];                        ans += t;                        stk.push_back({h[j], j, t});                    } else {                        auto [high, l, t] = stk.back();                        t += (j - l) * h[j];                        ans += t;                        stk.push_back({h[j], j, t});                    }                } else {                    h[j] = 0;                    stk.clear();                    left = j;                }            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1277-统计全为1的正方形子矩阵","url":"/2025/08/20/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981277-%E7%BB%9F%E8%AE%A1%E5%85%A8%E4%B8%BA1%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%AD%90%E7%9F%A9%E9%98%B5/","content":"题意给定 m * n 的 0/1 数组，返回其中由全 1 构成的正方形个数。\n思路那与昨天的思路其实是非常类似的，只是昨天是求全 0 的子数组个数，今天是求全 1 的正方形个数，也就是从 1 维变 2 维了而已。使用同样的思想：往已有全 1 正方形的右/下/右下再添加一个 1 可以贡献多少个新正方形呢，由于这里需要考虑三个方向的情况，故而不再简单的使用一个变量维护，而是新开一个二维数组做递推，或者直接在 matrix 上做。\n实现class Solution {public:    int countSquares(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {        const int n = matrix.size(), m = matrix.front().size();        int ans = 0;        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; m; j++) {                if (i &amp;&amp; j &amp;&amp; matrix[i][j]) {                    matrix[i][j] += min({matrix[i - 1][j - 1], matrix[i - 1][j], matrix[i][j - 1]});                }                ans += matrix[i][j];            }        }        return ans;    }};\n\nclass Solution:    def countSquares(self, matrix: List[List[int]]) -&gt; int:        n = len(matrix)        m = len(matrix[0])        ans = 0        for i in range(n):            for j in range(m):                if i and j and matrix[i][j]:                    matrix[i][j] += min(matrix[i - 1][j - 1], matrix[i - 1][j], matrix[i][j - 1])                ans += matrix[i][j]        return ans\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题2348-全 0 子数组的数目","url":"/2025/08/19/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982348-%E5%85%A8-0-%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定数组 nums ，返回全部为 0 的子数组数目。\n思路比较简单的思路就是找到每个全为零的块，然后单个全零块可以分割为多少个子数组呢，若长度为 n 显然是有 n 个长度为 1 的子数组， n - 1 个长度为 2 的子数组.... 那显然应该是一个等差数列求和  个。\n虽然都是 O(n) 的，但乘除的常数是比较大，这里还有一个比较经典的思路：对于一个全零的数组，在其末尾再添加一个 0 ，新添加的零可以贡献多少全零子数组呢，显然是原数组长度加一，根据此思路进行计算即可。\n实现cpp 与 等差\nclass Solution {using ll = long long;public:    long long zeroFilledSubarray(vector&lt;int&gt;&amp; nums) {        ll ans = 0;        const int n = nums.size();        for (int i = 0; i &lt; n; i++) {            if (nums[i]) continue;            int j;            for (j = i + 1; j &lt; n &amp;&amp; nums[j] == 0; j++);            ans += 1ll * (j - i + 1) * (j - i) / 2;            i = j - 1;        }        return ans;    }};\n\ncpp\nclass Solution {using ll = long long;public:    long long zeroFilledSubarray(vector&lt;int&gt;&amp; nums) {        ll ans = 0;        int cur = 0;        for (const auto&amp; x : nums) {            if (x) cur = 0;            else ans += ++cur;        }        return ans;    }};\n\npython\nclass Solution:    def zeroFilledSubarray(self, nums: List[int]) -&gt; int:        ans = 0        cur = 0        for x in nums:            if x == 0:                cur += 1                ans += cur            else:                cur = 0        return ans\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题679-24 点游戏","url":"/2025/08/18/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98679-24-%E7%82%B9%E6%B8%B8%E6%88%8F/","content":"题意给定长度为 4 的数组 cards, 可以将其上数字按任意顺序排列并在任意合法位置加上符号 + - * / ( ) ，判断是否可以通过得到的式子算出结果 24\n思路注意到数据量并不大，直接进行枚举模拟即可。\n实在有点麻烦，这里我就不用python再写一遍了。\n实现class Solution {static constexpr long double eps = 1e-9;using ld = long double;public:    bool judgePoint24(vector&lt;int&gt;&amp; cards) {        auto dfs = [&amp;](this auto&amp;&amp; self, vector&lt;ld&gt;&amp; nums) -&gt; bool {            if (nums.size() == 1) return fabsl(nums[0] - 24.0) &lt;= eps;            for (int i = 0; i &lt; nums.size(); i++) {                for (int j = 0; j &lt; nums.size(); j++) {                    if (i == j) continue;                    vector&lt;ld&gt; nxt;                    for (int k = 0; k &lt; nums.size(); k++) if (k != i &amp;&amp; k != j) nxt.push_back(nums[k]);                    for (char op : {'+', '-', '*', '/'}) {                        if ((op == '+' || op == '*') &amp;&amp; i &gt; j) continue;                        if (op == '+') nxt.push_back(nums[i] + nums[j]);                        if (op == '-') nxt.push_back(nums[i] - nums[j]);                        if (op == '*') nxt.push_back(nums[i] * nums[j]);                        if (op == '/' &amp;&amp; fabsl(nums[j]) &gt; eps) nxt.push_back(nums[i] / nums[j]);                        if (nxt.size() == nums.size() - 1 &amp;&amp; self(nxt)) return true;                        if (!nxt.empty()) nxt.pop_back();                    }                }            }            return false;        };        vector&lt;ld&gt; a(cards.begin(), cards.end());        return dfs(a);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题837-新21点","url":"/2025/08/17/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98837-%E6%96%B021%E7%82%B9/","content":"题意给定正整数 n k maxPts。当爱丽丝分数小于 k 时就会不停抽卡，每次抽卡等概率得分 [1, maxPts] ，求爱丽丝最总分数不超过 n 的概率。\n思路求不超过 n 的概率，又分数小于 k 时会不停抽卡，那也就是求得分为 [k, n] 的概率。那就是一个比较经典的概率dp了，进行一个递推求概率即可。\n实现class Solution {public:    double new21Game(int n, int k, int maxPts) {        if (maxPts &lt;= n - k + 1 || k == 0) return 1.0;        vector&lt;double&gt; f(n + 1);        f[0] = 1.0;        double pre = 1.0;        for (int i = 1; i &lt;= n; i++) {            if (i &gt; maxPts) pre -= f[i - maxPts - 1];            f[i] = pre / maxPts;            if (i &lt; k) pre += f[i];        }        return accumulate(f.begin() + k, f.end(), 0.0);    }};\n\nclass Solution:    def new21Game(self, n: int, k: int, maxPts: int) -&gt; float:        if n - k + 1 &gt;= maxPts or k == 0:            return 1                f = [1] + [0] * n        pre = 1        for i in range(1, n + 1):            if i &gt; maxPts:                pre -= f[i - maxPts - 1]            f[i] = pre / maxPts            if (i &lt; k):                pre += f[i]        return sum(f[k :])\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题1323-6 和 9 组成的最大数字","url":"/2025/08/16/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981323-6-%E5%92%8C-9-%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/","content":"题意给定仅由 6 和 9 组成的正整数 num。可以将 num 中一个 6 变成 9 ，或将一个 9 变成 6 或不进行操作。求可以得到的最大数字。\n思路由于题目给定了是正整数，那可以直接贪心地找到第一个 6 将其变为 9 即可，若无 6 直接不操作。\n实现class Solution {public:    int maximum69Number (int num) {        string n = to_string(num);        for (int i = 0; i &lt; n.size(); i++) {            if (n[i] == '6') {                n[i] = '9';                break;            }        }        return stoi(n);    }};\n\nclass Solution:    def maximum69Number (self, num: int) -&gt; int:        s = str(num)        for i in range(len(s)):            if s[i] == '6':                return int(s[ : i] + '9' + s[i + 1 : ])        return num\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题342-4的幂","url":"/2025/08/15/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98342-4%E7%9A%84%E5%B9%82/","content":"题意给定整数 n 判断其是否为 4 的幂次\n思路简单问题简单做就好。\n当然也有更加快的，首先 4 的幂次，肯定也是 2 的幂次  嘛；那前几天我们就有做过判断是否为 2 的幂次的题。\n但显然还是不够判断的，我们转成二进制视角，还可以发现 4 的幂次是在第 0 2 4 6... 等位上有 1 的（4 == 1 &lt;&lt; 2），将其提取出来使用位掩码 0x55555555 即可。\n实现class Solution {public:    bool isPowerOfFour(int n) {        return n &gt; 0 &amp;&amp; (n &amp; -n) == n &amp;&amp; (n &amp; 0x55555555);    }};\n\nclass Solution:    def isPowerOfFour(self, n: int) -&gt; bool:        return n &gt; 0 and (n &amp; -n) == n and (n &amp; 0x55555555) &gt; 0\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题1780-判断一个数字是否可以表示成三的幂的和","url":"/2025/08/14/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981780-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A1%A8%E7%A4%BA%E6%88%90%E4%B8%89%E7%9A%84%E5%B9%82%E7%9A%84%E5%92%8C/","content":"题意给定正整数 n ，判断 n 是否可以表示成若干不同的三的幂次和。\n思路三的幂次和，那和二的幂次和没什么本质区别的，表示方式都是唯一的，可以从数据范围内最大的三次幂开始，若 n 大于等于该数则减去该数，判断 n 最终是否为 0 即可.\n也可以将 n 转换为 3 进制，判断每一位是否均为 0 或 1\n实现class Solution {public:    bool checkPowersOfThree(int n) {        for (int i = 4782969; i; i /= 3) {            if (n &gt;= i) n -= i;        }        return n == 0;    }};\n\nclass Solution:    def checkPowersOfThree(self, n: int) -&gt; bool:        while n &gt; 1:          if n % 3 == 2:            return False          n //= 3        return True\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题326-3的幂","url":"/2025/08/13/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98326-3%E7%9A%84%E5%B9%82/","content":"题意给定整数 n 判断其是否为 3 的幂次。\n思路简单问题简单做，这题数据范围是 int 那最多不会超过 20 次运算，直接暴力就好。\n当然也有更加快的方法，首先可以预处理然后判断一下是否在集合中。\n最快的做法则是使用数据范围内最大的 3 的幂次，若 n 可以整除该数则 n 为 3 的幂次。\n实现class Solution {public:    bool isPowerOfThree(int n) {        if (n &lt; 1) return false;        while (n &gt; 1) {            if (n % 3) return false;            n /= 3;        }        return true;    }};\n\nclass Solution:    def isPowerOfThree(self, n: int) -&gt; bool:        if n &lt; 1:            return False        while n &gt; 1:            if n % 3 != 0:                return False            n /= 3        return True\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题2787-将一个数字表示成幂的和的方案数","url":"/2025/08/12/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982787-%E5%B0%86%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%88%90%E5%B9%82%E7%9A%84%E5%92%8C%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/","content":"题意给定正整数 n 和 x， 返回将 n 表示成一些互不相同的的正整数的 x 次幂之和的方案数，对 1e9 + 7 取模。\n思路那就是一个比较经典的 0-1背包问题，显然只需枚举 x 次幂小于等于 n 的数即可，必然是不会有特别多的数的，然后进行背包就好。\n实现using ll = long long;constexpr int mod = 1e9 + 7;int pow_(int a, int b) {    int res = 1;    for ( ; b; b &gt;&gt;= 1, a *= a) {        if (b &amp; 1) res *= a;    }    return res;}class Solution {public:    int numberOfWays(int n, int x) {        vector&lt;int&gt; f;        for (int i = 1; true; i++) {            int p = pow_(i, x);            if (p &gt; n) break;            f.push_back(p);        }        vector&lt;int&gt; dp(n + 1);        dp[0] = 1;        for (const auto&amp; num : f) {            for (int i = n - num; i &gt;= 0; i--) {                dp[i + num] += dp[i];                if (dp[i + num] &gt;= mod) dp[i + num] -= mod;            }        }        return dp.back();    }};\n\nmod = 1_000_000_007class Solution:    def numberOfWays(self, n: int, x: int) -&gt; int:        f = [0] * (n + 1)        f[0] = 1        for i in range(1, n + 1):            p = pow(i, x)            if p &gt; n:                break            for j in range(n - p, -1, -1):                f[j + p] += f[j]                if f[j + p] &gt;= mod:                    f[j + p] -= mod        return f[-1]\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题2438-二的幂数组中查询范围内的乘积","url":"/2025/08/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982438-%E4%BA%8C%E7%9A%84%E5%B9%82%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E8%AF%A2%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E4%B9%98%E7%A7%AF/","content":"题意给定数 n 找到对应的 powers 数组：\n\npowers 非递减\npowers 仅含 2 的幂次\npowers 含数最少\n\n给定一组询问 queries_i = [l_i, r_i] ，求 powers 中区间 [l_i, r_i] 的区间积，对 1e9 + 7 取模\n思路显然 powers 是唯一的，就是将 n 转为二进制的 1 的位\n然后区间积第一反应我是求前缀积，这里由于模数是质数，除法等价于乘逆元即可。\n但写python做法时看了下灵神写法，转为幂次的前缀和然后预处理就好，复杂度会更低。\n实现cpp 与 前缀积\nusing ll = long long;static constexpr int mod = 1e9 + 7;ll powMod(ll a, ll b) {    ll res = 1;    while (b) {        if (b &amp; 1) {            res = res * a % mod;        }        a = a * a % mod;        b &gt;&gt;= 1;    }    return res;}class Solution {public:    vector&lt;int&gt; productQueries(int n, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {        vector&lt;int&gt; f;        for (int i = 0; i &lt; 31; i++) {            if (n &gt;&gt; i &amp; 1) f.push_back(1 &lt;&lt; i);        }        const int len = f.size();        vector&lt;int&gt; pre(len + 1, 1);        for (int i = 0; i &lt; len; i++) {            pre[i + 1] = 1ll * pre[i] * f[i] % mod;        }        vector&lt;int&gt; ans;        for (const auto&amp; q : queries) {            int l = q[0], r = q[1] + 1;            ans.push_back(1ll * pre[r] * powMod(pre[l], mod - 2) % mod);        }        return ans;    }};\n\npython 与 前缀和\nmod = 1000000007def powMod(a, b):    res = 1    while b &gt; 0:        if (b &amp; 1):            res = res * a % mod        a = a * a % mod        b &gt;&gt;= 1    return resclass Solution:    def productQueries(self, n: int, queries: List[List[int]]) -&gt; List[int]:        pre = [0]        for i in range(0, 31):            if n &gt;&gt; i &amp; 1:                pre.append(pre[-1] + i)        return [powMod(2, pre[r + 1] - pre[l]) for l, r in queries]\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题869-重新排序得到 2 的幂","url":"/2025/08/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98869-%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B0-2-%E7%9A%84%E5%B9%82/","content":"题意给定正整数 n , 判断是否可以将其重排为无前导零的二的幂次数。\n思路注意到给定的数据范围是 n &lt;= 1e9 也就是最多有九位数，转为字符串进行全排列枚举排列方案再按昨日每日一题的方法判断是否为二的幂次数即可，计算量大概是 9! 完全是可以接受的。\n但确实不太优雅，1e9 内的二的幂次数显然是不超过 31 个的，我们完全可以预处理枚举这些数，将其中各个二次幂数的各数位出现的次数记录下来，然后与询问进行比对即可。只要各数位出现次数相同显然是可以重排的。\n比较简单的做法就是灵神的将二的幂次数转为字符串然后排序加入到uset/ump/set/map 中，也可以开个大小为10的数组记录然后哈希。\n但是我们可以注意到 1e9 意味着最多有九个数位，且相同数位出现次数不超过 9 ，我们完全可以转换为一个 long long 的数进行哈希，当然使用 python 的话就不用管这里的数据范围了。这样做常数会相对小些，但说实话这种题好像不用那么在意这个的，简单题简单做就好。\n实现cpp 与 枚举\nclass Solution {public:    bool reorderedPowerOf2(int n) {        auto check = [](int x) -&gt; bool {            return (x &amp; -x) == x;        };        string s = to_string(n);        string t = s;        const int len = s.size();        do {            int x = stoi(s);            if (to_string(x).size() == len &amp;&amp; check(x)) return true;            next_permutation(s.begin(), s.end());        } while (s != t);        return false;    }};\n\ncpp 与 哈希\nusing ll = long long;static constexpr int inf = 1e9;static constexpr int N = 10;static ll a[N];unordered_set&lt;ll&gt; f;auto init = []() -&gt; int {    a[0] = 1;    for (int i = 1; i &lt; N; i++) a[i] = a[i - 1] * 10;    int x = 1;    while (x &lt;= inf) {        ll cur = 0;        for (int t = x; t; t /= 10) {            cur += a[t % 10];        }        f.insert(cur);        x &lt;&lt;= 1;    }    return 0;} ();class Solution {public:    bool reorderedPowerOf2(int n) {        ll x = 0;        for ( ; n; n /= 10) x += a[n % 10];        return f.count(x);    }};\n\npython 与 哈希\nmx = 10**9a = [1] * 10for i in range(1, 10):    a[i] = a[i - 1] * 10f = set()for i in range(0, 31):    x = 1 &lt;&lt; i    cur = 0    while x:        cur += a[x % 10]        x //= 10    f.add(cur)class Solution:    def reorderedPowerOf2(self, n: int) -&gt; bool:        cur = 0        while n:            cur += a[n % 10]            n //= 10        return cur in f\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题231-2 的幂","url":"/2025/08/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98231-2-%E7%9A%84%E5%B9%82/","content":"题意给定数 n ，判断 n 是否为 2 的幂次。\n思路那有很多种写法的，最简单也最快的我认为就是利用位运算求 lowbit 也就是 n 二进制下的最低位，显然当 lowbit(n) == n 时 n 为 2 的幂次，不过要注意二的幂次应该是正整数的，题目给的范围为 int 范围。\nlowbit(x) == x &amp; -x\n实现class Solution {public:    bool isPowerOfTwo(int n) {        return n &gt; 0 &amp;&amp; (n &amp; -n) == n;    }};\n\nclass Solution:    def isPowerOfTwo(self, n: int) -&gt; bool:        return n &gt; 0 and (n &amp; -n) == n\n\n","categories":["做题笔记"],"tags":["cpp","python"]},{"title":"力扣每日一题808-分汤","url":"/2025/08/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98808-%E5%88%86%E6%B1%A4/","content":"题意给定初始有 n 毫升的汤A和汤B，每轮操作等概率地发生以下四种事件：\n\nA减少 100 毫升，B减少 0 毫升\nA减少 75 毫升，B减少 25 毫升\nA减少 50 毫升，B减少 50 毫升\nA减少 25 毫升，B减少 75 毫升\n\n求(A在B之前取完的概率)加上(AB同时取完概率的一半)\n思路先看数据范围，n &lt;= 1e9 非常的大，当 n 很大时什么做法都不可能实现的，那么肯定是个思维数学题。\n仔细观察每次操作的影响，A减少的期望量显然是大于B的，那么当 n 很大时一定是A先取完的。\n再考虑以下小范围时应该怎么做。求概率，比较自然可以想到使用概率dp，同时注意到每次操作的减少量的最大公因数为 25 ，故可以将毫升数统统除以 25 表示操作次数与操作减少量。\n再用获得的dp算法大概跑一下范围，可以发现操作次数超过 200 后概率在可接受误差内可认为 1\n实现class Solution {using ld = long double;static constexpr ld eps = 1e-5;static constexpr int N = 25;static constexpr ld p = 0.25;public:    double soupServings(int n) {        const int t = (n + N - 1) / N;        if (t &gt;= 200) return 1.0;        auto cal = [](const int&amp; x) -&gt; int {            return max(x, 0);        };        vector f(t + 1, vector&lt;ld&gt; (t + 1));        fill(f[0].begin(), f[0].end(), 1.0);        f[0][0] = 0.5;        for (int i = 1; i &lt;= t; i++) {            for (int j = 1; j &lt;= t; j++) {                f[i][j] = (f[cal(i - 4)][j] + f[cal(i - 3)][cal(j - 1)] + f[cal(i - 2)][cal(j - 2)] + f[cal(i - 1)][cal(j - 3)]) * p;            }        }        return f[t][t];    }};\n\nclass Solution:    def soupServings(self, n: int) -&gt; float:        t = (n + 24) // 25        if t &gt;= 200:            return 1.0                p = 0.25        @cache        def dfs(x, y) -&gt; float:            if x &lt;= 0 and y &lt;= 0:                return 0.5            elif x &lt;= 0:                return 1.0            elif y &lt;= 0:                return 0.0            res = 0.0            for i in range(1, 5):                res += dfs(x - i, y - 4 + i) * p            return res                return dfs(t, t)\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题3363-最多可收集的水果数目","url":"/2025/08/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983363-%E6%9C%80%E5%A4%9A%E5%8F%AF%E6%94%B6%E9%9B%86%E7%9A%84%E6%B0%B4%E6%9E%9C%E6%95%B0%E7%9B%AE/","content":"题意给定 n * n 大小的网格，以及二维数组 fruits 表示每个格子内的水果数。有三个小朋友分别位于 (0, 0), (0, n - 1), (n - 1, 0) 其中\n\n(0, 0) 的人每次可以往右、下、右下移动一格\n(0, n - 1) 的人每次可以往左下、下、右下移动一格\n(n - 1, 0) 的人每次可以往右上、右、右下移动一格\n\n每个小朋友只能移动 n - 1 步且终点必须为 (n - 1, n - 1) ，求三个小朋友总共可收集的最大水果数。\n思路咋一看是挺难的，但是每个小朋友都只能移动 n - 1 步且必须到达 (n - 1, n - 1) 那也就是说左上的小朋友有且仅有沿对角线一种走法，右上和左下的小朋友的可行动区域也仅是一个小三角形，且三个小朋友的行动路径不可能相交。\n那么问题就转变成了两个简单的dp（求右上和左下的小朋友行动最优方案）。\n实现class Solution {public:    int maxCollectedFruits(vector&lt;vector&lt;int&gt;&gt;&amp; fruits) {        const int n = fruits.size();        int ans = 0;        vector f(n + 1, vector&lt;int&gt; (n + 1));        f[0][n - 1] = fruits[0][n - 1];        for (int i = 1; i &lt; n; i++) {            for (int j = max(i + 1, n - 1 - i); j &lt; n; j++) {                f[i][j] = max({f[i - 1][j + 1], f[i - 1][j], f[i - 1][j - 1]}) + fruits[i][j];            }        }        ans += f[n - 2][n - 1];        f[n - 1][0] = fruits[n - 1][0];        for (int j = 1; j &lt; n; j++) {            for (int i = max(j + 1, n - 1 - j); i &lt; n; i++) {                f[i][j] = max({f[i + 1][j - 1], f[i][j - 1], f[i - 1][j - 1]}) + fruits[i][j];            }        }        ans += f[n - 1][n - 2];        for (int i = 0; i &lt; n; i++) ans += fruits[i][i];        return ans;    }};\n\nclass Solution:    def maxCollectedFruits(self, fruits: List[List[int]]) -&gt; int:        n = len(fruits)        f = [0] * ((n + 1) * (n + 1))        def cal(x, y):            return x * (n + 1) + y                ans = 0        f[cal(0, n - 1)] = fruits[0][n - 1]        for i in range(1, n):            for j in range(max(i + 1, n - 1 - i), n):                f[cal(i, j)] = max(f[cal(i - 1, j - 1)], f[cal(i - 1, j)], f[cal(i - 1, j + 1)]) + fruits[i][j]        ans += f[cal(n - 2, n - 1)]        f[cal(n - 1, 0)] = fruits[n - 1][0]        for j in range(1, n):            for i in range(max(j + 1, n - 1 - j), n):                f[cal(i, j)] = max(f[cal(i + 1, j - 1)], f[cal(i, j - 1)], f[cal(i - 1, j - 1)]) + fruits[i][j]        ans += f[cal(n - 1, n - 2)]        ans += sum(x[i] for i, x in enumerate(fruits))        return ans\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题3479-水果成篮 III","url":"/2025/08/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983479-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE-III/","content":"题意给定数组 fruits 与 baskets，分别表示不同种类水果的数量以及每个篮子的容量。需要按顺序将水果放进最左可以放进所有该种水果的篮子，不同水果不可混放。求会有多少种水果无法放进篮子。\n思路是和做题完全一样的题，只是数据范围增强到了1e5那就为无法直接暴力，可以使用线段树二分，不过由于昨天我已经是这么写的了，就不过多赘述。\n实现template&lt;class Info&gt;struct SegmentTree {    int n;    std::vector&lt;Info&gt; info;    SegmentTree() : n(0) {}    SegmentTree(int n_, Info v_ = Info()) {        init(n_, v_);    }    template&lt;class T&gt;    SegmentTree(std::vector&lt;T&gt; init_) {        init(init_);    }    void init(int n_, Info v_ = Info()) {        init(std::vector(n_, v_));    }    template&lt;class T&gt;    void init(std::vector&lt;T&gt; init_) {        n = init_.size();        info.assign(4 &lt;&lt; std::__lg(n), Info());        std::function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) {            if (r - l == 1) {                info[p] = init_[l];                return;            }            int m = (l + r) / 2;            build(2 * p, l, m);            build(2 * p + 1, m, r);            pull(p);        };        build(1, 0, n);    }    void pull(int p) {        info[p] = info[2 * p] + info[2 * p + 1];    }    void modify(int p, int l, int r, int x, const Info &amp;v) {        if (r - l == 1) {            info[p] = v;            return;        }        int m = (l + r) / 2;        if (x &lt; m) {            modify(2 * p, l, m, x, v);        } else {            modify(2 * p + 1, m, r, x, v);        }        pull(p);    }    void modify(int p, const Info &amp;v) {        modify(1, 0, n, p, v);    }    Info rangeQuery(int p, int l, int r, int x, int y) {        if (l &gt;= y || r &lt;= x) {            return Info();        }        if (l &gt;= x &amp;&amp; r &lt;= y) {            return info[p];        }        int m = (l + r) / 2;        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);    }    Info rangeQuery(int l, int r) {        return rangeQuery(1, 0, n, l, r);    }    template&lt;class F&gt;    int findFirst(int p, int l, int r, int x, int y, F pred) {        if (l &gt;= y || r &lt;= x || !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        int res = findFirst(2 * p, l, m, x, y, pred);        if (res == -1) {            res = findFirst(2 * p + 1, m, r, x, y, pred);        }        return res;    }    template&lt;class F&gt;    int findFirst(int l, int r, F pred) {        return findFirst(1, 0, n, l, r, pred);    }    template&lt;class F&gt;    int findLast(int p, int l, int r, int x, int y, F pred) {        if (l &gt;= y || r &lt;= x || !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        int res = findLast(2 * p + 1, m, r, x, y, pred);        if (res == -1) {            res = findLast(2 * p, l, m, x, y, pred);        }        return res;    }    template&lt;class F&gt;    int findLast(int l, int r, F pred) {        return findLast(1, 0, n, l, r, pred);    }};struct Info {    int mx;};Info operator+(Info a, Info b) {    return {max(a.mx, b.mx)};}class Solution {public:    int numOfUnplacedFruits(vector&lt;int&gt;&amp; fruits, vector&lt;int&gt;&amp; baskets) {        const int n = fruits.size();        SegmentTree&lt;Info&gt; SgT(n);        for (int i = 0; i &lt; n; i++) {            SgT.modify(i, {baskets[i]});        }        int ans = n;        for (const auto&amp; x : fruits) {            int loc = SgT.findFirst(0, n, [&amp;](const auto&amp; p) {                return p.mx &gt;= x;            });            if (loc == -1) continue;            SgT.modify(loc, {0});            ans--;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3477-水果成篮 II","url":"/2025/08/05/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983477-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE-II/","content":"题意给定数组 fruits 与 baskets，分别表示不同种类水果的数量以及每个篮子的容量。需要按顺序将水果放进最左可以放进所有该种水果的篮子，不同水果不可混放。求会有多少种水果无法放进篮子。\n思路注意到本题的数据范围是不大的，n == len(fruits) == len(baskets) &lt;= 100   ，那么其实直接暴力模拟即可。\n但是数据范围稍大些呢，问题其实是可以转换为多个求最左含大于某数的位置的问题，同时带修改，那么可以想到使用线段树维护区间最大值，然后使用线段树上二分即可。\n这里我只有cpp线段树二分的板子，所有只用cpp实现了线段树上二分的代码，python就偷懒暴力了。\n实现cpp 与 线段树二分\ntemplate&lt;class Info&gt;struct SegmentTree {    int n;    std::vector&lt;Info&gt; info;    SegmentTree() : n(0) {}    SegmentTree(int n_, Info v_ = Info()) {        init(n_, v_);    }    template&lt;class T&gt;    SegmentTree(std::vector&lt;T&gt; init_) {        init(init_);    }    void init(int n_, Info v_ = Info()) {        init(std::vector(n_, v_));    }    template&lt;class T&gt;    void init(std::vector&lt;T&gt; init_) {        n = init_.size();        info.assign(4 &lt;&lt; std::__lg(n), Info());        std::function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) {            if (r - l == 1) {                info[p] = init_[l];                return;            }            int m = (l + r) / 2;            build(2 * p, l, m);            build(2 * p + 1, m, r);            pull(p);        };        build(1, 0, n);    }    void pull(int p) {        info[p] = info[2 * p] + info[2 * p + 1];    }    void modify(int p, int l, int r, int x, const Info &amp;v) {        if (r - l == 1) {            info[p] = v;            return;        }        int m = (l + r) / 2;        if (x &lt; m) {            modify(2 * p, l, m, x, v);        } else {            modify(2 * p + 1, m, r, x, v);        }        pull(p);    }    void modify(int p, const Info &amp;v) {        modify(1, 0, n, p, v);    }    Info rangeQuery(int p, int l, int r, int x, int y) {        if (l &gt;= y || r &lt;= x) {            return Info();        }        if (l &gt;= x &amp;&amp; r &lt;= y) {            return info[p];        }        int m = (l + r) / 2;        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);    }    Info rangeQuery(int l, int r) {        return rangeQuery(1, 0, n, l, r);    }    template&lt;class F&gt;    int findFirst(int p, int l, int r, int x, int y, F pred) {        if (l &gt;= y || r &lt;= x || !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        int res = findFirst(2 * p, l, m, x, y, pred);        if (res == -1) {            res = findFirst(2 * p + 1, m, r, x, y, pred);        }        return res;    }    template&lt;class F&gt;    int findFirst(int l, int r, F pred) {        return findFirst(1, 0, n, l, r, pred);    }    template&lt;class F&gt;    int findLast(int p, int l, int r, int x, int y, F pred) {        if (l &gt;= y || r &lt;= x || !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        int res = findLast(2 * p + 1, m, r, x, y, pred);        if (res == -1) {            res = findLast(2 * p, l, m, x, y, pred);        }        return res;    }    template&lt;class F&gt;    int findLast(int l, int r, F pred) {        return findLast(1, 0, n, l, r, pred);    }};struct Info {    int mx;};Info operator+(Info a, Info b) {    return {max(a.mx, b.mx)};}class Solution {public:    int numOfUnplacedFruits(vector&lt;int&gt;&amp; fruits, vector&lt;int&gt;&amp; baskets) {        const int n = fruits.size();        SegmentTree&lt;Info&gt; SgT(n);        for (int i = 0; i &lt; n; i++) {            SgT.modify(i, {baskets[i]});        }        int ans = n;        for (const auto&amp; x : fruits) {            int loc = SgT.findFirst(0, n, [&amp;](const auto&amp; p) {                return p.mx &gt;= x;            });            if (loc == -1) continue;            SgT.modify(loc, {0});            ans--;        }        return ans;    }};\n\npython 与 暴力\nclass Solution:    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -&gt; int:        ans = n = len(fruits)        for x in fruits:            for i in range(n):                if baskets[i] &gt;= x:                    ans -= 1                    baskets[i] = 0                    break        return ans\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题904-水果成篮","url":"/2025/08/04/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98904-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/","content":"题意给定数组fruits表示一排果树的种类。有且仅有两个篮子，每个篮子仅可装一种水果但没有数量上限。可以任选一个位置开始向右摘水果，必须恰好摘一个所经过的水果，若无法装下则停止。求最多可以摘多少水果。\n思路简单来说就是仅包含小于等于两种数的最长子数组。直接使用滑动窗口即可，由于种类上限较少，可以仅开4个变量进行维护（两个篮子所装种类及数量）。若种类上限较多可以考虑使用哈希维护。\n实现class Solution {public:    int totalFruit(vector&lt;int&gt;&amp; fruits) {        array&lt;int, 2&gt; a {-1, 0}, b {-1, 0};        int ans = 0;        const int n = fruits.size();        for (int l = 0, r = -1; r + 1 &lt; n; ) {            if (a[0] == fruits[r + 1]) {                a[1]++;                r++;            } else if (b[0] == fruits[r + 1]) {                b[1]++;                r++;            } else if (b[0] == -1) {                b = {fruits[++r], 1};            } else if (a[0] == -1) {                a = {fruits[++r], 1};            } else if (r + 1 &lt; n) {                for ( ; b[1] &amp;&amp; a[1]; l++) {                    if (fruits[l] == a[0]) a[1]--;                    else b[1]--;                }                if (b[1] == 0) b[0] = -1;                else a[0] = -1;            }            ans = max(ans, a[1] + b[1]);        }        return ans;    }};\n\nclass Solution:    def totalFruit(self, fruits: List[int]) -&gt; int:        a = [-1, 0]        b = [-1, 0]        n = len(fruits)        ans = l = 0        r = -1        while r + 1 &lt; n:            if a[0] == fruits[r + 1]:                a[1] += 1                r += 1            elif b[0] == fruits[r + 1]:                b[1] += 1                r += 1            elif b[0] == -1:                b = [fruits[r + 1], 1]                r += 1            elif a[0] == -1:                a = [fruits[r + 1], 1]                r += 1            else:                while a[1] &gt; 0 and b[1] &gt; 0:                    if fruits[l] == a[0]:                        a[1] -= 1                    else:                        b[1] -= 1                    l += 1                if b[1] == 0:                    b[0] = -1                else:                    a[0] = -1            ans = max(ans, a[1] + b[1])        return ans\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题2106-摘水果","url":"/2025/08/03/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982106-%E6%91%98%E6%B0%B4%E6%9E%9C/","content":"题意位于无限长的横坐标轴上。给定数组fruits表示每堆水果所在的位置以及数量，初始位于位置startPos，最多可以移动k步。求可以获得的最大水果数。\n思路手玩一下可以发现来回走是会浪费步数的，所以只可能先向左再向右或反过来先向右再向左可能得到最大值。\n那么使用滑动窗口维护可达位置内的水果数量，取最大值即为答案。\n实现class Solution {public:    int maxTotalFruits(vector&lt;vector&lt;int&gt;&gt;&amp; fruits, int startPos, int k) {        const int n = fruits.size();        int lt = ranges::lower_bound(fruits, startPos - k, {}, [&amp;](const auto&amp; x) {            return x[0];        }) - fruits.begin();        int rt = lt;        int ans = 0;        for ( ; rt &lt; n &amp;&amp; fruits[rt][0] &lt;= startPos; rt++) ans += fruits[rt][1];        int cur = ans;        for ( ; rt &lt; n &amp;&amp; fruits[rt][0] &lt;= startPos + k; rt++) {            cur += fruits[rt][1];            for ( ; startPos - 2 * fruits[lt][0] + fruits[rt][0] &gt; k &amp;&amp; 2 * fruits[rt][0] - startPos - fruits[lt][0] &gt; k; lt++) {                cur -= fruits[lt][1];            }            ans = max(ans, cur);        }        return ans;    }};\n\nclass Solution:    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -&gt; int:        n = len(fruits)        lt = bisect_left(fruits, [startPos - k])        rt = lt        ans = 0        while rt &lt; n and fruits[rt][0] &lt;= startPos:            ans += fruits[rt][1]            rt += 1                cur = ans        while rt &lt; n and fruits[rt][0] &lt;= startPos + k:            cur += fruits[rt][1]            while startPos + fruits[rt][0] - fruits[lt][0] * 2 &gt; k and fruits[rt][0] * 2 - fruits[lt][0] - startPos &gt; k:                cur -= fruits[lt][1]                lt += 1            rt += 1            ans = max(ans, cur)        return ans\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题2561-重排水果","url":"/2025/08/02/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982561-%E9%87%8D%E6%8E%92%E6%B0%B4%E6%9E%9C/","content":"题意给定两个等长数组basket1和basket2。可以进行任意次以下操作：\n\n交换basket1[i]与basket2[j]，操作的代价为min(basket1[i], basket2[j])\n\n求欲使两数组内容相同的最小代价。\n思路手玩一下不难发现其实是很符合贪心性质的。\n首先是不能使两数组相同的情况，必然是有某个数有奇数个。\n再考虑可以使得两数组相同的情况，每个数均有偶数个，又两数组等长，若basket1中缺某数一定会多出另一个数，basket2也是同理。每次交换可以处理两个数。可以想到将两数中多的数列出来，每次操作交换一侧最大另一侧的最小。又可选择某侧最小值换过去再换回来，取代价最小即可。\n呃，好像讲得是有点乱，还请看代码吧。\n实现class Solution:    def minCost(self, basket1: List[int], basket2: List[int]) -&gt; int:        cnt = defaultdict(int)        for x in basket1:            cnt[x] += 1        for x in basket2:            cnt[x] -= 1                a, b = [], []        for num, t in cnt.items():            if t &amp; 1:                return -1            if t &gt; 0:                a.extend([num] * (t // 2))            elif t &lt; 0:                b.extend([num] * (-t // 2))                a.sort()        b.sort(reverse=True)        mn = min(min(basket1), min(basket2))        ans = 0        for i in range(len(a)):            ans += min(a[i], b[i], mn * 2)        return ans\n\nclass Solution {using ll = long long;public:    long long minCost(vector&lt;int&gt;&amp; basket1, vector&lt;int&gt;&amp; basket2) {        int mn = 1e9;        unordered_map&lt;int, array&lt;int, 2&gt;&gt; cnt;        for (const auto&amp; x : basket1) {            cnt[x][0]++;            mn = min(mn, x);        }        for (const auto&amp; x : basket2) {            cnt[x][1]++;            mn = min(mn, x);        }        vector&lt;int&gt; a, b;        for (const auto&amp; [num, arr] : cnt) {            const auto&amp; [x, y] = arr;            if ((x + y) &amp; 1) return -1;            if (x &gt; y) a.insert(a.end(), (x - y) &gt;&gt; 1, num);            else if (x &lt; y) b.insert(b.end(), (y - x) &gt;&gt; 1, num);        }        ranges::sort(a);        ranges::sort(b, greater());        ll ans = 0;        for (int i = 0; i &lt; a.size(); i++) {            ans += min({a[i], b[i], mn &lt;&lt; 1});        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题118-杨辉三角","url":"/2025/08/01/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/","content":"题意给定非负整数numRows，生成杨辉三角的前numRows行。\n思路这道题是hot100的原题，本身难度也没有很大，只要知道杨辉三角的定义我想就是不难写的。\n简单的双层循环模拟杨辉三角的计算过程即可。\n实现class Solution:    def generate(self, numRows: int) -&gt; List[List[int]]:        ans = [[1] * (i + 1) for i in range(numRows)]        for i in range(2, numRows):            for j in range(1, i):                ans[i][j] = ans[i - 1][j] + ans[i - 1][j - 1]        return ans\n\nclass Solution {public:    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {        vector&lt;vector&lt;int&gt;&gt; ans;        ans.push_back({1});        for (int i = 1; i &lt; numRows; i++) {            vector&lt;int&gt; tmp(ans.back().size() + 1);            for (int j = 0; j &lt;= i; j++) {                if (j == 0 || j == i) tmp[j] = 1;                else {                    tmp[j] = (ans.back()[j - 1] + ans.back()[j]);                }            }            ans.push_back(tmp);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题2683-相邻值的按位异或","url":"/2025/07/31/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982683-%E7%9B%B8%E9%82%BB%E5%80%BC%E7%9A%84%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96/","content":"题意数组derived是由同样长度的数组original相邻值异或得到的，即derived[i] = original[i] ^ original[i + 1]。对于给定的0/1数组derived，判断其是否存在有效的original数组。\n思路什么情况下derived[i] == 1呢，显然是derived[i] != derived[i + 1]时；而当derived[i] == derived[i + 1]时，derived[i] == 0。由此可以推出每一个数与其他数是否相等。\n那么什么时候不存在对应的original数组呢，显然是当出现矛盾时。不难想到遍历数组得到异或和，即可判断是否存在矛盾，是否存在对应数组。\n实现class Solution:    def doesValidArrayExist(self, derived: List[int]) -&gt; bool:        same = True        for i in derived:            if i == 1:                same = not same        return same                \n\nclass Solution {public:    bool doesValidArrayExist(vector&lt;int&gt;&amp; derived) {        bool same = true;        for (const auto&amp; x : derived) {            same ^= x;        }        return same;    }};\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题2419-按位与最大的最长子数组","url":"/2025/07/30/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982419-%E6%8C%89%E4%BD%8D%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84/","content":"题意给定正整数数组nums。求nums中按位与可以得到最大值的最长非空子数组的长度。\n思路与前几天的按位或略有不同，或是子数组越长越有可能出最大值，而与则是越长值越小，即 Misplaced &x &amp; y \\leq x \n所以不难想到按位与可以得到的最大值为nums中的最大值，而答案就是连续出现的最大值个数。\n实现class Solution:    def longestSubarray(self, nums: List[int]) -&gt; int:        i = ans = mx = 0        n = len(nums)        while i &lt; n:            j = i + 1            while j &lt; n and nums[i] == nums[j]:                j += 1            if nums[i] &gt; mx:                mx = nums[i]                ans = j - i            elif nums[i] == mx:                ans = max(ans, j - i)            i = j        return ans\n\nclass Solution:    def longestSubarray(self, nums: List[int]) -&gt; int:        i = ans = mx = 0        n = len(nums)        while i &lt; n:            j = i + 1            while j &lt; n and nums[i] == nums[j]:                j += 1            if nums[i] &gt; mx:                mx = nums[i]                ans = j - i            elif nums[i] == mx:                ans = max(ans, j - i)            i = j        return ans\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题2411-按位或最大的最小子数组长度","url":"/2025/07/29/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982411-%E6%8C%89%E4%BD%8D%E6%88%96%E6%9C%80%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/","content":"题意给定非负整数数组nums。对于nums中的每一个数，求出以其为起点可以得到按位或最大值的最小非空子数组的长度。\n思路首先考虑按位或可以得到的最大值怎么求，显然是子数组越长越可能得到最大值，那么一路或到尾显然是可以得到最大值的。那么怎么求最早出现也就是最短的呢。显然一个数与另一个数无论或几次结果都是不变的，那很自然可以想到ST表上二分。\n但这有点火箭毛毛虫了，因为或运算有个很好的性质，在正int的范围内，最多是可以变换31次的，那直接从前往后遍历，从后往前更新即可。\n实现st表加二分实现\ntemplate&lt;class T&gt; struct ST {\tint n, logn;\tvector&lt;int&gt; LOG;\tvector&lt;vector&lt;T&gt;&gt;st;\tST (int x) {\t\tn = x;\t\tlogn = __lg(n);\t\tLOG.resize(n + 1);\t\tst.resize(n, vector&lt;T&gt; (logn + 1));\t\tfor (int i = 2; i &lt;= n; i++) {\t\t\tLOG[i] = LOG[i / 2] + 1;\t\t}\t}\tvoid set(int i, T x) {\t\tst[i][0] = x;\t}\tvoid build() {\t\tfor (int i = 1; i &lt;= logn; i++) {\t\t\tfor (int j = 0; j + (1 &lt;&lt; i) - 1 &lt; n; j++) {\t\t\t\tst[j][i] = st[j][i - 1] | st[j + (1 &lt;&lt; (i - 1))][i - 1];\t\t\t}\t\t}\t}\tT query(int l, int r) {\t\tint len = LOG[r - l + 1];\t\treturn st[l][len] | st[r - (1 &lt;&lt; len) + 1][len];\t}};class Solution {public:    vector&lt;int&gt; smallestSubarrays(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        ST&lt;int&gt; st(n);        for (int i = 0; i &lt; n; i++) {            st.set(i, nums[i]);        }        st.build();        vector&lt;int&gt; ans(n);        for (int i = 0; i &lt; n; i++) {            int x = st.query(i, n - 1);            int lo = i, hi = n - 1;            while (lo &lt; hi) {                int mid = lo + hi &gt;&gt; 1;                if (st.query(i, mid) == x) hi = mid;                else lo = mid + 1;            }            ans[i] = lo - i + 1;        }        return ans;    }};\n\nclass Solution {public:    vector&lt;int&gt; smallestSubarrays(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        vector&lt;int&gt; ans(n, 1);        for (int i = 0; i &lt; n; i++) {            for (int j = i - 1; j &gt;= 0 &amp;&amp; (nums[j] | nums[i]) != nums[j]; j--) {                nums[j] |= nums[i];                ans[j] = i - j + 1;            }        }        return ans;    }};\n\nclass Solution:    def smallestSubarrays(self, nums: List[int]) -&gt; List[int]:        n = len(nums)        ans = [1] * n        for i in range(0, n):            for j in range(i - 1, -1, -1):                if (nums[j] | nums[i]) == nums[j]:                    break                nums[j] |= nums[i]                ans[j] = i - j + 1        return ans\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题2044-统计按位或能得到最大值的子集数目","url":"/2025/07/28/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982044-%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums，找出nums中子集按位或的最大值，并返回能得出最大值的不同非空子集数量。\nlen(nums) &lt;= 16\n思路数据范围并不大，直接dfs枚举子集即可。\n实现class Solution {public:    int countMaxOrSubsets(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        int mx = 0;        int cnt = 0;        auto dfs = [&amp;](this auto&amp;&amp; self, int cur, int loc) -&gt; void {            if (loc == n) {                if (cur &gt; mx) {                    mx = cur;                    cnt = 1;                } else if (cur == mx) cnt++;                return;            }            self(cur | nums[loc], loc + 1);            self(cur, loc + 1);        };        dfs(0, 0);        return cnt;    }};\n\nclass Solution:    def countMaxOrSubsets(self, nums: List[int]) -&gt; int:        n = len(nums)        cnt = mx = 0        def dfs(cur: int, loc: int) -&gt; None:            nonlocal cnt, mx            if loc == n:                if cur &gt; mx:                    mx = cur                    cnt = 1                elif cur == mx:                    cnt += 1                return            dfs(cur | nums[loc], loc + 1)            dfs(cur, loc + 1)        dfs(0, 0)        return cnt\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题2210-统计数组中峰和谷的数量","url":"/2025/07/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982210-%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%BB%84%E4%B8%AD%E5%B3%B0%E5%92%8C%E8%B0%B7%E7%9A%84%E6%95%B0%E9%87%8F/","content":"题意给定数组nums。如果某数两侧第一个与其不等的数均大于或小于该数，则称其为峰或谷。求nums内峰和谷的数量。\n思路遍历一趟模拟着求就好，两侧均大于或小于等价于两侧与该数的差值同号。\n实现class Solution {public:    int countHillValley(vector&lt;int&gt;&amp; nums) {        int ans = 0;        int pre = nums[0];        const int n = nums.size();        for (int i = 1; i &lt; n - 1; i++) {            int cur = nums[i];            int nxt = nums[i + 1];            if (cur == nxt) continue;            if ((pre - cur) * (nxt - cur) &gt; 0) ans++;            pre = cur;        }        return ans;    }};\n\nclass Solution:    def countHillValley(self, nums: List[int]) -&gt; int:        ans = 0        pre = nums[0]        n = len(nums)        for i in range(1, n - 1):            cur = nums[i]            nxt = nums[i + 1]            if cur == nxt:                continue            if (pre - cur) * (nxt - cur) &gt; 0:                ans += 1            pre = cur        return ans\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题3480-删除一个冲突对后最大子数组数目","url":"/2025/07/26/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983480-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%86%B2%E7%AA%81%E5%AF%B9%E5%90%8E%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/","content":"题意给定整数n 表示有 [1, n] 的顺序排列 nums。同时给定数组 conflictingPairs 表示一些冲突对 conflictingPairs[i] = [a, b] 表示 a 与 b 不能出现同一子数组中。\n现在可以任意删除一对冲突对，求删除后不冲突的 nums 子数组最大个数。\n思路枚举左端点，手玩一下可以发现性质。\n实现class Solution:\n    def maxSubarrays(self, n: int, conflictingPairs: List[List[int]]) -&gt; int:\n        f = [n + 1] * (n + 1)\n        g = [n + 1] * (n + 1)\n        for l, r in conflictingPairs:\n            if l &gt; r:\n                l, r = r, l\n            if r &lt; f[l]:\n                g[l] = f[l]\n                f[l] = r\n            elif r &lt; g[l]:\n                g[l] = r\n        \n        ans = e = mx = 0\n        b0 = b1 = n + 1\n        for i in range(n, 0, -1):\n            pre = b0\n            if f[i] &lt; b0:\n                b1 = b0\n                b0 = f[i]\n            elif f[i] &lt; b1:\n                b1 = f[i]\n            if g[i] &lt; b0:\n                b1 = b0\n                b0 = g[i]\n            elif g[i] &lt; b1:\n                b1 = g[i]\n            ans += b0 - i\n            if b0 != pre:\n                e = 0\n            e += b1 - b0\n            mx = max(mx, e)\n        return ans + mx\n\n","categories":["做题笔记"],"tags":["python","leetcode"]},{"title":"力扣每日一题3487-删除后的最大子数组元素和","url":"/2025/07/25/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983487-%E5%88%A0%E9%99%A4%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%92%8C/","content":"题意给定数组nums，可以删除其中任意元素但不能使其为空。求删除后可以得到的数组内元素各不相同且和最大的子数组和。\n思路相当于将所有负数删除并去重后得到的数组和，但需要注意若数组所有元素均为负数答案为最大的负数。\n实现class Solution:    def maxSum(self, nums: List[int]) -&gt; int:        ans = 0        cnt = 0        vis = [0] * 101        for i in nums:            if i &gt;= 0 and vis[i] == 0:                vis[i] = 1                ans += i                cnt += 1        if cnt == 0:            return max(nums)        return ans\n\nclass Solution {public:    int maxSum(vector&lt;int&gt;&amp; nums) {        array&lt;int, 101&gt; vis;        int ans = 0, cnt = 0, mx = -100;        for (const auto&amp; x : nums) {            if (x &gt;= 0 &amp;&amp; vis[x] == 0) {                vis[x]++;                cnt++;                ans += x;            } else mx = max(mx, x);        }        if (cnt == 0) return mx;        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题2322-从树中删除边的最小分数","url":"/2025/07/24/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982322-%E4%BB%8E%E6%A0%91%E4%B8%AD%E5%88%A0%E9%99%A4%E8%BE%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%88%86%E6%95%B0/","content":"题意给定一棵树以及树上各点权值nums。任意删除树的两条边，获取所得三个连通块中的所有节点异或值，求这三异或值最大值与最小值的最小差值\n思路注意到点数的数据范围其实是不大的 3 &lt;= n &lt;= 1e3\n那直接枚举所删除的两条边即可。快速求删边所得的连通块异或和可以使用dfs求得各点的子树异或和。各点的父子关系可以dfs时顺带处理深度以及dfs序即可判断。\n实现class Solution:    def minimumScore(self, nums: List[int], edges: List[List[int]]) -&gt; int:        n = len(nums)        adj = [[] for _ in range(n)]        for u, v in edges:            adj[u].append(v)            adj[v].append(u)        f = [0] * n        d = [0] * n        sz = [1] * n        p = [0] * n        tot = 0        def dfs(u: int, fa: int):            nonlocal tot            f[u] = nums[u]            p[u] = tot            tot += 1            for v in adj[u]:                if v == fa:                    continue                d[v] = d[u] + 1                dfs(v, u)                f[u] ^= f[v]                sz[u] += sz[v]                dfs(0, -1)        ans = 1e9        for i in range(n - 1):            for j in range(i + 1, n - 1):                u, v = edges[i]                x, y = edges[j]                if d[u] &gt; d[v]:                    u, v = v, u                if d[x] &gt; d[y]:                    x, y = y, x                if p[v] &lt;= p[y] &lt;= p[v] + sz[v] - 1:                    p0 = f[0] ^ f[v]                    p1 = f[v] ^ f[y]                    p2 = f[y]                elif p[y] &lt;= p[v] &lt;= p[y] + sz[y] - 1:                    p0 = f[0] ^ f[y]                    p1 = f[y] ^ f[v]                    p2 = f[v]                else:                    p0 = f[0] ^ f[v] ^ f[y]                    p1 = f[v]                    p2 = f[y]                ans = min(ans, max(p0, p1, p2) - min(p0, p1, p2))        return ans\n\nclass Solution {public:    int minimumScore(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {        const int n = nums.size();        vector&lt;vector&lt;int&gt;&gt; adj(n);        for (const auto&amp; e : edges) {            int u = e[0], v = e[1];            adj[u].push_back(v);            adj[v].push_back(u);        }                vector&lt;int&gt; f(n), d(n), sz(n, 1), p(n);        int tot = 0;        auto dfs = [&amp;](this auto&amp;&amp; self, int u, int fa) -&gt; void {            f[u] = nums[u];            p[u] = tot++;            for (const auto&amp; v : adj[u]) {                if (v == fa) continue;                d[v] = d[u] + 1;                self(v, u);                f[u] ^= f[v];                sz[u] += sz[v];            }        };        dfs(0, -1);        int ans = 1e9;        for (int i = 0; i &lt; n - 1; i++) {            for (int j = i + 1; j &lt; n - 1; j++) {                int u = edges[i][0], v = edges[i][1];                int x = edges[j][0], y = edges[j][1];                if (d[u] &gt; d[v]) swap(u, v);                if (d[x] &gt; d[y]) swap(x, y);                int p0, p1, p2;                if (p[v] &lt;= p[y] &amp;&amp; p[v] + sz[v] - 1 &gt;= p[y]) {                    p0 = f[0] ^ f[v];                    p1 = f[v] ^ f[y];                    p2 = f[y];                } else if (p[y] &lt;= p[u] &amp;&amp; p[y] + sz[y] - 1 &gt;= p[v]) {                    p0 = f[0] ^ f[y];                    p1 = f[y] ^ f[v];                    p2 = f[v];                } else {                    p0 = f[0] ^ f[v] ^ f[y];                    p1 = f[v];                    p2 = f[y];                }                ans = min(ans, max({p0, p1, p2}) - min({p0, p1, p2}));            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题1717-删除子字符串的最大得分","url":"/2025/07/23/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981717-%E5%88%A0%E9%99%A4%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/","content":"题意给定字符串s，可以进行任意次以下两种操作：\n\n删除s中的子串ab，得到分数x\n删除s中的子串ba，得到分数y\n\n求可以得到的最大分数\n思路手玩一下可以发现，仅需要关注s中仅含ab的子串即可，其他字符可以视作分隔符将问题分割为多个小问题。\n每个仅含ab的子串显然删除次数其实与删除方式是无关的，显然应该进行贪心首先尽可能多地用得分高的方式，再用得分较低的方式删除。\n实现class Solution {public:    int maximumGain(string s, int x, int y) {        const int n = s.size();        char a = 'a', b = 'b';        if (x &lt; y) {            swap(x, y);            swap(a, b);        }        int ans = 0;        for (int i = 0; i &lt; n; i++) {            if (s[i] != a &amp;&amp; s[i] != b) continue;            int ca = 0, cb = 0;            for ( ; i &lt; n &amp;&amp; (s[i] == a || s[i] == b); i++) {                if (s[i] == a) {                    ca++;                } else {                    if (ca) {                        ca--;                        ans += x;                    } else {                        cb++;                    }                }            }            ans += min(ca, cb) * y;        }        return ans;    }};\n\nclass Solution:    def maximumGain(self, s: str, x: int, y: int) -&gt; int:        n = len(s)        a, b = 'a', 'b'        if x &lt; y:            x, y = y, x            a, b = b, a        ans = i = 0        while i &lt; n:            if s[i] != a and s[i] != b:                i += 1                continue            ca = cb = 0            while i &lt; n and (s[i] == a or s[i] == b):                if s[i] == a:                    ca += 1                else:                    if ca &gt; 0:                        ans += x                        ca -= 1                    else:                        cb += 1                i += 1            ans += min(ca, cb) * y        return ans\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题1695-删除子数组的最大得分","url":"/2025/07/22/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981695-%E5%88%A0%E9%99%A4%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/","content":"题意给定正整数数组nums，从中删除一个不含相同元素的子数组，求所删子数组的最大和。\n思路应该是比较经典的题目了，印象中只是在面试里我就被问过两次类似的题目。\n给定的数组均为整数，那么子数组显然是越长越可能出答案，那么怎么获得最长的不含重复元素的子数组呢。可以想到使用哈希记录该元素是否出现过以及最后出现的位置，求这段的和就可以考虑使用滑动窗口或前缀和求解。\n实现class Solution {public:    int maximumUniqueSubarray(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        unordered_map&lt;int, int&gt; last;        vector&lt;int&gt; pre(n + 1);        int ans = 0;        for (int i = 0, l = 0; i &lt; n; i++) {            pre[i + 1] = pre[i] + nums[i];            if (last.count(nums[i]) &amp;&amp; last[nums[i]] &gt;= l) {                l = last[nums[i]] + 1;            }            last[nums[i]] = i;            ans = max(ans, pre[i + 1] - pre[l]);        }        return ans;    }};\n\nclass Solution:    def maximumUniqueSubarray(self, nums: List[int]) -&gt; int:        n = len(nums)        pre = [0] * (n + 1)        last = defaultdict(int)        l = 0        ans = 0        for i, num in enumerate(nums):            pre[i + 1] = pre[i] + num            if num in last and last[num] &gt;= l:                l = last[num] + 1            last[num] = i            ans = max(ans, pre[i + 1] - pre[l])        return ans\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题1957-删除字符使字符串变好","url":"/2025/07/21/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981957-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E5%A5%BD/","content":"题意给定字符串s，删除其中最少字符使得其内无连续三个及以上的相同字符。\n思路简单扫一遍删除多余符号即可。\n实现class Solution {public:    string makeFancyString(string s) {        const int n = s.size();        string ans;        for (int i = 0, cnt = 0; i &lt; n; i++) {            if (++cnt &lt; 3) ans += s[i];            if (i &lt; n - 1 &amp;&amp; s[i] != s[i + 1]) cnt = 0;        }        return ans;    }};\n\nclass Solution:    def makeFancyString(self, s: str) -&gt; str:        ans = []        cnt = 0        for i, ch in enumerate(s):            cnt += 1            if cnt &lt; 3:                ans.append(ch)            if i &lt; len(s) - 1 and s[i] != s[i + 1]:                cnt = 0;        return ''.join(ans)\n\n","categories":["做题笔记"],"tags":["cpp","python","leetcode"]},{"title":"力扣每日一题1948-删除系统中的重复文件夹","url":"/2025/07/20/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981948-%E5%88%A0%E9%99%A4%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%96%87%E4%BB%B6%E5%A4%B9/","content":"题意给定二维字符串数组paths其中paths[i]表示第i个文件的绝对路径目录。若两个文件夹非空且其子文件完全相同且子文件结构完全相同，则将两文件夹删除。返回不需删除的剩余文件目录。\n思路怎么快速地判断两个文件夹及其子结构是否相同，可以相等哈希是最快的比较方式，但是这个哈希值怎么计算呢。可以想到将其子目录结构转换为字符串，将所有子串排序以保证子树结构遍历顺序相同，再用()表示目录之间父子的关系。\n","categories":["做题笔记"],"tags":["leetcode"]},{"title":"力扣每日一题1233-删除子文件夹","url":"/2025/07/19/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981233-%E5%88%A0%E9%99%A4%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9/","content":"题意给定一份文件列表folder，若某一文件为另一文件的子目录则将其删除。\n思路进行简单模拟即可，为了提高效率可以考虑将其排序，显然子目录的字典序一定比父目录小。\n实现class Solution:    def removeSubfolders(self, folder: List[str]) -&gt; List[str]:        folder.sort()        ans = [folder[0]]        for s in folder[1:]:            if not (len(s) &gt; len(ans[-1]) and ans[-1] == s[:len(ans[-1])] and s[len(ans[-1])] == '/'):                ans.append(s);        return ans;\n\nclass Solution {public:    vector&lt;string&gt; removeSubfolders(vector&lt;string&gt;&amp; folder) {        ranges::sort(folder);        const int n = folder.size();        vector&lt;string&gt; ans{folder.front()};        for (int i = 1; i &lt; n; i++) {            if (ans.back().size() &lt; folder[i].size() &amp;&amp; ans.back() == folder[i].substr(0, ans.back().size()) &amp;&amp; folder[i][ans.back().size()] == '/') {            } else {                ans.push_back(folder[i]);            }        }        return ans;    }};\n\n其他决心成为传说中的 屁眼通红 高手，所以之后会仅可能地用 python 来写题\n","categories":["做题笔记"],"tags":["cpp","python"]},{"title":"力扣每日一题2163-删除元素后和的最小差值","url":"/2025/07/18/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982163-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E5%90%8E%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC/","content":"题意给定长度为3 * n的数组nums，将其中任意n个元素删除，记此时前n个数的和为sum_first后n个数的和为sum_second，求sum_first - sum_second的最小值\n思路转换一下思路，题目的意思可以转变为：选出前n个最小数，再取出这之后的n个最大数，将两部分做差求最值。注意前后必须有且仅有n个数即可，使用优先队列计算一下就好。\n实现class Solution {using ll = long long;static constexpr ll inf = 1ll &lt;&lt; 52;public:    long long minimumDifference(vector&lt;int&gt;&amp; nums) {        ll ans = inf;        const int n = nums.size() / 3, m = nums.size();        priority_queue&lt;int&gt; pq;        ll sum = 0;        vector&lt;ll&gt; pre(m);        for (int i = 0; i &lt; m; i++) {            sum += nums[i];            pq.push(nums[i]);            if (pq.size() &gt; n) {                sum -= pq.top();                pq.pop();            }            pre[i] = sum;        }        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;&gt;&gt; pqt;        sum = 0;        for (int i = m - 1; i &gt;= n - 1; i--) {            if (i &lt; m - n) ans = min(ans, pre[i] - sum);            sum += nums[i];            pqt.push(nums[i]);            if (pqt.size() &gt; n) {                sum -= pqt.top();                pqt.pop();            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3202-找出有效子序列的最大长度 II","url":"/2025/07/17/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983202-%E6%89%BE%E5%87%BA%E6%9C%89%E6%95%88%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6-II/","content":"题意给定数组nums与整数k，求满足以下条件的最长子序列的长度：子序列任意两个相邻数的和模k均相等。\n思路题目中k的数据范围并不大，可以考虑直接枚举两数之和的模大小，由此递推最大答案即可。\n实现class Solution {public:    int maximumLength(vector&lt;int&gt;&amp; nums, int k) {        vector&lt;int&gt; cnt(k);        int ans = 0;        for (int i = 0; i &lt; k; i++) {            fill(cnt.begin(), cnt.end(), 0);            for (auto x : nums) {                x %= k;                cnt[x] = cnt[(i - x + k) % k] + 1;                ans = max(ans, cnt[x]);            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3201-找出有效子序列的最大长度 I","url":"/2025/07/16/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983201-%E6%89%BE%E5%87%BA%E6%9C%89%E6%95%88%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6-I/","content":"题意给定数组nums，求满足以下条件的最长子序列的长度：任意相邻两个元素的和的奇偶性均相等。\n思路观察可以发现答案子序列应该为 全为偶数 或 全为奇数 或 奇数偶数相间 的形式。那么开变量记录一下遍历一趟返回最大值即可。\n实现class Solution {public:    int maximumLength(vector&lt;int&gt;&amp; nums) {        int ao = 0, ae = 0, o = 0, e = 0;        for (const auto&amp; x : nums) {            if (x &amp; 1) {                ao++;                o = max(o, e + 1);            } else {                ae++;                e = max(e, o + 1);            }        }        return max({ao, ae, o, e});    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3136-有效单词","url":"/2025/07/15/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983136-%E6%9C%89%E6%95%88%E5%8D%95%E8%AF%8D/","content":"题意给定字符串word判断其是否长度至少为3且仅由大小写字母与数字组成且至少含一个元音字母且至少含一个辅音字母。\n思路遍历判断条件即可。\n实现class Solution {public:    bool isValid(string word) {        if (word.size() &lt; 3) return false;        bool ok1 = false, ok2 = false;        for (auto&amp; ch : word) {            if (isalpha(ch)) {                ch = tolower(ch);                if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') ok1 = true;                else ok2 = true;            } else if (!isdigit(ch)) return false;        }        return ok1 &amp;&amp; ok2;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1290-二进制链表转整数","url":"/2025/07/14/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981290-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/","content":"题意给定结点值均为0/1的链表，求其表示的二进制数字的十进制值。\n思路进行一个遍历链表得到二进制数再将其转换即可。\n实现class Solution {public:    int getDecimalValue(ListNode* head) {        string s;        for ( ; head != nullptr; head = head-&gt;next) {            s += char('0' + head-&gt;val);        }        int ans = 0;        for (int i = int(s.size()) - 1, base = 0; i &gt;= 0; i--, base++) {            ans |= (s[i] == '1') &lt;&lt; base;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2410-运动员和训练师的最大匹配数","url":"/2025/07/13/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982410-%E8%BF%90%E5%8A%A8%E5%91%98%E5%92%8C%E8%AE%AD%E7%BB%83%E5%B8%88%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E6%95%B0/","content":"题意给定数组player与trainers表示运动员与训练员的能力。若运动员的能力小于等于训练员则可互相匹配。运动员与训练员均尽可匹配一个。求最大匹配数。\n思路排序后使用双指针即可。\n实现class Solution {public:    int matchPlayersAndTrainers(vector&lt;int&gt;&amp; players, vector&lt;int&gt;&amp; trainers) {        ranges::sort(players);        ranges::sort(trainers);        int ans = 0;        const int n = players.size(), m = trainers.size();        for (int i = 0, j = 0; i &lt; n &amp;&amp; j &lt; m; ) {            if (players[i] &lt;= trainers[j]) {                ans++;                i++; j++;            } else {                j++;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1900-最佳运动员的比拼回合","url":"/2025/07/12/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981900-%E6%9C%80%E4%BD%B3%E8%BF%90%E5%8A%A8%E5%91%98%E7%9A%84%E6%AF%94%E6%8B%BC%E5%9B%9E%E5%90%88/","content":"题意给定整数n与firstPlayer与secondPlayer，表示n名运动员编号为1~n按升序排序。\n每一回合令从前往后数的第i位选手与从后往前数的第i位选手对战，除firstPlayer与secondPlayer必胜外各位选手均可能胜或负。败者淘汰，胜者仍按升序进行排序。\n求firstPlayer与secondPlayer最早与最晚的相遇回合数。\n思路可以进行一个推导发现规律。\n实现class Solution {public:    vector&lt;int&gt; earliestAndLatest(int n, int firstPlayer, int secondPlayer) {        if (firstPlayer + secondPlayer == n + 1) return {1, 1};        if (firstPlayer + secondPlayer &gt; n + 1) {            int t = firstPlayer;            firstPlayer = n + 1 - secondPlayer;            secondPlayer = n + 1 - t;        }        auto cal = [&amp;](int n) -&gt; int {            int res = 1;            if (firstPlayer + secondPlayer &lt;= (n + 1) / 2) {                while (firstPlayer + secondPlayer &lt;= (n + 1) / 2) {                    res++;                    n = (n + 1) / 2;                }                if (secondPlayer - firstPlayer &gt; 1) return res + 1;            }            if (secondPlayer - firstPlayer == 1) {                res++;                n = (n + 1) / 2;                while (n &amp; 1) {                    res++;                    n = (n + 1) / 2;                }                return res;            }            if (secondPlayer &lt;= (n + 1) / 2) return res + 1;            if (secondPlayer - firstPlayer == 2) {                res++;                n = (n + 1) / 2;                while(n &amp; 1) {                    res++;                    n = (n + 1) / 2;                }                return res;            }            if (firstPlayer % 2 == 0 &amp;&amp; firstPlayer + secondPlayer == n) {                res++;            }            return res + 1;        };        return {cal(n), min(bit_width(n - 1u), n + 1 -secondPlayer)};    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3169-无需开会的工作日","url":"/2025/07/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983169-%E6%97%A0%E9%9C%80%E5%BC%80%E4%BC%9A%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%97%A5/","content":"题意给定整数days表示总天数，以及数组meetings其内记录每个会议的开始与结束时间（包含首尾）。\n求没有会议的天数。\n思路比较自然可以想到使用差分，但发现数据范围有点太大并不好做。进一步观察可以想到将会议按开始时间排序，模拟合并求出有会议的天数，再反过来求无会议天数即可。\n实现class Solution {public:    int countDays(int days, vector&lt;vector&lt;int&gt;&gt;&amp; meetings) {        ranges::sort(meetings);        int l = 1, r = 0;        for (const auto&amp; vec : meetings) {            if (vec[0] &gt; r) {                days -= r - l + 1;                l = vec[0];            }            r = max(r, vec[1]);        }        return days - (r - l + 1);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3440-重新安排会议得到最多空余时间 II","url":"/2025/07/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983440-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%9A%E7%A9%BA%E4%BD%99%E6%97%B6%E9%97%B4-II/","content":"题意给定整数eventTime表示总时长，活动开始于t = 0结束于t = eventTime\n同时给定两个数组startTime与endTime表示n个时间没有重叠的会议的开始与结束时间。\n最多可以平移1个会议，使其保持原会议时长但改变其开始结束时间，可以改变会议的相对顺序。求可以得到的会议间最长连续空闲时间。\n思路和昨天的题非常的像，只是条件变成了只能移动一个会议但可以改变会议的顺序。\n可以想到，有两种方式可以得到最优，首先是不改变会议的相对顺序即按照昨天的做法不过k变为了1，另一种则是将每一个会议尝试放入其他会议之间，原位置前后的空闲时间。简单模拟两种操作取最优即可。\n同样是好早之前写的（\n实现class Solution {public:    int maxFreeTime(int eventTime, vector&lt;int&gt;&amp; startTime, vector&lt;int&gt;&amp; endTime) {        vector&lt;array&lt;int, 3&gt;&gt; len;        const int n = startTime.size();        for (int i = 0; i &lt; n; i++) {            if (i == 0) {                len.push_back({startTime[i], 0, 0});            } else {                len.push_back({startTime[i] - endTime[i - 1], i, i - 1});            }        }        len.push_back({eventTime - endTime.back(), n - 1, n - 1});        sort(len.begin(), len.end());        int ans = len.back()[0];        for (int i = 0; i &lt; n; i++) {            if (i == 0) {                ans = max(ans, startTime[i + 1] - endTime[i] + startTime[i]);            } else if (i == n - 1) {                ans = max(ans, eventTime - endTime[i - 1] - endTime[i] + startTime[i]);            } else {                ans = max(ans, startTime[i] - endTime[i - 1] + startTime[i + 1] - endTime[i]);            }        }        for (int i = 0; i &lt; n; i++) {            int l = endTime[i] - startTime[i];            array&lt;int, 3&gt; tmp = {l, 0, 0};            auto it = lower_bound(len.begin(), len.end(), tmp);            while (it != len.end() &amp;&amp; ((*it)[1] == i || (*it)[2] == i)) {                it++;            }            if (it == len.end()) continue;            if (i == 0) {                ans = max(ans, startTime[i + 1]);            } else if (i == n - 1) {                ans = max(ans, eventTime - endTime[i - 1]);            } else {                ans = max(ans, startTime[i + 1] - endTime[i - 1]);            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3439-重新安排会议得到最多空余时间 I","url":"/2025/07/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983439-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%9A%E7%A9%BA%E4%BD%99%E6%97%B6%E9%97%B4-I/","content":"题意给定整数eventTime表示总时长，活动开始于t = 0结束于t = eventTime\n同时给定两个数组startTime与endTime表示n个时间没有重叠的会议的开始与结束时间。\n最多可以平移k个会议，使其保持原会议时长但改变其开始结束时间，同时保持所有会议相对顺序不变且无重叠。求可以得到的会议间最长连续空闲时间。\n思路发现这题之前赛时写过，但实在有点久远同时又是比赛过程，所以可能可能有些丑陋。但最近上班好累哦，实在懒得重写（\n大概就是直接模拟将多个会议拼在一起往前平移或往后平移所能得到的最大空闲块即可。\n实现class Solution {public:    int maxFreeTime(int eventTime, int k, vector&lt;int&gt;&amp; startTime, vector&lt;int&gt;&amp; endTime) {        vector&lt;int&gt; len(startTime.size());        for (int i = 0; i &lt; startTime.size(); i++) {            len[i] = endTime[i] - startTime[i];        }        int start = 0, sum = 0, cnt = 0, lo = 0, l = 0;        int ans = 0;        for (int i = 0; i &lt; startTime.size(); i++) {            sum += len[i];            cnt++;            if (cnt &lt; k) continue;            if (cnt &gt; k) {                cnt--;                sum -= len[lo];                start = endTime[lo];                l = endTime[lo];                lo++;            }            ans = max({ans, (i &lt; startTime.size() - 1 ? startTime[i + 1] - sum - l : eventTime - sum - l)});        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1751-最多可以参加的会议数目 II","url":"/2025/07/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981751-%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%95%B0%E7%9B%AE-II/","content":"题意给定数组events与整数k，其中event[i] = [startDat_i, endDay_i, value_i]表示第i个会议开始与结束的时间以及其价值。若完整参加某一会议可得其价值，最多参加k个会议，求所能得到的最大总价值。\n思路首先考虑所有会议价值一致且无参加的会议数量限制，那么比较经典是将会议按结束时间排序进行贪心。\n再考虑加入会议价值的影响，也不难想到使用dp，递推或递归地推出每一时刻结束前所能获得的最大价值。\n最后是参加会议数量的限制，在前一思路的基础上加入已参与会议的数量维度即可。\n实现class Solution {public:    int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; events, int k) {        const int n = events.size();        ranges::sort(events, [&amp;](const auto&amp; x, const auto&amp; y) {            return x[1] &lt; y[1];        });        vector dp(n + 1, vector&lt;int&gt; (k + 1));        for (int i = 0; i &lt; n; i++) {            int p = lower_bound(events.begin(), events.end(), events[i][0], [](const auto&amp; x, int t) {                return x[1] &lt; t;            }) - events.begin();            for (int j = 1; j &lt;= k; j++) {                dp[i + 1][j] = max(dp[i][j], dp[p][j - 1] + events[i][2]);            }        }        return dp[n][k];    }};\n\n\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1353-最多可以参加的会议数目","url":"/2025/07/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981353-%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%95%B0%E7%9B%AE/","content":"题意给定数组events，其中event[i] = [startDat_i, endDay_i]表示第i个会议开始与结束的时间。每日最多可参加一个会议，求最多可以参加几个会议。（不必完整参加某个会议）\n思路显然是满足贪心性质的，对于每个当前未参加且可参加的会议，应当选择结束时间最早的会议，使用优先队列进行维护可参加的会议即可。\n实现class Solution {public:    int maxEvents(vector&lt;vector&lt;int&gt;&gt;&amp; events) {        int mx = 0;        for (const auto&amp; vec : events) {            mx = max(mx, vec.back());        }        int ans = 0;        const int n = events.size();        vector&lt;vector&lt;int&gt;&gt; cnt(mx + 1);        for (const auto&amp; vec : events) {            cnt[vec.front()].push_back(vec.back());        }        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;&gt;&gt; pq;        for (int i = 0; i &lt;= mx; i++) {            while (!pq.empty() &amp;&amp; pq.top() &lt; i) {                pq.pop();            }            for (const auto&amp; x : cnt[i]) {                pq.push(x);            }            if (!pq.empty()) {                ans++;                pq.pop();            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1865-找出和为指定值的下标对","url":"/2025/07/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981865-%E6%89%BE%E5%87%BA%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E4%B8%8B%E6%A0%87%E5%AF%B9/","content":"题意给定数组nums1与nums2，实现支持以下功能的数据结构：\n\n将nums2下标为index的值增加val\n求满足nums1[i] + nums2[j] == tot的下标对(i, j)的数量\n\n注意：\n\n1 &lt;= nums1.length &lt;= 1000\n1 &lt;= nums2.length &lt;= 10^5\n\n思路显然该数据结构需要记录nums2以用于实现功能1。同时求和为某定值的下标对数，比较容易想到使用哈希记录某一数组各数值数量然后遍历另一数组实现，此处观察数据范围，不难想到应使用哈希记录nums2遍历nums1有着更好的效率。\n实现class FindSumPairs {private:    unordered_map&lt;int, int&gt; cnt;    vector&lt;int&gt; a, b;public:    FindSumPairs(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        a = nums1;        b = nums2;        for (const auto&amp; x : nums2) cnt[x]++;    }        void add(int index, int val) {        cnt[b[index]]--;        b[index] += val;        cnt[b[index]]++;    }        int count(int tot) {        int res = 0;        for (const auto&amp; x : a) {            if (cnt.count(tot - x)) res += cnt[tot - x];        }        return res;    }};/** * Your FindSumPairs object will be instantiated and called as such: * FindSumPairs* obj = new FindSumPairs(nums1, nums2); * obj-&gt;add(index,val); * int param_2 = obj-&gt;count(tot); */\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1394-找出数组中的幸运数","url":"/2025/07/05/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981394-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0/","content":"题意给定数组arr，若某个数的出现频次与它的大小相等则称该数幸运。求arr中最大的幸运数。\n思路简单哈希记录下各个数出现的频率比较大小即可。\n实现class Solution {public:    int findLucky(vector&lt;int&gt;&amp; arr) {        unordered_map&lt;int, int&gt; cnt;        int ans = -1;        for (const auto&amp; x : arr) cnt[x]++;        for (auto [x, t] : cnt) {            if (x == t) {                ans = max(x, ans);            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3307-找出第 K 个字符 II","url":"/2025/07/04/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983307-%E6%89%BE%E5%87%BA%E7%AC%AC-K-%E4%B8%AA%E5%AD%97%E7%AC%A6-II/","content":"题意给定字符串word = \"a\"以及整数k以及一个操作数组operations，对于每次操作，若operations[i] == 0表示该次操作将当前字符串直接复制加入到当前字符串末尾，若operations[i] == 1表示会将当前字符串复制一遍并将其内每个字符全部变为字母表顺序的下一个字符（其中'z'会变为'a'）后将其插入到当前字符串的末尾，求问第k个字符是什么。\n思路那很显然和昨天题意非常相似，只是多了个操作数组限制，当op[i] == 0时前后两截一致也就是不加，当op[i] == 1时与昨日一致，故不过多赘述。\n实现class Solution {public:    char kthCharacter(long long k, vector&lt;int&gt;&amp; operations) {        const int n = operations.size();        k--;        int t = 0;        for (int i = min(50, n - 1); i &gt;= 0; i--) {            if (k &gt;&gt; i &amp; 1) {                t += operations[i];            }        }        return char('a' + t % 26);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3304-找出第 K 个字符 I","url":"/2025/07/03/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983304-%E6%89%BE%E5%87%BA%E7%AC%AC-K-%E4%B8%AA%E5%AD%97%E7%AC%A6-I/","content":"题意给定字符串word = \"a\"以及整数k，对于每次操作，会将当前字符串复制一遍并将其内每个字符全部变为字母表顺序的下一个字符（其中'z'会变为'a'）后将其插入到当前字符串的末尾，求问第k个字符是什么。\n思路可以模拟一下这个过程有\n初始[a]第一次[a][a+1]第二次[[a][a+1]][[a+1][a+2]]第三次[[a][a+1][a+1][a+2]][[a+1][a+2][a+2][a+3]]...\n\n显然可以观察到字符串的长度是随操作次数成倍增长的，那就可以比较自然的想到对k进行一下二进制的回溯。\n实现class Solution {public:    char kthCharacter(int k) {        int t = 0;        while (k &gt; 1) {            t++;            k -= (1 &lt;&lt; __lg(k - 1));        }        return char(t % 26 + 'a');    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3333-找到初始输入字符串 II","url":"/2025/07/02/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983333-%E6%89%BE%E5%88%B0%E5%88%9D%E5%A7%8B%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2-II/","content":"题意给出字符串word与整数k， Alice 在打这个字符串时可能在某个键停留过久使得该字符被输入多次，已知 Alice 最初所输入的字符串长度不小于k，求 Alice 最初想输入的字符串的可能数量。\n思路先不考虑长度问题，那么就和昨天的题非常类似，仅仅是 Alice 犯错次数变为无限多，那还是很好做的。也就是总的方案数是好求的。\n最终字符串的长度大于某值的方案数似乎不太好做，但不大于某长度的就好做很多，进行一个分组dp即可。\n实现using ll = long long;static constexpr int mod = 1e9 + 7;class Solution {public:    int possibleStringCount(string word, int k) {        const int n = word.size();        if (n &lt; k) return 0;        ll ans = 1;        vector&lt;int&gt; f;        for (int i = 0; i &lt; n; ) {            int j;            for (j = i + 1; j &lt; n &amp;&amp; word[i] == word[j]; j++);            k--;            if (j - i &gt; 1) {                ans = ans * (j - i) % mod;                f.push_back(j - i - 1);            }            i = j;        }        if (k &lt;= 0) return ans;        const int m = f.size();        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt; (k));        vector&lt;int&gt; pre(k + 1);        ranges::fill(dp[0], 1);        for (int i = 0; i &lt; m; i++) {            for (int j = 0; j &lt; k; j++) {                pre[j + 1] = (pre[j] + dp[i][j]) % mod;            }            for (int j = 0; j &lt; k; j++) {                dp[i + 1][j] = (pre[j + 1] - pre[max(j - f[i], 0)]) % mod;            }        }        return (ans - dp[m][k - 1] + mod) % mod;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3330-找到初始输入字符串 I","url":"/2025/07/01/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983330-%E6%89%BE%E5%88%B0%E5%88%9D%E5%A7%8B%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2-I/","content":"题意给出字符串word， Alice 在打这个字符串时可能在某个键停留过久使得该字符被输入多次，但 Alice 最多犯一次这样的错误，求 Alice 最初想输入的字符串的可能数量。\n思路若存在多个相邻相同的字符，则均可拆解为 Alice 失误，寻找所有相邻相同的子串长度即可。\n实现class Solution {public:    int possibleStringCount(string word) {        int ans = 1;        const int n = word.size();        for (int i = 0; i &lt; n; ) {            int j;            for (j = i + 1; j &lt; n &amp;&amp; word[j] == word[i]; j++);            ans += j - i - 1;            i = j;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题594-最长和谐子序列","url":"/2025/06/30/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98594-%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/","content":"题意给定数组nums。求nums中最大最小值只差为1的最长子序列长度。\n思路令每个数作为最小值，判断其值加一是否存在以及对应数的数量即可。\n实现class Solution {public:    int findLHS(vector&lt;int&gt;&amp; nums) {        unordered_map&lt;int, int&gt; cnt;        for (const auto&amp; x : nums) cnt[x]++;        int mx = 0;        for (auto [x, t] : cnt) {            if (cnt.count(x + 1)) {                mx = max(mx, t + cnt[x + 1]);            }        }        return mx;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1498-满足条件的子序列数目","url":"/2025/06/29/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981498-%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums与整数target，求nums中满足最大最小值之和不超过target的子序列的个数。\n思路需要求的是子序列，所以其顺序是无所谓的，故而考虑直接排序，这样最大最小值就方便直接选择。\n使得最大最小值之和不超过某一定值，若x + y不超过某值，显然若z &lt; y则必有x + z不超过对应值。故而可以直接使用双指针，记录若选出当前最小值，最大值可以选哪个，再计算出对应子序列数量即可。\n实现using ll = long long;static constexpr int mod = 1e9 + 7;ll powMod(ll a, ll b) {    ll res = 1;    while (b) {        if (b &amp; 1) {            res = res * a % mod;        }        a = a * a % mod;        b &gt;&gt;= 1;    }    return res;}static constexpr int N =  1e5;ll p[N + 10];int init = []() {    p[0] = 1;    for (int i = 1; i &lt;= N; i++) {        p[i] = (p[i - 1] &lt;&lt; 1) % mod;    }    return 0;} ();class Solution {public:    int numSubseq(vector&lt;int&gt;&amp; nums, int target) {        ranges::sort(nums);        ll ans = 0;        for (int l = 0, r = int(nums.size()) - 1 ; l &lt;= r; ) {            if (nums[l] + nums[r] &gt; target) {                r--;            } else {                // ans = (ans + powMod(2, r - l)) % mod;                ans += p[r - l];                if (ans &gt; mod) ans -= mod;                l++;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2099-找到和最大的长度为 K 的子序列","url":"/2025/06/28/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982099-%E6%89%BE%E5%88%B0%E5%92%8C%E6%9C%80%E5%A4%A7%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA-K-%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/","content":"题意给定整数数组nums与整数k，求nums中长度为k的和最大的子序列。\n思路贪心选出前k大的数即可。\n实现class Solution {public:    vector&lt;int&gt; maxSubsequence(vector&lt;int&gt;&amp; nums, int k) {        const int n = nums.size();        vector&lt;int&gt; p(n);        ranges::iota(p, 0);        ranges::sort(p, [&amp;](const int&amp; x, const int&amp; y) {            return nums[x] &gt; nums[y];        });        p.resize(k);        ranges::sort(p);        for (auto&amp; i : p) i = nums[i];        return p;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2014-重复 K 次的最长子序列","url":"/2025/06/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982014-%E9%87%8D%E5%A4%8D-K-%E6%AC%A1%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/","content":"题意给定字符串s与整数k，求最长且字典序最大且在s中出现k次的子序列。\n注意到 \n思路好像有点难，但注意到数据范围有暗示s.size() &lt;= 8 * k，那也就是说答案子序列最长为8，进行一个枚举复杂度是可以接受的，故筛出至少出现k次的字符，进行枚举对应子序列即可。\n实现class Solution {public:    string longestSubsequenceRepeatedK(string s, int k) {        const int n = s.size();        vector&lt;array&lt;int, 26&gt;&gt; nxt(n);        array&lt;int, 26&gt; cnt, tmp;        cnt.fill(0); tmp.fill(n);        for (const auto&amp; ch : s) cnt[ch - 'a']++;        for (int i = n - 1; i &gt;= 0; i--) {            tmp[s[i] - 'a'] = i;            nxt[i] = tmp;        }        string a;        for (int i = 25; i &gt;= 0; i--) {            a.insert(a.end(), cnt[i] / k, char(i + 'a'));        }        const int m = a.size();        vector&lt;bool&gt; vis(m);        string ans;        auto check = [&amp;](const string&amp; x) -&gt; void {            if (x.size() &lt; ans.size() || (x.size() == ans.size() &amp;&amp; x &lt;= ans)) return;            int cur = 0, t = k;            while (t--) {                for (const auto&amp; ch : x) {                    if (cur &gt;= n) return;                    cur = nxt[cur][ch - 'a'] + 1;                }            }            if (cur == n + 1) return;            ans = x;        };        string x;        auto dfs = [&amp;](this auto&amp;&amp; self) -&gt; void {            check(x);            if (x.size() == m) return;            for (int i = 0; i &lt; m; i++) {                if (vis[i] || (i &amp;&amp; a[i - 1] == a[i] &amp;&amp; !vis[i - 1])) continue;                x += a[i];                vis[i] = true;                self();                x.pop_back();                vis[i] = false;            }        };        dfs();        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2311-小于等于 K 的最长二进制子序列","url":"/2025/06/26/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982311-%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E-K-%E7%9A%84%E6%9C%80%E9%95%BF%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E5%BA%8F%E5%88%97/","content":"题意给定二进制字符串s与整数k，求字符串s子序列的最大长度，要求该子序列的对应二进制数不大于k，允许存在前导零。\n思路显然贪心即可：\n允许存在前导零，那显然应该将所有0加入答案。\n对于1，可以发现最好情况下将其加入答案使得答案加一，最坏情况下需要删除1到多个0才可将其加入答案子序列。\n那么从后往前贪即可得到最长答案，注意别爆数据范围即可。\n实现class Solution {public:    int longestSubsequence(string s, int k) {        const int n = s.size();        int ans = 0;        for (int i = n - 1, cur = 0; i &gt;= 0; i--) {            if (s[i] == '0') ans++;            else {                if (ans &gt;= 30) continue;                if ((cur | (1 &lt;&lt; ans)) &lt;= k) {                    cur |= 1 &lt;&lt; ans;                    ans++;                }            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2040-两个有序数组的第 K 小乘积","url":"/2025/06/25/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982040-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%AC-K-%E5%B0%8F%E4%B9%98%E7%A7%AF/","content":"题意给定两个升序数组nums1与nums2以及一个整数k，求第k小的nums1[i] * nums2[j]。\n思路比较显然是一个二分。\n列出矩阵，其中matrix[i][j]表示nums1[i] * nums2[j]的结果，由于两个数组均为升序排序，故可得一些性质，由此二分答案即可。\n实现class Solution {using ll = long long;public:    long long kthSmallestProduct(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, long long k) {        const int n = nums1.size(), m = nums2.size();        int x = ranges::lower_bound(nums1, 0) - nums1.begin();        int y = ranges::lower_bound(nums2, 0) - nums2.begin();            auto check = [&amp;](ll mid) -&gt; bool {            ll cnt = 0;            if (mid &lt; 0) {                for (int i = 0, j = y; i &lt; x &amp;&amp; j &lt; m &amp;&amp; cnt &lt; k; ) {                    if (1ll * nums1[i] * nums2[j] &gt; mid) j++;                    else {                        cnt += m - j;                        i++;                    }                }                for (int i = x, j = 0; i &lt; n &amp;&amp; j &lt; y &amp;&amp; cnt &lt; k; ) {                    if (1ll * nums1[i] * nums2[j] &gt; mid) i++;                    else {                        cnt += n - i;                        j++;                    }                }            } else {                cnt = 1ll * x * (m - y) + 1ll * (n - x) * y;                for (int i = 0, j = y - 1; i &lt; x &amp;&amp; j &gt;= 0 &amp;&amp; cnt &lt; k; ) {                    if (1ll * nums1[i] * nums2[j] &gt; mid) i++;                    else {                        cnt += x - i;                        j--;                    }                }                for (int i = x, j = m - 1; i &lt; n &amp;&amp; j &gt;= y &amp;&amp; cnt &lt; k; ) {                    if (1ll * nums1[i] * nums2[j] &gt; mid) j--;                    else {                        cnt += j - y + 1;                        i++;                    }                }            }            return cnt &gt;= k;        };        array&lt;ll, 4&gt; tmp = {1ll * nums1.front() * nums2.front(), 1ll * nums1.front() * nums2.back(), 1ll * nums1.back() * nums2.front(), 1ll * nums1.back() * nums2.back()};        auto [lo, hi] = ranges::minmax(tmp);        while (lo &lt; hi) {            ll mid = lo + hi &gt;&gt; 1;            if (check(mid)) {                hi = mid;            } else {                lo = mid + 1;            }        }        return lo;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2200-找出数组中的所有 K 近邻下标","url":"/2025/06/24/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982200-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89-K-%E8%BF%91%E9%82%BB%E4%B8%8B%E6%A0%87/","content":"题意给定数组nums与整数key和k。求nums中所有与值为key距离不超过k的下标集合，升序返回。\n思路记录已经加入答案集合的右边界，遍历寻找值为key的下标即可。\n实现class Solution {public:    vector&lt;int&gt; findKDistantIndices(vector&lt;int&gt;&amp; nums, int key, int k) {        const int n = nums.size();        vector&lt;int&gt; ans;        for (int i = 0, l = 0; i &lt; n; i++) {            while (i - l &gt; k) l++;            if (nums[i] == key) {                while (l &lt; n &amp;&amp; abs(i - l) &lt;= k) ans.push_back(l++);            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2081-k 镜像数字的和","url":"/2025/06/23/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982081-k-%E9%95%9C%E5%83%8F%E6%95%B0%E5%AD%97%E7%9A%84%E5%92%8C/","content":"题意定义k镜像数字为在十进制与k进制下均为回文数字的正整数\n对于给定的整数k与n，求出前n小的k镜像数字之和。\n思路注意到n与k的数据范围不大，直接预处理作答即可。\n实现using ll = long long;static constexpr int MX = 30;static constexpr int K = 10;ll ans[K][MX + 10];bool check(ll x, int k) {    string s;    while (x) {        s += char(x % k + '0');        x /= k;    }    for (int l = 0, r = int(s.size()) - 1; l &lt;= r; l++, r--) {        if (s[l] != s[r]) return false;    }    return true;}bool over() {    bool res = true;    for (int i = 2; i &lt; K &amp;&amp; res; i++) {        res &amp;= ans[i][0] &gt;= MX;    }    return res;}int init = []() {    for (int b = 1; ; b *= 10) {        for (int i = b; i &lt; b * 10; i++) {            string s = to_string(i);            string r = s;            reverse(r.begin(), r.end());            s.pop_back();            s += r;            ll u = stoll(s);            for (int k = 2; k &lt; K; k++) {                if (ans[k][0] &gt;= MX) continue;                if (check(u, k)) ans[k][++ans[k][0]] = u;            }        }        for (int i = b; i &lt; b * 10; i++) {            string s = to_string(i);            string r = s;            reverse(r.begin(), r.end());            s += r;            ll u = stoll(s);            for (int k = 2; k &lt; K; k++) {                if (ans[k][0] &gt;= MX) continue;                if (check(u, k)) ans[k][++ans[k][0]] = u;            }        }        if (over()) break;    }    for (int k = 2; k &lt; 10; k++) {        for (int i = 2; i &lt;= MX; i++) {            // cout &lt;&lt; k &lt;&lt; ' ' &lt;&lt; i &lt;&lt; ' ' &lt;&lt; ans[k][i] &lt;&lt; '\\n';            ans[k][i] += ans[k][i - 1];        }    }    return 0;} ();class Solution {public:    long long kMirror(int k, int n) {        return ans[k][n];    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2138-将字符串拆分为若干长度为 k 的组","url":"/2025/06/22/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982138-%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86%E4%B8%BA%E8%8B%A5%E5%B9%B2%E9%95%BF%E5%BA%A6%E4%B8%BA-k-%E7%9A%84%E7%BB%84/","content":"题意给定字符串s与整数k与字符fill，需将s分割为长度均为k的子串，长度不足k的用字符fill填充。\n思路简单模拟即可。\n实现class Solution {public:    vector&lt;string&gt; divideString(string s, int k, char fill) {        const int n = s.size();        vector&lt;string&gt; ans;        for (int i = 0; i &lt; n; i += k) {            ans.push_back(s.substr(i, k));            if (i + k &gt;= n) {                while (ans.back().size() &lt; k) ans.back() += fill;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3085-成为 K 特殊字符串需要删除的最少字符数","url":"/2025/06/21/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983085-%E6%88%90%E4%B8%BA-K-%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E5%88%A0%E9%99%A4%E7%9A%84%E6%9C%80%E5%B0%91%E5%AD%97%E7%AC%A6%E6%95%B0/","content":"题意给定字符串word与整数k，可以任意删除word中的字符，需使得word中的任意两种字符出现次数差值不超过k，求需要删除的最小次数。\n思路显然至少存在一种字符不需要删除，进行枚举贪心即可。\n实现class Solution {static constexpr int N = 26;public:    int minimumDeletions(string word, int k) {        array&lt;int, N&gt; cnt;        for (const auto&amp; ch : word) cnt[ch - 'a']++;        ranges::sort(cnt);        int mx = 0;        for (int i = 0; i &lt; N; i++) {            int tmp = 0;            for (int j = i; j &lt; N; j++) {                tmp += min(cnt[j], cnt[i] + k);            }            mx = max(mx, tmp);        }        return word.size() - mx;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3443-K 次修改后的最大曼哈顿距离","url":"/2025/06/20/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983443-K-%E6%AC%A1%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/","content":"题意初始位于坐标原点(0, 0)，给定由NSWE组成的字符串，分别表示向北南西东走一格，最多可以修改字符串的k个字符，求移动过程中离原点的最大曼哈顿距离。\n思路贪心地进行模拟即可。\n实现class Solution {public:    int maxDistance(string s, int k) {        int x = 0, y = 0;        const int n = s.size();        int ans = 0;        for (int i = 0; i &lt; n; i++) {            if (s[i] == 'N') {                y++;            } else if (s[i] == 'S') {                y--;            } else if (s[i] == 'E') {                x++;            } else {                x--;            }            ans = max(ans, abs(x) + abs(y) + min(2 * k, i + 1 - abs(x) - abs(y)));        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2294-划分数组使最大差为 K","url":"/2025/06/19/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982294-%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E4%BD%BF%E6%9C%80%E5%A4%A7%E5%B7%AE%E4%B8%BA-K/","content":"题意给定数组nums与整数k，将nums划分为子序列，使得每个子序列最大值与最小值的差值不超过k，求所需划分的最少子序列数。\n思路显然符合贪心性质，直接排序开贪即可。\n实现class Solution {public:    int partitionArray(vector&lt;int&gt;&amp; nums, int k) {        ranges::sort(nums);        const int n = nums.size();        int cnt = 1;        for (int l = 0, i = 0; i &lt; n; i++) {            if (nums[i] - nums[l] &lt;= k) continue;            cnt++;            l = i;        }        return cnt;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2966-划分数组并满足最大差限制","url":"/2025/06/18/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982966-%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E5%B9%B6%E6%BB%A1%E8%B6%B3%E6%9C%80%E5%A4%A7%E5%B7%AE%E9%99%90%E5%88%B6/","content":"题意给定长度为3的倍数的数组nums，以及一个正整数k，要求把数组分割为长度均为3的子数组，要求子数组中任意两数差均小于等于k\n思路什么样的子数组满足任意两数差均小于等于k呢，显然是最大最小值差值小于等于k的，因此不难想到首先进行排序，贪心地不断连续选取3个数为一组即可。\n实现class Solution {public:    vector&lt;vector&lt;int&gt;&gt; divideArray(vector&lt;int&gt;&amp; nums, int k) {        const int n = nums.size();        vector&lt;vector&lt;int&gt;&gt; ans;        ranges::sort(nums);        for (int i = 2; i &lt; n; i += 3) {            if (nums[i] - nums[i - 2] &lt;= k) {                ans.push_back({nums[i], nums[i - 1], nums[i - 2]});            } else {                return {};            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3405-统计恰好有 K 个相等相邻元素的数组数目","url":"/2025/06/17/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983405-%E7%BB%9F%E8%AE%A1%E6%81%B0%E5%A5%BD%E6%9C%89-K-%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/","content":"题意对于给定的三个正整数n、m、k，称满足以下条件的数组arr为好数组\n\narr的长度为n\narr的元素均为[1, m]\narr中恰好有k对满足arr[i] == arr[i - 1]的下标\n\n求好数组arr的构造数\n思路仔细观察可以发现该题其实就是个数学题，进行一个推式子即可\n首先长为n的数组共有n - 1对相邻元素，要求恰好有k对相邻元素相同，也就是说有n - 1 - k对相邻元素不同。也就是说有会有n - 1 - k个数将整个数组分割为n - k段，每段元素相同。\n计算分割方案与分割后填色数即可。\n实现static constexpr int mod = 1e9 + 7;static constexpr int N = 1e5;int f[N + 1], nf[N + 1];int powMod(int a, int b) {    int res = 1;    while (b) {        if (b &amp; 1) {            res = 1ll * res * a % mod;        }        a = 1ll * a * a % mod;        b &gt;&gt;= 1;    }    return res;}int C(int n, int k) {    return 1ll * f[n] * nf[k] % mod * nf[n - k] % mod;}int init = []() -&gt; int {    f[0] = 1;    for (int i = 1; i &lt;= N; i++) {        f[i] = 1ll * f[i - 1] * i % mod;    }    nf[N] = powMod(f[N], mod - 2);    for (int i = N; i &gt; 0; i--) {        nf[i - 1] = 1ll * nf[i] * i % mod;    }    return 0;} ();class Solution {public:    int countGoodArrays(int n, int m, int k) {        return 1ll * C(n - 1, k) * m % mod * powMod(m - 1, n - k - 1) % mod;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2016-增量元素之间的最大差值","url":"/2025/06/16/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982016-%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/","content":"题意给定数组nums，求满足以下条件的nums[j] - nums[i]的最大值\n\n\n\n\n思路对于同一个i显然应该选择其后最大的nums[j]才能使得nums[j] - nums[i]最大，因此不难想到使用后缀最大即可。\n实现class Solution {public:    int maximumDifference(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        int ans = -1;        for (int i = n - 1, mx = -1; i &gt;= 0; i--) {            if (mx &gt; nums[i]) ans = max(ans, mx - nums[i]);            mx = max(mx, nums[i]);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1432-改变一个整数能得到的最大差值","url":"/2025/06/15/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981432-%E6%94%B9%E5%8F%98%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E8%83%BD%E5%BE%97%E5%88%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/","content":"题意给定一个整数num，可以将其中某一个数字全部替换为另一数字，求可以得到的最大值与最小值的差值。但不可以转为有前导0的数\n思路显然就是做题的题加上不能有前导零的条件，进行贪心即可。\n实现class Solution {public:    int maxDiff(int num) {        string s = to_string(num);        string t = s;        const int n = s.size();        for (int i = 0, b = -1; i &lt; n; i++) {            if (s[i] == '9') continue;            if (b == -1) {                b = s[i] - '0';                s[i] = '9';            } else if (b == s[i] - '0') s[i] = '9';        }        if (t.front() != '1') {            for (int i = n - 1; i &gt;= 0; i--) {                if (t[i] == t.front()) t[i] = '1';            }        } else {            for (int i = 0, b = -1; i &lt; n; i++) {                if (t[i] &lt;= '1') continue;                if (b == -1) {                    b = t[i] - '0';                }                if (t[i] - '0' == b) t[i] = '0';            }        }        return stoi(s) - stoi(t);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2566-替换一个数字后的最大差值","url":"/2025/06/14/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982566-%E6%9B%BF%E6%8D%A2%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/","content":"题意给定一个整数num，可以将其中某一个数字全部替换为另一数字，求可以得到的最大值与最小值的差值。\n思路比较显然是可以贪心的，得最大值应该使得最靠前非9的数变为9，得最小值应该是最靠前非0的数变为0，直接进行模拟即可。\n实现class Solution {public:    int minMaxDifference(int num) {        string s = to_string(num);        string t = s;        const int n = s.size();        for (int i = 0, b = -1; i &lt; n; i++) {            if (s[i] == '9') continue;            if (b == -1) {                b = s[i] - '0';                s[i] = '9';            } else if (b == s[i] - '0') s[i] = '9';        }        for (int i = 0, b = -1; i &lt; n; i++) {            if (t[i] == '0') continue;            if (b == -1) {                b = t[i] - '0';                t[i] = '0';            } else if (b == t[i] - '0') t[i] = '0';        }        return stoi(s) - stoi(t);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2616-最小化数对的最大差值","url":"/2025/06/13/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982616-%E6%9C%80%E5%B0%8F%E5%8C%96%E6%95%B0%E5%AF%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/","content":"题意给定整数数组nums与整数p，找出p对不同下标对(i, j)使得abs(nums[i] - nums[j])最大值最小时的最大值。每个下标在p对下标对中仅出现一次。\n思路使得最大值最小，显然进行二分即可。\n实现class Solution {public:    int minimizeMax(vector&lt;int&gt;&amp; nums, int p) {        ranges::sort(nums);        const int n = nums.size();        auto check = [&amp;](int x) -&gt; bool {            int t = 0;            for (int i = 0; i &lt; n - 1; i++) {                if (nums[i + 1] - nums[i] &lt;= x) {                    t++;                    i++;                }            }            return t &gt;= p;        };        int lo = 0, hi = nums.back() - nums.front();        while (lo &lt; hi) {            int mid = lo + hi &gt;&gt; 1;            if (check(mid)) hi = mid;            else lo = mid + 1;        }        return lo;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3423-循环数组中相邻元素的最大差值","url":"/2025/06/12/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983423-%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/","content":"题意给定循环数组nums，求相邻元素最大绝对差值。\n思路直接遍历求即可\n实现class Solution {public:    int maxAdjacentDistance(vector&lt;int&gt;&amp; nums) {        int ans = -200;        const int n = nums.size();        for (int i = 1; i &lt;= n; i++) {            ans = max(ans, abs(nums[i % n] - nums[i - 1]));        }        return ans;    }};\n\n\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3345-奇偶频次间的最大差值 II","url":"/2025/06/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983345-%E5%A5%87%E5%81%B6%E9%A2%91%E6%AC%A1%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC-II/","content":"题意给定由['0', '4']组成的字符串s与整数k，求s的子串subs中freq[a] - freq[b]的最大值，其中：\n\nsubs长度至少为k\nfreq表示该字符在subs中出现的次数\nfreq[a]为奇数\nfreq[b]为偶数\n\n思路显然应该使用滑动窗口与前缀最小。\n实现class Solution {static constexpr int inf = 1e9;static constexpr int N = 5;public:    int maxDifference(string s, int k) {        int ans = -inf;        const int n = s.size();        for (int x = 0; x &lt; N; x++) {            for (int y = 0; y &lt; N; y++) {                if (x == y) continue;                array&lt;int, N&gt; cur, pre;                cur.fill(0); pre.fill(0);                array&lt;array&lt;int, 2&gt;, 2&gt; mn;                for (auto&amp; i : mn) i.fill(inf);                int left = 0;                for (int i = 0; i &lt; n; i++) {                    cur[s[i] - '0']++;                    while (i + 1 - left &gt;= k &amp;&amp; cur[x] &gt; pre[x] &amp;&amp; cur[y] &gt; pre[y]) {                        int&amp; t = mn[pre[x] &amp; 1][pre[y] &amp; 1];                        t = min(t, pre[x] - pre[y]);                        pre[s[left++] - '0']++;                    }                    ans = max(ans, cur[x] - cur[y] - mn[cur[x] &amp; 1 ^ 1][cur[y] &amp; 1]);                }            }        }        return  ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3442-奇偶频次间的最大差值 I","url":"/2025/06/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983442-%E5%A5%87%E5%81%B6%E9%A2%91%E6%AC%A1%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC-I/","content":"题意给定小写字母字符串s，求diff = a1 - a2的最大值\n其中a1为字符串中任意出现次数为奇数次的字符的出现次数\na2为字符串中任意出现次数为偶数次的字符的出现次数\n思路要使得diff最大，显然应该使得a1取得最大a2取得最小\n也就是选取出现次数为奇数的最大，出现次数为偶数的最大，注意出现0次也就是未出现的字符应不考虑即可。\n实现class Solution {public:    int maxDifference(string s) {        array&lt;int, 26&gt; cnt;        for (const auto&amp; ch : s) {            cnt[ch - 'a']++;        }        int mx = 0, mn = INT_MAX;        for (const auto&amp; i : cnt) {            if (i &amp; 1) mx = max(mx, i);            else if (i) mn = min(mn, i);        }        return mx - mn;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题440-字典序的第K小数字","url":"/2025/06/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98440-%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACK%E5%B0%8F%E6%95%B0%E5%AD%97/","content":"题意给定整数n和k，返回[1, n]中字典序第k小的数字\n思路不妨将数字当作字符串看待，那又比较自然的可以想到字典树。\n是返回[1, n]范围内的数，故而可以得到一颗根节点有9条边其余点有10条边共有n + 1个结点的树。\n将[1, n]的数按照字典序排序，显然是按照先序遍历该树得到，本题数据量较大不太可以直接遍历模拟得到，考虑使用子树结点数进行加速判断：假定当前处于任意结点，需要得到第k小的数，若其第一个子节点子树内所有结点数为x，若 显然所需点不在该子树内，若显然所需点在该子树内。\n实现class Solution {using ll = long long;public:    int findKthNumber(int n, int k) {        int p = 1;        for (int i = n / 10; i &gt; 0; i /= 10) p *= 10;        auto cal = [&amp;](int x) -&gt; int {            int sz = (p - 1) / 9;            ll l = 1ll * p * x, r = 1ll * p * (x + 1);            if (l &lt;= n) {                sz += min(r, n + 1ll) - l;            }            return sz;        };        int x = 1;        k--;        while (k) {            int sz = cal(x);            if (sz &lt;= k) {                k -= sz;                x++;            } else {                p /= 10;                x *= 10;                k--;            }        }        return x;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题386-字典序排数","url":"/2025/06/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98386-%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0/","content":"题意给定整数n，按字典序返回范围[1, n]内所有整数\n思路按字典序进行枚举即可。\n实现class Solution {public:    vector&lt;int&gt; lexicalOrder(int n) {        vector&lt;int&gt; ans(n);        for (int i = 0, num = 1; i &lt; n; i++) {            ans[i] = num;            if (num * 10 &lt;= n) num *= 10;            else {                while (num % 10 == 9 || num + 1 &gt; n) {                    num /= 10;                }                num++;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3170-删除星号以后字典序最小的字符串","url":"/2025/06/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983170-%E5%88%A0%E9%99%A4%E6%98%9F%E5%8F%B7%E4%BB%A5%E5%90%8E%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"题意给定含*的字符串s，要求删除所有*，同时每次删除操作必须删除该*号左侧任意字典序最小的字母，求最终字典序最小的字符串。\n思路对于每次操作，应该删除当前*左侧最右的字典序最小字母，使用栈进行记录即可。\n实现class Solution {static constexpr int N = 26;public:    string clearStars(string s) {        vector&lt;vector&lt;int&gt;&gt; stk(N);        const int n = s.size();        int mask = 0;        for (int i = 0; i &lt; n; i++) {            if (s[i] == '*') {                for (int j = 0; j &lt; 26; j++) {                    if (mask &gt;&gt; j &amp; 1) {                        s[stk[j].back()] = '*';                        stk[j].pop_back();                        if (stk[j].empty()) mask ^= 1 &lt;&lt; j;                        break;                    }                }            } else {                stk[s[i] - 'a'].push_back(i);                mask |= 1 &lt;&lt; (s[i] - 'a');            }        }        s.erase(ranges::remove(s, '*').begin(), s.end());        return s;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2434-使用机器人打印字典序最小的字符串","url":"/2025/06/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982434-%E4%BD%BF%E7%94%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%89%93%E5%8D%B0%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"题意给定字符串s与空白字符串t，以及初始也为空的字符串ans，每次操作可以将s的第一个字符移到t的尾部，或将t最后一个字符移动到ans的尾部，操作直到s和t变为空字符串。求可得到的字典序最小的ans\n思路可以发现这是一个入栈出栈得到字符串的问题，s是原始字符串，t就是栈，移动到t尾部等价于入栈，将t尾加入ans等价于出栈。\n那还是比较经典的，若有还未入栈的字符含有比栈顶小的字符应一路入栈直到当前后缀中最小的字符入栈，再将该最小字符出栈；若未入栈的字符均大于栈顶字符，直接出栈即可。\n加速寻找后缀最小可以使用后缀min。\n实现class Solution {public:    string robotWithString(string s) {        const int n = s.size();        string ans, stk;        vector&lt;int&gt; last(n + 1, n);        for (int i = n - 1; i &gt;= 0; i--) {            if (last[i + 1] == n || s[i] &lt;= s[last[i + 1]]) {                last[i] = i;            } else {                last[i] = last[i + 1];            }        }        for (int cur = 0; cur &lt; n; ) {            if (stk.empty() || stk.back() &gt; s[last[cur]]) {                ans += s[last[cur]];                stk += s.substr(cur, last[cur] - cur);                cur = last[cur] + 1;            } else {                ans += stk.back();                stk.pop_back();            }        }        reverse(stk.begin(), stk.end());        ans += stk;        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1061-按字典序排列最小的等效字符串","url":"/2025/06/05/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981061-%E6%8C%89%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E5%88%97%E6%9C%80%E5%B0%8F%E7%9A%84%E7%AD%89%E6%95%88%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"题意给定两等长字符串s1与s2，以及另一字符串baseStr\ns1与s2相同位置的字符等价，即s1[i]与s2[i]等价\n可将baseStr中的字符任意替换成与其等价的字符\n求baseStr替换后字典序最小的结果。\n思路比较自然可以想到使用并查集，同一集合内的字符是可以互相替换的，要使得字典序最小，应将同一集合内的字符均替换为最小的字符。\n实现class Solution {static constexpr int N = 26;public:    string smallestEquivalentString(string s1, string s2, string baseStr) {        array&lt;int, N&gt; fa;        ranges::iota(fa, 0);        auto find = [&amp;](this auto&amp;&amp; self, int u) -&gt; int {            if (fa[u] == u) return u;            return fa[u] = self(fa[u]);        };        auto merge = [&amp;](int x, int y) -&gt; void {            x = find(x); y = find(y);            if (x == y) return;            if (x &gt; y) swap(x, y);            fa[y] = x;            return;        };        const int n = s1.size();        for (int i = 0; i &lt; n; i++) {            merge(s1[i] - 'a', s2[i] - 'a');        }        for (auto&amp; ch : baseStr) {            ch = char(find(ch - 'a') + 'a');        }        return baseStr;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3403-从盒子中找出字典序最大的字符串 I","url":"/2025/06/04/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983403-%E4%BB%8E%E7%9B%92%E5%AD%90%E4%B8%AD%E6%89%BE%E5%87%BA%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%A4%A7%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-I/","content":"题意给定字符串word，要将其划分为numFriends个非空子串，问字典序最大的子串。\n思路数据范围是比较小的，怎么做都可以，直接枚举子串起点进行比较就好。\n实现class Solution {public:    string answerString(string word, int numFriends) {        if (numFriends == 1) return word;        const int n = word.size();        string ans = word.substr(0, n - numFriends + 1);        for (int i = 1; i &lt; n; i++) {            if (word[i] &lt; ans.front()) continue;            else if (word[i] == ans.front()) {                string t = word.substr(i, n - i - max(numFriends - i - 1, 0));                if (t &gt; ans) ans = t;            } else {                ans = word.substr(i, n - i - max(numFriends - i - 1, 0));            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1298-你能从盒子里获得的最大糖果数","url":"/2025/06/03/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981298-%E4%BD%A0%E8%83%BD%E4%BB%8E%E7%9B%92%E5%AD%90%E9%87%8C%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B3%96%E6%9E%9C%E6%95%B0/","content":"题意给定n个盒子与盒子的状态，盒子可能开着或关闭若关闭需用对应钥匙打开，同时盒子中有一些糖有一些钥匙甚至一些其他盒子；给出最开始所拥有的盒子，求最多可以获得多少糖果。\n思路就是简单的模拟，没什么思维难度也没什么代码实现难度，不知道为什么标困难，数据范围也小，应该是怎么写都可以的。\n实现class Solution {public:    int maxCandies(vector&lt;int&gt;&amp; status, vector&lt;int&gt;&amp; candies, vector&lt;vector&lt;int&gt;&gt;&amp; keys, vector&lt;vector&lt;int&gt;&gt;&amp; containedBoxes, vector&lt;int&gt;&amp; initialBoxes) {        const int n = status.size();        vector&lt;bool&gt; box(n), key(n), done(n);        vector&lt;int&gt; q;        for (auto&amp; x : initialBoxes) {            box[x] = true;            if (status[x]) q.push_back(x);        }        int ans = 0;        for (int cur = 0; cur &lt; q.size(); cur++) {            int x = q[cur];            if (done[x]) continue;            done[x] = true;            ans += candies[x];            for (auto k : keys[x]) {                key[k] = true;                if (box[k] &amp;&amp; !done[k]) q.push_back(k);            }            for (auto b : containedBoxes[x]) {                box[b] = true;                if ((key[b] || status[b]) &amp;&amp; !done[b]) q.push_back(b);            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题135-分发糖果","url":"/2025/06/02/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/","content":"题意给定数组ratings表示小朋友们的分数，小朋友们站成一排，要求给他们每人至少1颗糖果，且若某孩子分数大于相邻的孩子则其糖果数一定大于相邻分数较小的孩子，求最少需要多少糖果。\n思路贪心地想当然是先给最小的一颗糖，然后再慢慢根据大小关系往两边放。\n就比较自然的可以想到建图然后按拓扑序分发糖果。\n但是写完后发现好像没必要，正着跑一趟反着跑一趟与上一个小朋友比较大小关系即可，不知道为什么会标困难，可能也是受这个影响想复杂了。\n实现建图拓扑序：\nclass Solution {public:    int candy(vector&lt;int&gt;&amp; ratings) {        const int n = ratings.size();        vector&lt;vector&lt;int&gt;&gt; e(n);        vector&lt;int&gt; q, d(n), ans(n);        for (int i = 0; i &lt; n; i++) {            if (i &amp;&amp; ratings[i] &lt; ratings[i - 1]) {                e[i].push_back(i - 1);                d[i - 1]++;            }            if (i != n - 1 &amp;&amp; ratings[i] &lt; ratings[i + 1]) {                e[i].push_back(i + 1);                d[i + 1]++;            }        }        for (int i = 0; i &lt; n; i++) {            if (d[i] == 0) q.push_back(i);            ans[i]++;        }        for (int cur = 0; cur &lt; q.size(); cur++) {            int x = q[cur];            for (auto v : e[x]) {                d[v]--;                ans[v] = max(ans[v], ans[x] + 1);                if (d[v] == 0) q.push_back(v);            }        }        return accumulate(ans.begin(), ans.end(), 0);    }};\n\n\n\n直接贪心：\nclass Solution {public:    int candy(vector&lt;int&gt;&amp; ratings) {        const int n = ratings.size();        vector&lt;int&gt; ans(n, 1);        for (int i = 1; i &lt; n; i++) {            if (ratings[i] &gt; ratings[i - 1]) ans[i] = ans[i - 1] + 1;        }        for (int i = n - 2; i &gt;= 0; i--) {            if (ratings[i] &gt; ratings[i + 1]) ans[i] = max(ans[i], ans[i + 1] + 1);        }        return accumulate(ans.begin(), ans.end(), 0);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2929-给小朋友们分糖果 II","url":"/2025/06/01/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982929-%E7%BB%99%E5%B0%8F%E6%9C%8B%E5%8F%8B%E4%BB%AC%E5%88%86%E7%B3%96%E6%9E%9C-II/","content":"题意给定正整数n和limit\n求将n颗糖果分给3个小朋友，每人所得不超过limit颗，有多少种方案数。\n思路正着推好像有点难，可以考虑正难则反。\n求总分配方案数减去有人获得超limit颗的方案数显然比正着推简单一些。\n总分配方案数显然是用隔板法，有种\n有人获得超limit颗需要用到隔板法与一点容斥的想法：\n首先是至少含一人获得超limit，显然应该是首先分配出limit + 1颗糖果再将剩下的分给三人，然后将这limit + 1颗糖果分给任意人即有\n但显然至少一人含超limit的情况包含了至少两人含超与至少三人含超，并且存在重复计数，利用容斥的思想应该减去至少两人含超加上三人含超，由此可得答案。\n至少两人含超limit颗糖果思想同上有\n至少三人含超limit颗糖果有\n至于这个容斥想法怎么来可以简单证明下：\n记三个小朋友分别为 A B C至少一个人含超过 limit 颗糖果有如下情况：\tA 含超过 limit 颗：A AB AC ABC\tB 含超过 limit 颗：B AB BC ABC\tC 含超过 limit 颗：C AC BC ABC显然是存在重复计数的至少两人含超过 limit 颗糖果有如下情况：\tAB 含超过 limit 颗：AB ABC\tAC 含超过 limit 颗：AC ABC\tBC 含超过 limit 颗：BC ABC至少三人含超过 limit 颗糖果有如下情况：\tABC 含超过 limit 颗：ABC\n\n\n\n实现class Solution {using ll = long long;public:    long long distributeCandies(int n, int limit) {        auto cal = [](int x) -&gt; ll {            if (x &lt; 2) return 0;            return 1ll * x * (x - 1) / 2;        };        return cal(n + 2) - 3 * cal(n - limit + 1) + 3 * cal(n - 2 * limit) - cal(n - 3 * limit - 1);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题909-蛇梯棋","url":"/2025/05/31/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98909-%E8%9B%87%E6%A2%AF%E6%A3%8B/","content":"题意给定大小为n * n的矩阵board，初始位于1目标为n * n。每次可走[1, 6]格，若目的格点board值不为-1则传送至目标格点值处，反之若目标格点board值为-1则到达目标格点，不会连续传送即：若通过传送到达点x且x处board值不为-1不会继续进行传送而是停留在x点处。\n求问到达终点最少走几次。\n思路可以考虑直接BFS求出到各点最少移动步数。\n只需注意格点编号类似于’Z’字型，注意进行转换即可。\n实现class Solution {public:    int snakesAndLadders(vector&lt;vector&lt;int&gt;&gt;&amp; board) {        const int n = board.size();                auto cal = [&amp;](int a) -&gt; int {            int x = a / n, y = a % n;            if (x &amp; 1) return board[n - 1 - x][n - 1 - y];            return board[n - 1 - x][y];        };                vector&lt;int&gt; q{0};        vector&lt;bool&gt; vis(n * n);        for (int cur = 0; !q.empty(); cur++) {            vector&lt;int&gt; nq;            for (auto x : q) {                if (x == n * n - 1) return cur;                for (int t = x + 1; t &lt;= x + 6; t++) {                    if (t &gt;= n * n) break;                    int y = cal(t);                    if (y == -1) y = t;                    else y--;                    if (!vis[y]) {                        vis[y] = true;                        nq.push_back(y);                    }                }            }            swap(q, nq);        }        return -1;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2359-找到离给定两个节点最近的节点","url":"/2025/05/30/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982359-%E6%89%BE%E5%88%B0%E7%A6%BB%E7%BB%99%E5%AE%9A%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E6%9C%80%E8%BF%91%E7%9A%84%E8%8A%82%E7%82%B9/","content":"题意给定有向图，每个点至多含一条出边，对于给定两点node1与node2，求这两点均能到达且距两点距离较大值最小的点。\n思路求两点均可达且较大距离最小，可以考虑先求出两点到所有其他点所需距离，再遍历所有点判断即可；\n求两点到其他点距离可以考虑bfs，但注意到该题每个点至多一条出边，那简单循环一下即可。\n实现class Solution {public:    int closestMeetingNode(vector&lt;int&gt;&amp; edges, int node1, int node2) {        const int n = edges.size();        vector&lt;int&gt; dis1(n, n), dis2(n, n);        for (int cur = 0; node1 != -1 &amp;&amp; dis1[node1] == n; node1 = edges[node1]) {            dis1[node1] = cur++;        }        for (int cur = 0; node2 != -1 &amp;&amp; dis2[node2] == n; node2 = edges[node2]) {            dis2[node2] = cur++;        }        int mn = n, ans = -1;        for (int i = 0; i &lt; n; i++) {            if (max(dis1[i], dis2[i]) &lt; mn) {                mn = max(dis1[i], dis2[i]);                ans = i;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3373-连接两棵树后最大目标节点数目 II","url":"/2025/05/29/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983373-%E8%BF%9E%E6%8E%A5%E4%B8%A4%E6%A3%B5%E6%A0%91%E5%90%8E%E6%9C%80%E5%A4%A7%E7%9B%AE%E6%A0%87%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE-II/","content":"题意给定两棵大小分别为n和m的树\n若两点间距离为偶数则称两点互为目标结点。\n求数组answer，其中answer[i]表示将第一二棵树的任意结点相连，第一棵树的结点i的最大目标结点数。\n思路那好像，和昨天的也没什么太大区别啊，不知道为什么昨天给标中等今天标困难了。\n同样的，对第一棵树的每个节点 第一棵树内的目标结点数是固定的，这个可以简单的用类似换根的思路求出来：若结点u目标结点即距离为偶数的点数目为x个，距u距离为奇数的点数应为n - x个，因所有点离它的距离非奇即偶；若v与u直接相邻，所有点离v的距离相对离u的距离一定是加减一的，故离v奇距离的点数为x个，偶距离的为n - x个。\n再考虑连接第二棵树造成的影响，同理，以任意点为根求出距其奇偶距离的点数，显然与其直接相连目标结点可增加距其奇距离数，与其相邻结点相连可增加其偶距离数。\n实现class Solution {public:    vector&lt;int&gt; maxTargetNodes(vector&lt;vector&lt;int&gt;&gt;&amp; edges1, vector&lt;vector&lt;int&gt;&gt;&amp; edges2) {        const int n = edges1.size() + 1, m = edges2.size() + 1;        vector&lt;vector&lt;int&gt;&gt; adj1(n), adj2(m);        for (const auto&amp; e : edges1) {            adj1[e.front()].push_back(e.back());            adj1[e.back()].push_back(e.front());        }        for (const auto&amp; e : edges2) {            adj2[e.front()].push_back(e.back());            adj2[e.back()].push_back(e.front());        }        int cnt = 0;        auto dfs1 = [&amp;](this auto&amp;&amp; self, int u, int fa, int tag) -&gt; void {            if (tag) cnt++;            for (auto v : adj2[u]) {                if (v == fa) continue;                self(v, u, tag ^ 1);            }        };        dfs1(0, -1, 1);        cnt = max(cnt, m - cnt);        vector&lt;int&gt; ans(n);        auto dfs = [&amp;](this auto&amp;&amp; self, int u, int fa, int tag) -&gt; void {            if (tag) ans[0]++;            for (auto v : adj1[u]) {                if (v == fa) continue;                self(v, u, tag ^ 1);            }        };        auto dfs2 = [&amp;](this auto&amp;&amp; self, int u, int fa) -&gt; void {            for (auto v : adj1[u]) {                if (v == fa) continue;                ans[v] = n - ans[u];                self(v, u);            }            ans[u] += cnt;        };        dfs(0, -1, 1);        dfs2(0, -1);        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3372-连接两棵树后最大目标节点数目 I","url":"/2025/05/28/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983372-%E8%BF%9E%E6%8E%A5%E4%B8%A4%E6%A3%B5%E6%A0%91%E5%90%8E%E6%9C%80%E5%A4%A7%E7%9B%AE%E6%A0%87%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE-I/","content":"题意给定两棵大小分别为n和m的树，以及正整数k\n若两点间距离不超过k则称两点互为目标结点。\n求数组answer，其中answer[i]表示将第一二棵树的任意结点相连，第一棵树的结点i的最大目标结点数。\n思路对于给定的某点应该如何连接两棵树使得其目标结点数最大呢\n显然第一棵树应选择该点；而第二棵树所选择的点与第一棵树选取的点无关，应都选择含距离不超过k - 1点最多的点。\n使用bfs求对应距离的点数即可。\n实现class Solution {public:    vector&lt;int&gt; maxTargetNodes(vector&lt;vector&lt;int&gt;&gt;&amp; edges1, vector&lt;vector&lt;int&gt;&gt;&amp; edges2, int k) {        const int n = edges1.size() + 1, m = edges2.size() + 1;        vector&lt;vector&lt;int&gt;&gt; adj1(n), adj2(m);        for (const auto&amp; vec : edges1) {            adj1[vec.front()].push_back(vec.back());            adj1[vec.back()].push_back(vec.front());        }        for (const auto&amp; vec : edges2) {            adj2[vec.front()].push_back(vec.back());            adj2[vec.back()].push_back(vec.front());        }        if (k == 0) return vector&lt;int&gt; (n, 1);        int mx = 0;        for (int i = 0; i &lt; m; i++) {            int t = 0;            vector&lt;array&lt;int, 3&gt;&gt; q {{i, -1, 0}}; int cur = 0;            for ( ; cur &lt; q.size(); cur++) {                auto [u, fa, d] = q[cur];                if (d &gt;= k) break;                t++;                for (auto v : adj2[u]) {                    if (v == fa) continue;                    q.push_back({v, u, d + 1});                }            }            mx = max(mx, t);        }        vector&lt;int&gt; ans(n, mx);        for (int i = 0; i &lt; n; i++) {            int t = 0;            vector&lt;array&lt;int, 3&gt;&gt; q {{i, -1, 0}}; int cur = 0;            for ( ; cur &lt; q.size(); cur++) {                auto [u, fa, d] = q[cur];                if (d &gt; k) break;                t++;                for (auto v : adj1[u]) {                    if (v == fa) continue;                    q.push_back({v, u, d + 1});                }            }            ans[i] += t;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2894-分类求和并作差","url":"/2025/05/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982894-%E5%88%86%E7%B1%BB%E6%B1%82%E5%92%8C%E5%B9%B6%E4%BD%9C%E5%B7%AE/","content":"题意给定整数n与m\n记num1为[1, n]无法被m整除的数的和\n记num2为[1, n]被m整除的数的和\n求num1 - num2\n思路可以发现本题的数据范围很小可以直接继续暴力求解。\n但同时也可以直接进行数学推导：\n注意到[1, n]的数不是被m整除就是无法被m整除\n也就是\n同时,被m整除的数均形如\n故而\n不难得出结果\n\n实现class Solution {public:    int differenceOfSums(int n, int m) {        int ans = (1 + n) * n &gt;&gt; 1;        int t = n / m;        ans -= (1 + t) * t * m;        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1857-有向图中最大颜色值","url":"/2025/05/26/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981857-%E6%9C%89%E5%90%91%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E9%A2%9C%E8%89%B2%E5%80%BC/","content":"题意给定一个有向图，以及图上各节点的颜色colors，若图有环返回-1；\n记路径颜色值为路径中出现次数最多的颜色的出现次数。\n求各合法路径的最大颜色值。\n思路首先假定图无环，该怎么求路径最大颜色值呢；\n若有一条路径可得最大颜色值，且存在一个不在该路径上的点可达该路径起点，显然将路径起点改为该点一定不劣。也就是说从各入度为0的点出发一定不劣，比较自然的可以想到使用拓扑排序。\n拓扑排序同时也可以解决判断有无环问题，由此可解。\n实现class Solution {static constexpr int N = 26;public:    int largestPathValue(string colors, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {        const int n = colors.size();        vector&lt;int&gt; d(n);        vector&lt;vector&lt;int&gt;&gt; e(n);        for (const auto&amp; vec : edges) {            e[vec.front()].push_back(vec.back());            d[vec.back()]++;        }        vector&lt;int&gt; q; int cur = 0;        for (int i = 0; i &lt; n; i++) {            if (d[i] == 0) q.push_back(i);        }        vector&lt;array&lt;int, N&gt;&gt; f(n);        int ans = 0;        for ( ; cur &lt; q.size(); cur++) {            int x = q[cur];            f[x][colors[x] - 'a']++;            ans = max(ans, f[x][colors[x] - 'a']);            for (const auto&amp; v : e[x]) {                for (int i = 0; i &lt; N; i++) {                    f[v][i] = max(f[v][i], f[x][i]);                }                d[v]--;                if (d[v] == 0) {                    q.push_back(v);                }            }        }        if (count(d.begin(), d.end(), 0) != n) return -1;        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2131-连接两字母单词得到的最长回文串","url":"/2025/05/25/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982131-%E8%BF%9E%E6%8E%A5%E4%B8%A4%E5%AD%97%E6%AF%8D%E5%8D%95%E8%AF%8D%E5%BE%97%E5%88%B0%E7%9A%84%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/","content":"题意给定由长度为2的字符串组成的字符串数组words，可任选并按任意顺序连接其中字符串，求所能组成最长回文串长度。\n思路给定一个回文串，显然往两边同时添加相反字符串是不会破坏回文性质的。\n所有可选字符串长度均为2，那首先考虑回文对称轴在不同字符串之间，显然是贪心的将相反的字符串不断添加到已有回文串左右；\n再考虑如果存在可选回文串即s[0] == s[1]，显然可以将其加入回文串的中间，使回文串对称轴位于该字符串中间。\n进行一个贪心模拟就好。\n实现class Solution {static constexpr int N = 26;public:    int longestPalindrome(vector&lt;string&gt;&amp; words) {        vector f(N, vector&lt;int&gt; (N));        int ans = 0;        for (const auto&amp; s : words) {            f[s.front() - 'a'][s.back() - 'a']++;        }        int t = 0;        for (int i = 0; i &lt; N; i++) {            for (int j = 0; j &lt; N; j++) {                if (i == j) {                    ans += (f[i][j] - (f[i][j] &amp; 1)) &lt;&lt; 1;                    if (f[i][j] &amp; 1) t = 2;                } else {                    ans += min(f[i][j], f[j][i]) &lt;&lt; 1;                }            }        }        return ans + t;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2942-查找包含给定字符的单词","url":"/2025/05/24/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982942-%E6%9F%A5%E6%89%BE%E5%8C%85%E5%90%AB%E7%BB%99%E5%AE%9A%E5%AD%97%E7%AC%A6%E7%9A%84%E5%8D%95%E8%AF%8D/","content":"题意给定字符串数组words与字符x，寻找所有含x的字符串下标\n思路进行一个暴力即可。\n实现class Solution {public:    vector&lt;int&gt; findWordsContaining(vector&lt;string&gt;&amp; words, char x) {        vector&lt;int&gt; ans;        for (int i = 0; i &lt; words.size(); i++) {            if (words[i].find(x) != string::npos) ans.push_back(i);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3068-最大节点价值之和","url":"/2025/05/23/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983068-%E6%9C%80%E5%A4%A7%E8%8A%82%E7%82%B9%E4%BB%B7%E5%80%BC%E4%B9%8B%E5%92%8C/","content":"题意给定一棵树及其结点权值nums与正整数k，每次操作可以任选一条边使其两端点权值异或k，可以进行任意次操作，求问最大权值和。\n思路比较自然是可以想到树形dp的，但是仔细一想异或的性质可以发现存在更加简单的写法：\n只要两点间存在路径，一定存在操作使得仅两点权值异或k而其余值不受影响，故而可以简单地为结点权值异或前后大小差排序进行贪心。\n实现class Solution {using ll = long long;public:    long long maximumValueSum(vector&lt;int&gt;&amp; nums, int k, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {        const int n = nums.size();        ll ans = 0;        for (int i = 0; i &lt; n; i++) {            ans += nums[i];            nums[i] = (nums[i] ^ k) - nums[i];        }        ranges::sort(nums, greater());        for (int i = 1; i &lt; n; i += 2) {            if (nums[i] + nums[i - 1] &gt; 0) {                ans += nums[i] + nums[i - 1];            } else {                break;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3362-零数组变换 III","url":"/2025/05/22/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983362-%E9%9B%B6%E6%95%B0%E7%BB%84%E5%8F%98%E6%8D%A2-III/","content":"题意给定非负整数数组nums与二维操作数组queries，对于每次操作给出范围[l, r]，每次操作可任选构成下标子集，使得选中的nums[i]减1，求问最多可删除多少操作仍能将nums转换为零数组。\n思路删除操作好像不太好处理，那么可以考虑正难则反：最少选择多少操作可使得nums转换为零数组呢\n显然是可以满足贪心性质的，对于每个仍大于零的数，我们希望选择左端在其左而右端尽可能右的操作，那么可以使用优先队列维护满足条件的右端点，使用差分维护当前数值。\n实现class Solution {public:    int maxRemoval(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {        ranges::sort(queries, [&amp;](const auto&amp; x, const auto&amp; y) {            return x.front() &lt; y.front();        });        const int n = nums.size(), q = queries.size();        vector&lt;int&gt; f(n + 1);        priority_queue&lt;int&gt; pq;        int cnt = 0, cur = 0;        for (int i = 0; i &lt; n; i++) {            if (i) f[i] += f[i - 1];            while (cur &lt; q &amp;&amp; queries[cur].front() &lt;= i) {                pq.push(queries[cur++].back());            }            while (f[i] &lt; nums[i] &amp;&amp; !pq.empty()) {                int r = pq.top();                pq.pop();                if (r &lt; i) continue;                f[i]++;                f[r + 1]--;                cnt++;            }            if (f[i] &lt; nums[i]) return -1;        }        return q - cnt;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3356-零数组变换 II","url":"/2025/05/21/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983356-%E9%9B%B6%E6%95%B0%E7%BB%84%E5%8F%98%E6%8D%A2-II/","content":"题意给定非负整数数组nums与二维操作数组queries，对于每次操作给出范围[l, r, val]，每次操作可将[l, r]内的每个数独立地减[0, val]，求问若顺序地执行操作queries最少多少次操作可以使得nums变为零数组或判断不可能。\n思路二分可以发现当操作次数越多时越有可能将nums转变为零数组，那么求最小次数显然可以进行一个二分。直接使用昨日代码进行 check 即可。\n线段树若想在线的做这道题，显然需要的操作是不断进行区间减与区间最大值查询，那就自然地想到使用带懒标记的线段树。\n实现二分实现\nclass Solution {public:    int minZeroArray(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {        const int n = nums.size(), q = queries.size();        vector&lt;int&gt; f(n + 1);        auto check = [&amp;](int x) -&gt; bool {            fill(f.begin(), f.end(), 0);            for (int i = 0; i &lt; x; i++) {                f[queries[i][0]] += queries[i].back();                f[queries[i][1] + 1] -= queries[i].back();            }            for (int i = 0; i &lt; n; i++) {                if (i) f[i] += f[i - 1];                if (f[i] &lt; nums[i]) return false;            }            return true;        };        int lo = 0, hi = q + 1;        while (lo &lt; hi) {            int mid = lo + hi &gt;&gt; 1;            if (check(mid)) {                hi = mid;            } else {                lo = mid + 1;            }        }        return lo &gt; q ? -1 : lo;    }};\n\n线段树实现\ntemplate&lt;class Info, class Tag&gt;struct SegmentTree {    int n;    vector&lt;Info&gt; info;    vector&lt;Tag&gt; tag;    SegmentTree() : n(0) {}    SegmentTree(int n_, Info v_ = Info()) {        init(n_, v_);    }    template&lt;class T&gt;    SegmentTree(vector&lt;T&gt; init_) {        init(init_);    }    void init(int n_, Info v_ = Info()) {        init(vector&lt;Info&gt;(n_, v_));    }    template&lt;class T&gt;    void init(vector&lt;T&gt; init_) {        n = init_.size();        info.assign(4 &lt;&lt; __lg(n), Info());        tag.assign(4 &lt;&lt; __lg(n), Tag());        auto build = [&amp;](this auto&amp;&amp; self, int p, int l, int r) -&gt; void {            if (r - l == 1) {                info[p] = init_[l];                return;            }            int m = (l + r) / 2;            self(2 * p, l, m);            self(2 * p + 1, m, r);            pull(p);        };        build(1, 0, n);    }    void pull(int p) {        info[p] = info[2 * p] + info[2 * p + 1];    }    void apply(int p, const Tag &amp;v) {        info[p].apply(v);        tag[p].apply(v);    }    void push(int p) {        apply(2 * p, tag[p]);        apply(2 * p + 1, tag[p]);        tag[p] = Tag();    }    void set(int p, int l, int r, int x, const Info &amp;v) {        if (r - l == 1) {            info[p] = v;            return;        }        int m = (l + r) / 2;        push(p);        if (x &lt; m) {            set(2 * p, l, m, x, v);        } else {            set(2 * p + 1, m, r, x, v);        }        pull(p);    }    void set(int p, const Info &amp;v) {        set(1, 0, n, p, v);    }    Info query(int p, int l, int r, int x, int y) {        if (l &gt;= y || r &lt;= x) {            return Info();        }        if (l &gt;= x &amp;&amp; r &lt;= y) {            return info[p];        }        int m = (l + r) / 2;        push(p);        return query(2 * p, l, m, x, y) + query(2 * p + 1, m, r, x, y);    }    Info query(int l, int r) {        return query(1, 0, n, l, r);    }    void update(int p, int l, int r, int x, int y, const Tag &amp;v) {        if (l &gt;= y || r &lt;= x) {            return;        }        if (l &gt;= x &amp;&amp; r &lt;= y) {            apply(p, v);            return;        }        int m = (l + r) / 2;        push(p);        update(2 * p, l, m, x, y, v);        update(2 * p + 1, m, r, x, y, v);        pull(p);    }    void update(int l, int r, const Tag &amp;v) {        return update(1, 0, n, l, r, v);        }};struct Tag {    int add = 0;    void apply(Tag t) {        add += t.add;    }};struct Info {    int mi = 0;    void apply(Tag t) {        mi -= t.add;    }};Info operator+(const Info &amp;a, const Info &amp;b) {    if (a.mi &gt;= b.mi) {        return a;    } else {        return b;    }}using S = SegmentTree&lt;Info, Tag&gt;;class Solution {public:    int minZeroArray(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {        const int n = nums.size(), q = queries.size();        S StT(n);        for (int i = 0; i &lt; n; i++) {            StT.set(i, {nums[i]});        }        if (StT.query(0, n).mi &lt;= 0) return 0;        for (int i = 0; i &lt; q; i++) {            const auto&amp; vec = queries[i];            StT.update(vec[0], vec[1] + 1, {vec[2]});            if (StT.query(0, n).mi &lt;= 0) return i + 1;        }        return -1;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3355-零数组变换 I","url":"/2025/05/20/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983355-%E9%9B%B6%E6%95%B0%E7%BB%84%E5%8F%98%E6%8D%A2-I/","content":"题意给定非负整数数组nums与二维操作数组queries，对于每次操作给出范围[l, r]，每次操作可任选构成下标子集，使得选中的nums[i]减1，求问是否可使得nums转换为零数组。\n思路首先我们可以想到对于每个操作都贪心地对范围所有元素进行减一操作，若元素可减至小于等于0显然是可行的，只需减至0后不再选取其即可。\n那么什么情况是不合法的呢，显然是操作覆盖次数小于nums[i]的。\n对于区间加减，覆盖次数大小，可以自然的想到使用差分。\n实现class Solution {public:    bool isZeroArray(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {        const int n = nums.size();        vector&lt;int&gt; f(n + 1);        for (const auto&amp; vec : queries) {            f[vec.front()]++;            f[vec.back() + 1]--;        }        for (int i = 0; i &lt; n; i++) {            if (i) f[i] += f[i - 1];            if (f[i] &lt; nums[i]) return false;        }        return true;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3024-三角形类型","url":"/2025/05/19/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983024-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%B1%BB%E5%9E%8B/","content":"题意给定三条边长度，判断其是否可构成三角形可构造成什么三角形。\n思路简单的数学判断，if-else一下就好。\n实现class Solution {public:    string triangleType(vector&lt;int&gt;&amp; nums) {        ranges::sort(nums);        if (nums[0] + nums[1] &lt;= nums.back()) return \"none\";        if (nums.front() == nums.back()) return \"equilateral\";        if (nums.front() == nums[1] || nums[1] == nums.back()) return \"isosceles\";        return \"scalene\";    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1931-用三种不同颜色为网格涂色","url":"/2025/05/18/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981931-%E7%94%A8%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E9%A2%9C%E8%89%B2%E4%B8%BA%E7%BD%91%E6%A0%BC%E6%B6%82%E8%89%B2/","content":"题意给定m  *  n的网格，使用三种不同的颜色进行涂色，要求无相邻的网格颜色相同，求合法涂色的方案数。\n思路注意到m的范围是比较小的而，可以考虑一次填一列的色，那么每次填色的方案数显然是的。\n可以通过预处理得到所有合法同时填一列颜色的方案，并得出哪些方案是不可以相邻的，问题就转换为了经典的一维填色方案数，使用dp即可。\n实现class Solution {static constexpr int mod = 1e9 + 7;using ll = long long;public:    int colorTheGrid(int m, int n) {        int pm = 1;        for (int i = 0; i &lt; m; i++) pm *= 3;        vector&lt;int&gt; a;        for (int i = 0; i &lt; pm; i++) {            bool ok = true;            for (int j = 0, last = -1, x = i; j &lt; m; j++) {                if (last == x % 3) {                    ok = false;                    break;                }                last = x % 3;                x /= 3;            }            if (ok) a.push_back(i);        }        const int an = a.size();        vector&lt;vector&lt;int&gt;&gt; adj(an);        for (int i = 0; i &lt; an; i++) {            for (int j = i + 1; j &lt; an; j++) {                bool ok = true;                for (int k = 0, x = a[i], y = a[j]; k &lt; m; k++) {                    if (x % 3 == y % 3) {                        ok = false;                        break;                    }                    x /= 3; y /= 3;                }                if (ok) {                    adj[i].push_back(j);                    adj[j].push_back(i);                }            }        }        vector f(an, vector&lt;int&gt; (n));        for (int i = 0; i &lt; an; i++) f[i][0]++;        for (int i = 1; i &lt; n; i++) {            for (int j = 0; j &lt; an; j++) {                for (const auto&amp; v : adj[j]) {                    f[j][i] += f[v][i - 1];                    if (f[j][i] &gt;= mod) f[j][i] -= mod;                }            }        }        ll ans = 0;        for (int i = 0; i &lt; an; i++) ans += f[i].back();        return ans % mod;    }};\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题75-颜色分类","url":"/2025/05/17/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9875-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/","content":"题意给定数组nums表示小球序列，其中红白蓝球分别用0、1、2表示，希望使用原地排序使小球按红白蓝顺序摆放。\n思路原地排序，有且仅有3种不同元素，那么维护中间元素即1区间的左右端点枚举一下即可。\n实现class Solution {public:    void sortColors(vector&lt;int&gt;&amp; nums) {        int p1 = 0, p2 = 0;        for (int i = 0; i &lt; nums.size(); i++) {            if (nums[i] == 1) {                swap(nums[i], nums[p2++]);            } else if (nums[i] == 0) {                swap(nums[i], nums[p1]);                if (p1 &lt; p2) {                    swap(nums[i], nums[p2]);                }                p1++;                p2++;            }        }    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2901-最长相邻不相等子序列 II","url":"/2025/05/16/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982901-%E6%9C%80%E9%95%BF%E7%9B%B8%E9%82%BB%E4%B8%8D%E7%9B%B8%E7%AD%89%E5%AD%90%E5%BA%8F%E5%88%97-II/","content":"题意给定等长的字符串数组words与整数数组groups；\n求任意最长递增序列I满足以下条件：\n\ngroups[I[i]] != groups[I[i + 1]]\nwords[I[i]]与words[I[i + 1]]的汉明距离为1\n\n返回word[I]\n思路数组的长度范围并不大，最大仅有\n因此其实怎么写基本都是可以的，进行一个的dp即可\n实现class Solution {public:    vector&lt;string&gt; getWordsInLongestSubsequence(vector&lt;string&gt;&amp; words, vector&lt;int&gt;&amp; groups) {        auto check = [](const string&amp; x, const string&amp; y) -&gt; bool {            if (x.size() != y.size()) return false;            int dif = 0;            for (int i = 0; i &lt; x.size(); i++) {                if (x[i] != y[i]) dif++;            }            return dif == 1;        };        const int n = words.size();        vector&lt;int&gt; len(n, 1), from(n, -1);        int mxloc = 0;        for (int i = n - 1; i &gt;= 0; i--) {            for (int j = i + 1; j &lt; n; j++) {                if (len[i] &lt;= len[j] &amp;&amp; groups[i] != groups[j] &amp;&amp; check(words[i], words[j])) {                    len[i] = len[j] + 1;                    from[i] = j;                }            }            if (len[i] &gt; len[mxloc]) mxloc = i;        }        vector&lt;string&gt; ans;        for (int i = mxloc; i != -1; i = from[i]) {            ans.push_back(words[i]);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2900最长相邻不相等子序列 I","url":"/2025/05/15/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982900%E6%9C%80%E9%95%BF%E7%9B%B8%E9%82%BB%E4%B8%8D%E7%9B%B8%E7%AD%89%E5%AD%90%E5%BA%8F%E5%88%97-I/","content":"题意给定等长的字符串数组words与二进制数组groups；\n求任意最长递增序列I满足groups[I[i]] != groups[I[i + 1]]返回word[I]\n思路显然满足贪心性质，进行一趟遍历即可。\n实现class Solution {public:    vector&lt;string&gt; getLongestSubsequence(vector&lt;string&gt;&amp; words, vector&lt;int&gt;&amp; groups) {        vector&lt;string&gt; ans;        const int n = groups.size();        for (int i = 0, cur = -1; i &lt; n; i++) {            if (cur != groups[i]) {                cur = groups[i];                ans.push_back(words[i]);            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3337-字符串转换后的长度 II","url":"/2025/05/14/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983337-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E9%95%BF%E5%BA%A6-II/","content":"题意给定小写字符串s与变换次数t以及长度为26的变换规则nums\n每次比那换为将s[i]变换为字母表中后续的nums[s[i] - 'a']各连续字符，如若有nums[0] = 2; nums[25] = 3则有：\na -&gt; bc\nz -&gt; abc\n求t次变换后s 的长度\n思路注意到此题为昨日题目的升级版，区别在于变换规则不定且t最大可为1e9\n我们且先不考虑完整的26个字母，考虑下仅有abc三个字符互相变换的情况，记与分别为某次变换前后a的的数量\n我们设变换规则为\na -&gt; bcb -&gt; ac -&gt; ac\n\n那么显然有\n\n\n​\n不难将其转换为矩阵乘法的形式：那么聪明的你显然不难发现，t次变换不过如下：那么显然可以使用快速幂的知识将这个运算进行优化。\n同时也不难将这个计算方法推广到26个字母与给定的任意变换规则。\n实现class Solution {static constexpr int mod = 1e9 + 7;static constexpr int sz = 26;using ll = long long;using Matrix = array&lt;array&lt;int, sz&gt;, sz&gt;;Matrix mul(const Matrix&amp; x, const Matrix&amp; y) {    Matrix res;    for (auto&amp; arr : res) arr.fill(0);    for (int i = 0; i &lt; sz; i++) {        for (int j = 0; j &lt; sz; j++) {            if (x[i][j] == 0) continue;            for (int k = 0; k &lt; sz; k++) {                res[i][k] = (res[i][k] + 1ll * x[i][j] * y[j][k]) % mod;            }        }    }    return res;}Matrix powMod(Matrix a, int b) {    Matrix res;    for (int i = 0; i &lt; sz; i++) {        res[i].fill(0);        res[i][i] = 1;    }    while (b) {        if (b &amp; 1) {            res = mul(res, a);        }        a = mul(a, a);        b &gt;&gt;= 1;    }    return res;}public:    int lengthAfterTransformations(string s, int t, vector&lt;int&gt;&amp; nums) {        Matrix m;        for (auto&amp; arr : m) arr.fill(0);        for (int i = 0; i &lt; sz; i++) {            for (int j = 1; j &lt;= nums[i]; j++) {                m[(i + j) % sz][i]++;            }        }        Matrix mt = powMod(m, t);        array&lt;int, sz&gt; cnt;        cnt.fill(0);        for (const auto&amp; ch : s) cnt[ch - 'a']++;        int ans = 0;        for (int i = 0; i &lt; sz; i++) {            ll res = 0;            for (int j = 0; j &lt; sz; j++) {                res += 1ll * mt[i][j] * cnt[j];            }            ans = (ans + res) % mod;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","矩阵快速幂"]},{"title":"力扣每日一题3335-字符串转换后的长度 I","url":"/2025/05/13/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983335-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E9%95%BF%E5%BA%A6-I/","content":"题意给定小写字符串s与变换次数t，每次变换会使s中各字符发生如下变化:\na -&gt; b\nb -&gt; c\n…\n唯有z特殊\nz -&gt; ab\n求解t次变换之后字符串s的最终长度。\n思路我们仅关心字符串的最终长度而不关心其最终形态，且相同字符的变换是相同的，故可以简单的开个数组对各个字符的数量进行模拟计算。\n同时本题是数据削弱版  故而可以直接模拟即可。\n若数据范围较大，可以将操作转换为矩阵乘法，采用矩阵快速幂即可。\n实现class Solution {static constexpr int mod = 1e9 + 7;public:    int lengthAfterTransformations(string s, int t) {        array&lt;int, 26&gt; f;        f.fill(0);        for (const auto&amp; ch : s) {            f[ch - 'a']++;        }        for (int i = 0; i &lt; t; i++) {            int x = f.back();            for (int i = 25; i &gt; 0; i--) {                f[i] = f[i - 1];            }            f[0] = x;            f[1] = f[1] + x;            if (f[1] &gt;= mod) f[1] -= mod;        }        return accumulate(f.begin(), f.end(), 0ll) % mod;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2094-找出 3 位偶数","url":"/2025/05/12/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982094-%E6%89%BE%E5%87%BA-3-%E4%BD%8D%E5%81%B6%E6%95%B0/","content":"题意给定个位数数组digits，可从中任选3个数，按任意顺序排序并组成一个三位数，求所有满足以下条件的不同整数\n\n无前导零\n为偶数\n\n思路三位偶数的个数并不多，可以考虑枚举三位偶数，再判断给出的digits是否可以拼出该数即可。\n实现class Solution {public:    vector&lt;int&gt; findEvenNumbers(vector&lt;int&gt;&amp; digits) {        array&lt;int, 10&gt; cnt;        cnt.fill(0);        for (const auto&amp; x : digits) {            cnt[x]++;        }        auto check = [&amp;](int x) -&gt; bool {            array&lt;int, 3&gt; t;            bool res = true;            for (int i = 0; i &lt; 3; i++) {                t[i] = x % 10;                x /= 10;                res &amp;= (--cnt[t[i]] &gt;= 0);            }            for (int i = 0; i &lt; 3; i++) cnt[t[i]]++;            return res;        };        vector&lt;int&gt; ans;        for (int i = 100; i &lt; 1000; i += 2) {            if (check(i)) ans.push_back(i);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1550-存在连续三个奇数的数组","url":"/2025/05/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981550-%E5%AD%98%E5%9C%A8%E8%BF%9E%E7%BB%AD%E4%B8%89%E4%B8%AA%E5%A5%87%E6%95%B0%E7%9A%84%E6%95%B0%E7%BB%84/","content":"题意给定数组arr，判断其内是否包含连续三个奇数。\n思路比较简单，遍历一遍判断一下就好。\n实现class Solution {public:    bool threeConsecutiveOdds(vector&lt;int&gt;&amp; arr) {        const int n = arr.size();        for (int i = 1; i &lt; n - 1; i++) {            if (!(arr[i] &amp; 1)) continue;            if (arr[i - 1] &amp; arr[i + 1] &amp; 1) return true;        }        return false;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2918-数组的最小相等和","url":"/2025/05/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982918-%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E7%9B%B8%E7%AD%89%E5%92%8C/","content":"题意给定两由非负整数组成的数组nums1与nums2\n必须将两数组中的所有0替换为正整数，且使得两数组之和相同。\n求最小相等和，或表明其无法实现。\n思路可以发现当两个数组均有0时是一定可以实现的，最小和应贪心地使所有0替换为1取较大数组和；\n若均无0则简单比较两数组和即可；\n若仅有某一数组含0，且0均转换为最小正整数1后含0数组和仍大于另一数组则无解。\n实现class Solution {using ll = long long;public:    long long minSum(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        ll sum1 = 0, sum2 = 0;        int cnt1 = 0, cnt2 = 0;        for (const auto&amp; x : nums1) {            sum1 += x;            if (x == 0) cnt1++;        }        for (const auto&amp; x : nums2) {            sum2 += x;            if (x == 0) cnt2++;        }        if ((cnt1 == 0 &amp;&amp; sum2 + cnt2 &gt; sum1) || (cnt2 == 0 &amp;&amp; sum1 + cnt1 &gt; sum2)) return -1;        return max(sum1 + cnt1, sum2 + cnt2);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3343-统计平衡排列的数目","url":"/2025/05/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983343-%E7%BB%9F%E8%AE%A1%E5%B9%B3%E8%A1%A1%E6%8E%92%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意若一个数字字符串奇数位和与偶数位和相同，则称其平衡。\n给定一数字字符串num，求其有多少种排列平衡。\n答案mod 1e9 + 7， 2 &lt;= num.size() &lt;= 80\n思路记有n个数，和为sum，数位为i的个数有\n显然奇数位与偶数位分别有与个\n要使得奇数位和与偶数位和相等即将n个数分为大小为与的两个和为的集合，再对集合进行排序\n记数位为i的数有个放进了第一个集合，则另一个集合有个数位为i的数放进来第二个集合\n假定每个数均不同则共有种排列方式\n再考虑去掉数位相同造成的重复排列有\n那么有几种划分集合的方法呢，比较自然可以想到dp(以前感觉这种话就是懒得详写，轮到自己写了发现真的是\n记为待划分的数为i，第一个集合还缺j个数，第一个集合的和还差k有\n\n显然有递推式\n其中t表示数i有t个填到集合一，剩余填到集合二\n\n接着进行一个dp计数即可。\n实现using ll = long long;constexpr int mod = 1e9 + 7;constexpr int mx = 40;ll powMod(ll a, ll b) {    ll res = 1;    while (b) {        if (b &amp; 1) {            res = res * a % mod;        }        a = a * a % mod;        b &gt;&gt;= 1;    }    return res;}ll fac[mx + 1], nfac[mx + 1];auto init = []() -&gt; int {    fac[0] = 1;    for (int i = 1; i &lt;= mx; i++) {        fac[i] = fac[i - 1] * i % mod;    }    nfac[mx] = powMod(fac[mx], mod - 2);    for (int i = mx - 1; i &gt;= 0; i--) {        nfac[i] = nfac[i + 1] * (i + 1) % mod;    }    return 0;} ();class Solution {public:    int countBalancedPermutations(string num) {        array&lt;int, 10&gt; cnt;        cnt.fill(0);        int sum = 0;        for (const auto&amp; ch : num) {            cnt[ch - '0']++;            sum += ch - '0';        }        if (sum &amp; 1) return 0;        const int n = num.size();        const int t = n / 2, tot = sum / 2;        vector dp(t + 1, vector&lt;ll&gt; (tot + 1));        dp[t][tot] = 1;        for (int i = 0; i &lt; 10; i++) {            vector ndp(t + 1, vector&lt;ll&gt; (tot + 1));            for (int j = 0; j &lt;= t; j++) {                for (int k = 0; k &lt;= tot; k++) {                    int tmx = min({j, cnt[i], i &gt; 0 ? (k / i) : cnt[i]});                    for (int x = 0; x &lt;= tmx; x++) {                        if (cnt[i] - x &gt; mx) continue;                        ndp[j - x][k - x * i] += dp[j][k] * nfac[x] % mod * nfac[cnt[i] - x] % mod;                        ndp[j - x][k - x * i] %= mod;                    }                }            }            swap(dp, ndp);        }        return dp[0][0] * fac[t] % mod * fac[n - t] % mod;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","dp"]},{"title":"力扣每日一题3342-到达最后一个房间的最少时间 II","url":"/2025/05/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983342-%E5%88%B0%E8%BE%BE%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%88%BF%E9%97%B4%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4-II/","content":"题意给定n * m的方格，格子(i, j)必须在时刻moveTime[i][j]之后才可往其移动，第奇数次移动耗时1第偶数次移动耗时2，初始处于时刻0与左上角(0, 0)，求解到达右下角(n - 1, m - 1)的最早时刻。\n思路就是昨日题目的变种，移动耗时不再固定为1而是与当前移动次数的奇偶性有关。\n那还是比较经典的最短路问题，比较朴素的思想是额外增加一个变量用以记录当前移动的次数。\n稍加观察可以注意到，初始位于(0, 0)则移动到(i, j)所需步数奇偶性一定是与i + j相同的，即记当前步数为t一定有：\n\n实现class Solution {static constexpr array&lt;int, 2&gt; nxt[] = {    {1, 0}, {-1, 0}, {0, 1}, {0, -1}};public:    int minTimeToReach(vector&lt;vector&lt;int&gt;&gt;&amp; moveTime) {        const int n = moveTime.size(), m = moveTime.back().size();        const int e = n * m - 1;        auto cal1 = [&amp;](int x, int y) -&gt; int {            return x * m + y;        };        auto cal2 = [&amp;](int x) -&gt; pair&lt;int, int&gt; {            return {x / m, x % m};        };        auto across = [&amp;](int x, int y) -&gt; bool {            return x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m;        };        vector&lt;bool&gt; vis(n * m);        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;&gt;&gt; pq;        pq.push({0, 0});        while (!pq.empty()) {            auto [c, t] = pq.top();            pq.pop();            if (vis[t]) continue;            if (t == e) return c;            vis[t] = true;            auto [x, y] = cal2(t);            for (auto [tx, ty] : nxt) {                int nx = tx + x, ny = ty + y;                if (across(nx, ny)) continue;                int nt = cal1(nx, ny);                pq.push({max(c, moveTime[nx][ny]) + 1 + ((x + y) &amp; 1), nt});            }        }        return -1;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3341-到达最后一个房间的最少时间 I","url":"/2025/05/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983341-%E5%88%B0%E8%BE%BE%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%88%BF%E9%97%B4%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4-I/","content":"题意给定n * m的方格，格子(i, j)必须在时刻moveTime[i][j]之后才可往其移动，每次移动耗时1，初始处于时刻0与左上角(0, 0)，求解到达右下角(n - 1, m - 1)的最早时刻。\n思路比较经典的最短路题，只需把当前时刻t与目的方格最小时刻moveTime[i][j]取max加一即max(t, moveTime[i][j]) + 1作为边权然后跑一下迪杰斯特拉即可。\n实现class Solution {using ll = long long;static constexpr array&lt;int, 2&gt; nxt[] = {    {1, 0}, {-1, 0}, {0, 1}, {0, -1}};public:    int minTimeToReach(vector&lt;vector&lt;int&gt;&gt;&amp; moveTime) {        const int n = moveTime.size(), m = moveTime.back().size();        const int e = n * m - 1;        auto cal1 = [&amp;](int x, int y) -&gt; int {            return x * m + y;        };        auto cal2 = [&amp;](int x) -&gt; pair&lt;int, int&gt; {            return {x / m, x % m};        };        auto across = [&amp;](int x, int y) -&gt; bool {            return x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m;        };        vector&lt;bool&gt; vis(n * m);        priority_queue&lt;pair&lt;ll, int&gt;, vector&lt;pair&lt;ll, int&gt;&gt;, greater&lt;&gt;&gt; pq;        pq.push({0, 0});        while (!pq.empty()) {            auto [c, t] = pq.top();            pq.pop();            if (vis[t]) continue;            if (t == e) return c;            vis[t] = true;            auto [x, y] = cal2(t);            for (auto [tx, ty] : nxt) {                int nx = tx + x, ny = ty + y;                if (across(nx, ny)) continue;                int nt = cal1(nx, ny);                pq.push({max(c, 1ll * moveTime[nx][ny]) + 1, nt});            }        }        return -1;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1920-基于排列构建数组","url":"/2025/05/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981920-%E5%9F%BA%E4%BA%8E%E6%8E%92%E5%88%97%E6%9E%84%E5%BB%BA%E6%95%B0%E7%BB%84/","content":"题意给定排列nums，希望返回满足以下条件的ans\nans[i] = nums[nums[i]], 0 &lt;= i &lt; nums.size()\n思路开个ans简单地遍历一遍模拟一下即可，空间复杂度为O(n)，没什么难度\n进阶：是否可以用O(1)的空间复杂度解决问题呢\n如此只能是在nums上原地操作变换，即令nums[i] = nums[nums[i]]\n但显然是不可以直接这么做的，因为直接替换nums[i]可能会影响后续的其他操作结果\n但由于nums为排列即无重复数，可以注意到nums[i]与要替换nums[i]的nums[nums[i]]、nums[nums[i]]与要替换nums[nums[i]]的nums[nums[nums[i]]]…等等是必定会形成一个环的\n即nums变换前后其实是由多个环组成的\n那么仅需考虑同时操作变换同一个环内的数字，并记录标记哪些数操作过即可。\n实现简单实现\nclass Solution {public:    vector&lt;int&gt; buildArray(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        vector&lt;int&gt; ans(n);        for (int i = 0; i &lt; n; i++) {            ans[i] = nums[nums[i]];        }        return ans;    }};\n\n空间O(1)实现\nclass Solution {public:    vector&lt;int&gt; buildArray(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        for (int i = 0; i &lt; n; i++) {            if (nums[i] &lt; 0) continue;            int x = nums[i], cur = i;            while (nums[cur] != i) {                int nxt = nums[cur];                nums[cur] = ~nums[nxt];                cur = nxt;            }            nums[cur] = ~x;        }        for (int i = 0; i &lt; n; i++) {            nums[i] = ~nums[i];        }        return nums;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题790-多米诺和托米诺平铺","url":"/2025/05/05/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98790-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/","content":"题意有两种瓷砖，形如：\n种类1..种类2...\n\n两种瓷砖均可以任意旋转，求一个2 * n的的面板可以有几种不同的铺法。\n思路一个很经典的dp问题，为方便讨论，记以下称呼\n平：..上凸：...下凸：...\n\n记\n第i列为平有几种铺法\n​为第i列为上凸有几种铺法\n为第i列为下凸有几种铺法\n显然有：具体原因可以简单手绘得出，故不过多赘述。\n仅需注意边界、溢出问题即可。\n实现class Solution {static constexpr int mod = 1e9 + 7;public:    int numTilings(int n) {        vector&lt;int&gt; f(n + 1), g(n + 1), h(n + 1);        f[0] = 1;        for (int i = 1; i &lt;= n; i++) {            f[i] = (1ll * f[i - 1] + g[i - 1] + h[i - 1]) % mod;            if (i &gt; 1) {                f[i] = (f[i] + f[i - 2]) % mod;                g[i] = (f[i - 2] + h[i - 1]) % mod;                h[i] = (f[i - 2] + g[i - 1]) % mod;            }        }        return f[n];    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"部分条件下幂次的期望可以转换为元组个数","url":"/2025/05/04/%E9%83%A8%E5%88%86%E6%9D%A1%E4%BB%B6%E4%B8%8B%E5%B9%82%E6%AC%A1%E7%9A%84%E6%9C%9F%E6%9C%9B%E5%8F%AF%E4%BB%A5%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%83%E7%BB%84%E4%B8%AA%E6%95%B0/","content":"结论\n抛n次硬币，记x为正面朝上次数，求x的k次幂的期望\n有m张不同的牌，随机洗牌并取牌顶，重复n次，记x为取到某特定牌的次数，求x的k次幂的期望\n\n形如以上，满足以下条件的问题：\n\n随机变量是指标函数之和\n每个指标函数有明确定义的期望，最好互相独立\n允许多重元组并考虑重复时的概率\n\n可以将问题转换为求k元组的个数。\n思路以有m张不同的牌，随机洗牌并取牌顶，重复n次，记x为取到某特定牌的次数，求x的k次幂的期望为例子：\n记  为指示函数，表示第i次洗牌是否为好，其中  ：\n\n 表示该次洗牌所需特定牌在牌顶\n 表示其他情况\n\n那么可以将x表示为\n\n所求期望转换为  \n将其展开\n\n故而有\n\n每一个    元组   ，我们关心的是这  个编号是否都是好编号，故可以认为：\n\n每个元组贡献的期望值为这组编号全是好编号的概率\n把所有可能的元组的概率加起来，就等于 ​\n\n而k元组个数可以通过dp简单求得\n简单例子有2张牌，抽取3次，求的期望\n设  是每次洗牌是否为“好”的指示变量：  \n展开\n\n转换为元组考虑\n考虑所有  的 2 元组，共  个：\n\n\n\n元组\n\n\n\n\n(1,1)\n\n\n\n(1,2), (2,1)\n\n\n\n(1,3), (3,1)\n\n\n\n(2,2)\n\n\n\n(2,3), (3,2)\n\n\n\n(3,3)\n\n\n\n其他写CF1278F时学到的新东西，觉得好神奇又好像有点典，故而记录\nCF1278F\n","categories":["学习笔记"],"tags":["dp","概率论"]},{"title":"力扣每日一题1128-等价多米诺骨牌对的数量","url":"/2025/05/04/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981128-%E7%AD%89%E4%BB%B7%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F/","content":"题意给一组多米诺骨牌，每张牌上有两个数，可以任意次旋转使某张牌上数顺序交换，求相同牌的对数。\n思路可以任意次改变某牌上数的顺序，即牌上数顺序无关紧要，判断时令较小数在前或在后统一标准即可。\n遍历一趟使用哈希记录各个牌型数量即可。\n实现class Solution {public:    int numEquivDominoPairs(vector&lt;vector&lt;int&gt;&gt;&amp; dominoes) {        array&lt;int, 100&gt; cnt;        cnt.fill(0);        int ans = 0;        for (const auto&amp; vec : dominoes) {            int t = min(vec[0], vec[1]) * 10 + max(vec[0], vec[1]);            ans += cnt[t];            cnt[t]++;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1007-行相等的最少多米诺旋转","url":"/2025/05/03/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981007-%E8%A1%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%9A%E7%B1%B3%E8%AF%BA%E6%97%8B%E8%BD%AC/","content":"题意有一排可分上下部分的多米诺骨牌，每张牌上下部分均分别写着[1, 6]的数字，每次操作可使得某张牌上下颠倒，求使得上部/下部所有数字相同的最小操作次数或判断其不可能。\n思路注意到牌上数字的范围很小，可以考虑直接枚举是哪个数可以满足条件及最小操作次数；但这样常数，呃也不算大但不够优，可以再考虑开个数组记录各个数字出现次数及使其在上部或下部满足同排均相同的操作次数，如此遍历一趟即可。\n没什么特别需要注意的地方。\n实现class Solution {public:    int minDominoRotations(vector&lt;int&gt;&amp; tops, vector&lt;int&gt;&amp; bottoms) {        array&lt;int, 7&gt; num, tcnt, bcnt;        num.fill(0); tcnt.fill(0); bcnt.fill(0);        const int n = tops.size();        for (int i = 0; i &lt; n; i++) {            if (tops[i] == bottoms[i]) {                num[tops[i]]++;            } else {                num[tops[i]]++;                num[bottoms[i]]++;                tcnt[bottoms[i]]++;                bcnt[tops[i]]++;            }        }        int mn = n;        for (int i = 1; i &lt; 7; i++) {            if (num[i] == n) mn = min({mn, tcnt[i], bcnt[i]});        }        return mn == n ? -1 : mn;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题838-推多米诺","url":"/2025/05/02/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98838-%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/","content":"题意给出字符串dominoes表示第0时刻排成一排的多米诺骨牌，其中：\n\ndominoes[i] = 'L'表示初始时该牌向左倒\ndominoes[i] = 'R'表示初始时刻该牌向右倒\ndominoes[i] = '.'表示初始时刻该牌直立\n\n每过一秒倒下的牌会使其倒下方向的下一张牌向同方向倒下（若下一张牌未倒下）；但若一张未倒下的牌同时收到左右两边相反方向的影响，其不会倒下。\n求问给定牌的最终情况。\n思路比较简单的模拟题，第一想法是开个数组time记录其受到左右影响的时刻，哪个小往哪边倒，从左到右再从右到左模拟两趟即可。\n但再观察一下发现，一片连续的未倒牌，其最终状态只受其两侧两个牌的状态影响：\n\nL...L-&gt;LLLLL\nL...R-&gt;L...R\nR...R-&gt;RRRRR\nR...L-&gt;RR.LL\n\n那只需遍历一趟找到连续未倒牌，比较其左右两侧牌的状态即可。\n实现记录比较时间模拟：\nclass Solution {public:    string pushDominoes(string dominoes) {        const int n = dominoes.size();        vector&lt;int&gt; time(n);        for (int i = 0, t = 0; i &lt; n; i++) {            if (dominoes[i] == 'R') {                t = 1;            } else if (dominoes[i] == '.') {                if (t &gt; 0) {                    time[i] = t++;                }            } else {                t = 0;            }        }        for (int i = n - 1, t = 0; i &gt;= 0; i--) {            if (dominoes[i] == 'R') {                t = 0;            } else if (dominoes[i] == 'L') {                t = 1;            } else {                if (t == 0) {                    if (time[i]) dominoes[i] = 'R';                    continue;                }                if (time[i] == 0) {                    dominoes[i] = 'L';                    t++;                } else {                    if (time[i] == t) {                        t = 0;                    } else if (time[i] &gt; t) {                        dominoes[i] = 'L';                        t++;                    } else {                        dominoes[i] = 'R';                        t = 0;                    }                }            }        }        return dominoes;    }};\n\n\n\n比较未倒牌左右：\nclass Solution {public:    string pushDominoes(string dominoes) {        const int n = dominoes.size();        for (int i = 0; i &lt; n; i++) {            if (dominoes[i] != '.') continue;            int j = i + 1;            for ( ; j &lt; n &amp;&amp; dominoes[j] == '.'; j++);            if (i == 0 &amp;&amp; j == n) continue;            else if (i == 0 &amp;&amp; dominoes[j] == 'L') {                for ( ; i &lt; j; i++) dominoes[i] = 'L';            } else if (j == n &amp;&amp; dominoes[i - 1] == 'R') {                for ( ; i &lt; j; i++) dominoes[i] = 'R';            } else if (i != 0 &amp;&amp; j != n) {                if (dominoes[i - 1] == dominoes[j]) {                    for ( ; i &lt; j; i++) dominoes[i] = dominoes[j];                } else if (dominoes[i - 1] == 'R' &amp;&amp; dominoes[j] == 'L') {                    int m1 = i + j + 1 &gt;&gt; 1, m2 = i + j &gt;&gt; 1;                    for ( ; i &lt; m2; i++) dominoes[i] = 'R';                    for (i = m1; i &lt; j; i++) dominoes[i] = 'L';                }            }            i = j;        }        return dominoes;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2071-你可以安排的最多任务数目","url":"/2025/05/01/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982071-%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%AE%89%E6%8E%92%E7%9A%84%E6%9C%80%E5%A4%9A%E4%BB%BB%E5%8A%A1%E6%95%B0%E7%9B%AE/","content":"题意给定n个任务m名工人，第i个任务完成需要力量tasks[i]，第j名工人力量为workers[j]；同时拥有pills个药丸，每个药丸可使一个工人力量提高strengh；每个工人最多可以完成一个任务使用一个药丸，求最多可以完成多少任务。\n思路我们首先考虑在不使用药丸的前提下，若需完成任意x个任务，是否可以完成。\n显然应当选出前x小的任务与前x大的工人，若能一一对应完成即可。\n那应当对workers与tasks进行排序，取出x个任务与工人，贪心地使最小的工人与最小的任务匹配。\n如果加入k个药丸的条件呢？是否可以完成任意x个任务如何判断\n那么一个工人所能完成的任务应该是一个区间[workers[i], workers[i] + strengh]，如果不使用药丸，该工人应该依旧选择与所能完成的最小任务匹配；如果使用药丸，贪心地应该选择能完成的最大任务匹配，使得药丸发挥最大作用，这个是基于直觉的guess，需要证明应该也不难。\n如果可以考虑明白上面的事，那么你已经知道如何check给定的任务数x了！接下来就可以进行一个二分查找得到答案。\n实现class Solution {public:    int maxTaskAssign(vector&lt;int&gt;&amp; tasks, vector&lt;int&gt;&amp; workers, int pills, int strength) {        ranges::sort(tasks);        ranges::sort(workers);        const int n = tasks.size(), m = workers.size();        auto check = [&amp;](int x) -&gt; bool {            int cnt = 0, cur = 0;            deque&lt;int&gt; q;            for (int i = m - x; i &lt; m; i++) {                for ( ; cur &lt; n &amp;&amp; tasks[cur] &lt;= workers[i] + strength; cur++) {                    q.push_back(tasks[cur]);                }                if (q.empty()) return false;                if (q.front() &lt;= workers[i]) {                    q.pop_front();                    continue;                }                if (cnt &gt;= pills) return false;                cnt++;                q.pop_back();            }            return true;        };        int lo = 0, hi = min(n, m);        while (lo &lt; hi) {            int mid = lo + hi + 1 &gt;&gt; 1;            if (check(mid)) {                lo = mid;            } else {                hi = mid - 1;            }        }        return lo;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1295-统计位数为偶数的数字","url":"/2025/04/30/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981295-%E7%BB%9F%E8%AE%A1%E4%BD%8D%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97/","content":"题意给定数组nums，求nums中数位个数为偶数的数的个数。\n思路直接遍历nums求每个数的位数即可。\n实现class Solution {public:    int findNumbers(vector&lt;int&gt;&amp; nums) {        int ans = 0;        for (const auto&amp; x : nums) {            ans += (to_string(x).size() &amp; 1) == 0;        }        return ans;    }};\n\n其他也是顺利拿下2025-04的力扣全勤了，也是结束了写博客的第一个月。\n做下来后感觉其实也没什么特别难的题，琢磨琢磨、看看别人题解琢磨琢磨总是能做出来的；以及感觉这个月好多都是给定数组求满足条件的子区间个数，有点写闷了。\n以前看别人题解，总是嫌别人写得太简单跳步太多，后来轮到自己写，会犯懒不想写得太详细，会有我都会了大家应该也会的想法；这确实是不太好的，但我有点把握不好啰嗦和详细清晰的度，也有点平衡不好花费的时间与详实程度。争取在未来的博客中得到改进吧。\n目前为止，我的博客还是没什么人看的，虽然主要原因是我还没买域名也没配置可以在搜索引擎检索到更没和多少人讲；博客配置也还存在些问题，比如多行Latex公式还是会挤在一起，图片还贴不上，争取下个月折腾完善一下吧。\n然后好像就没什么特别的感想了，五一将至，祝大家节日快乐假期愉快，love。\n文末是当前博客访问人数与四月徽章留作纪念，至于贴图问题，应该可能大概2025-05可以解决吧。（报告，贴图问题已于2025-05-03解决）\n\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2962-统计最大元素出现至少 K 次的子数组","url":"/2025/04/29/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982962-%E7%BB%9F%E8%AE%A1%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E8%87%B3%E5%B0%91-K-%E6%AC%A1%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/","content":"题意给定数组nums与定值k，求nums最大值至少出现k次的子数组个数。\n思路这个月全是这种类似的题啊，完全没有什么讲的想法与必要。\n找满足条件的子区间个数，滑动窗口，枚举右端点找最左不满足的左端点就好。\n实现class Solution {using ll = long long;public:    long long countSubarrays(vector&lt;int&gt;&amp; nums, int k) {        ll ans = 0;        const int n = nums.size();        int mx = ranges::max(nums);        for (int l = 0, r = 0, cur = 0; r &lt; n; r++) {            cur += nums[r] == mx;            while (l &lt;= r &amp;&amp; cur &gt;= k) {                cur -= nums[l++] == mx;            }            ans += l;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2302-统计得分小于 K 的子数组数目","url":"/2025/04/28/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982302-%E7%BB%9F%E8%AE%A1%E5%BE%97%E5%88%86%E5%B0%8F%E4%BA%8E-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums与整数上界k\n求nums内区间和乘区间长度严格小于k的非空子数组个数\n思路又又又是求数组内满足条件的子区间个数\n那写了这么多相似的题，应该很自然的可以想到使用滑动窗口，枚举右端点\n唯一差异是先前的多是区间越长越可能合法，这题是区间越小越可能合法，那就是改 寻第一个不满足的左端点 为 寻第一个满足的左端点，统计方向改变即可。\n仅需维护当前窗口和即可。\n实现class Solution {using ll = long long;public:    long long countSubarrays(vector&lt;int&gt;&amp; nums, long long k) {        ll ans = 0;        ll cur = 0;        for (int l = 0, r = 0; r &lt; nums.size(); r++) {            cur += nums[r];            while (l &lt;= r &amp;&amp; cur * (r - l + 1) &gt;= k) {                cur -= nums[l++];            }            ans += r - l + 1;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3392-统计符合条件长度为 3 的子数组数目","url":"/2025/04/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983392-%E7%BB%9F%E8%AE%A1%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E9%95%BF%E5%BA%A6%E4%B8%BA-3-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums，求长度为3且第一个数与第三个数的和为第二个数的一半的子数组个数。\n思路很明显就是求nums[i] == (nums[i - 1] + nums[i + 1]) * 2的个数，直接暴力即可，稍微注意以下边界就好。\n实现class Solution {public:    int countSubarrays(vector&lt;int&gt;&amp; nums) {        int ans = 0;        const int n = nums.size();        for (int i = 1; i &lt; n - 1; i++) {            if (nums[i] &amp; 1) continue;            ans += nums[i] / 2 == nums[i - 1] + nums[i + 1];        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2444-统计定界子数组的数目","url":"/2025/04/26/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982444-%E7%BB%9F%E8%AE%A1%E5%AE%9A%E7%95%8C%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums与两整数minK与maxK\n若某数组满足以下条件则称其为定界子数组\n\n\n\n\n求nums中定界子数组个数\n思路又是求满足条件的子数组个数，最近的每日一题都是这种题，那写到这应该还是比较熟悉的。比较自然的可以想到使用滑动窗口求解。\n枚举右端点，那么有多少个左端点是可以符合条件的呢？\n首先区间的最大值需要为maxK且最小值需为minK故而左端点一定是在当前右端点左侧离右端点最近的值为minK的左侧与最近的值为maxK的左侧，即两者取min\n同时区间内不能存在[minK, maxK]的值，所以合法左端点最远可以取到当前右端左侧最近的不属于[minK, maxK]的位置。\n实现class Solution {using ll = long long;public:    long long countSubarrays(vector&lt;int&gt;&amp; nums, int minK, int maxK) {        ll ans = 0;        for (int i = 0, mx = -1, mn = -1, no = -1; i &lt; nums.size(); i++) {            if (nums[i] == minK) mn = i;            if (nums[i] == maxK) mx = i;            if (nums[i] &gt; maxK || nums[i] &lt; minK) no = i;            ans += max(min(mx, mn) - no, 0);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2845-统计趣味子数组的数目","url":"/2025/04/25/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982845-%E7%BB%9F%E8%AE%A1%E8%B6%A3%E5%91%B3%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定整数数组nums，以及整数modulo和k。\n记数组内满足x % modulo == k的个数为cnt\n若nums的某子数组满足cnt % modulo == k则称其为趣味子数组，求nums内的趣味子数组个数。\n思路首先可以发现我们仅关注满足x % modulo == k的x的个数，因此我们可以将所有nums内模modulo为k的数记为1其他数则记为0;\n完成转换后什么样的子数组满足cnt % modulo == k呢，显然需要满足\n\n那么是不是可以联想到前缀和，再结合一下模运算的性质，可以得出结果。\n实现class Solution {using ll = long long;public:    long long countInterestingSubarrays(vector&lt;int&gt;&amp; nums, int modulo, int k) {        ll ans = 0;        unordered_map&lt;int, int&gt; cnt;        int pre = 0;        for (const auto&amp; x : nums) {            cnt[pre]++;            pre += x % modulo == k;            if (pre &gt;= modulo) pre -= modulo;            ans += cnt[(pre - k + modulo) % modulo];        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2799-统计完全子数组的数目","url":"/2025/04/24/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982799-%E7%BB%9F%E8%AE%A1%E5%AE%8C%E5%85%A8%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums，称不同元素的数目与整个nums不同元素的个数相同的子数组为完全子数组。求nums中完全子数组个数。\n思路思路与2025-04-16的2537-统计好子数组的数目其实是高度类似的\n进行一个滑动窗口，枚举窗口的右端点，对于每个右端点其最左不满足条件的位置左侧所有位置均满足条件。\n使用哈希简单计数即可。\n实现class Solution {public:    int countCompleteSubarrays(vector&lt;int&gt;&amp; nums) {        unordered_set&lt;int&gt; st(nums.begin(), nums.end());        int cnt = st.size();        int ans = 0, cur = 0;        unordered_map&lt;int, int&gt; f;        for (int l = 0, r = 0; r &lt; nums.size(); r++) {            f[nums[r]]++;            if (f[nums[r]] == 1) cur++;            while (l &lt;= r &amp;&amp; cur == cnt) {                f[nums[l]]--;                if (f[nums[l]] == 0) cur--;                l++;            }            ans += l;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1399-统计最大组的数目","url":"/2025/04/23/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981399-%E7%BB%9F%E8%AE%A1%E6%9C%80%E5%A4%A7%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定整数n，将[1, n]中所有数位和相同的分作一组，求大小并列最大的组的数目\n思路首先这道题的数据范围很小\n\n可以考虑直接暴力枚举[1, n]计算其数位和然后统计对应组的大小。\n进阶一些可以考虑数位dp，但比较常规便不过多赘述，仅列出递推公式：\n记为递推到第位数位和为前几位是（）否（）等于对应数位的方案个数\n为十进制下第位的数\n为第位所填的数\n\n\n\n实现数位dp实现\nclass Solution {public:    int countLargestGroup(int n) {        string s = to_string(n);        reverse(s.begin(), s.end());        const int N = s.size();        vector dp(2, vector&lt;vector&lt;int&gt;&gt; (N + 1, vector&lt;int&gt; (9 * N + 1)));        dp[1][N][0] = 1;        for (int i = N; i &gt; 0; i--) {            for (int j = 0; j &lt;= (N - i) * 9; j++) {                if (dp[0][i][j] == 0 &amp;&amp; dp[1][i][j] == 0) continue;                for (int k = 0; k &lt;= 9; k++) {                    if (k &lt; s[i - 1] - '0') {                        dp[0][i - 1][j + k] += dp[0][i][j] + dp[1][i][j];                    } else if (k == s[i - 1] - '0') {                        dp[1][i - 1][j + k] += dp[1][i][j];                        dp[0][i - 1][j + k] += dp[0][i][j];                    } else {                        dp[0][i - 1][j + k] += dp[0][i][j];                    }                }            }        }        int mx = 0, ans = 0;        for (int i = 1; i &lt;= 9 * N; i++) {            int t = dp[0][0][i] + dp[1][0][i];            if (mx &lt; t) {                mx = t;                ans = 1;            } else if (mx == t) {                ans++;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","dp"]},{"title":"力扣每日一题2338-统计理想数组的数目","url":"/2025/04/22/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982338-%E7%BB%9F%E8%AE%A1%E7%90%86%E6%83%B3%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定值n与maxValue\n称满足以下条件的数组arr为理想数组：\n\n长度为n\n每个元素在[1, maxValue]\n每个元素均可被前一个元素整除即arr[i] % arr[i - 1] == 0\n\n求不同理想数组数目\n思路每个元素均可被前一个元素整除，也就是每个数均为上一个元素的倍数。\n当数组内的最大值即最后一个元素固定时，有多少个满足条件的理想数组呢。可以考虑将最大值质因数分解得到：\n\n那么是不是在数组的n个位置中相对前一个元素，分别乘了\n次次次\n那么问题就转化为了在n个盒子放a个红球，b个黄球...k个蓝球允许有盒子空出，允许多个球在同一盒子的问题。\n显然不同颜色的球的方法是互相独立的互相之间可以直接乘算。\n那么在n个盒子中放x个同样的球允许放空有多少种方法呢，这里我参考了灵茶山艾府大佬的题解，讲的非常好\n可以转化为在n个盒子中放x + n个相同的球，不允许放空；在放完结束后从每个盒子中各拿出一个球即为n个盒子放x个球允许放空。\n那么如何做在n个盒子中放x + n个相同的球，不允许放空呢，显然是有x + n个球x + n - 1个空隙中插入n - 1个挡板的方案即\n\n故只需预处理出组合数与质因式分解的结果再进行方案数计算即可。\n实现constexpr int mod = 1e9 + 7;constexpr int MX = 1e4;vector&lt;int&gt; primes;int minp[MX + 1];vector&lt;vector&lt;int&gt;&gt; pi(MX + 1);constexpr int MK = __lg(MX) + 1;int C[MX + MK + 1][MX + 1];int init = []() {    for (int i = 2; i &lt;= MX; i++) {        if (minp[i] == 0) {            minp[i] = i;            primes.push_back(i);        }        for (const auto&amp; p : primes) {            if (p * i &gt; MX) break;            minp[p * i] = p;            if (minp[i] == p) break;        }    }    for (int i = 2; i &lt;= MX; i++) {        int x = i, mp = minp[i];        while (x != 1) {            int cnt = 0;            for ( ; x % mp == 0; x /= mp, cnt++);            pi[i].push_back(cnt);            mp = minp[x];        }    }    for (int i = 0; i &lt;= MX + MK; i++) {        C[i][0] = 1;        for (int j = 1; j &lt;= min(i, MX); j++) {            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;        }    }    return 0;} ();class Solution {public:    int idealArrays(int n, int maxValue) {        int ans = 0;        for (int i = 1; i &lt;= maxValue; i++) {            int res = 1;            for (const auto&amp; x : pi[i]) {                res = 1ll * res * C[x + n - 1][n - 1] % mod;            }            ans = (ans + res) % mod;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","组合数学"]},{"title":"力扣每日一题2145-统计隐藏数组数目","url":"/2025/04/21/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982145-%E7%BB%9F%E8%AE%A1%E9%9A%90%E8%97%8F%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/","content":"题意给定某隐藏数组的差分数组differences与定值上界upper及定值lower，求满足最大最小值不超过给定上下界的合法隐藏数组的个数。\n思路对差分数组求前缀和即可获知隐藏数组各数与第一个数的差值，也因此易得隐藏数组最大最小值的相对差值。\n又对于给定的差分结果，确定一个数即可确定整个隐藏数组。\n根据给定的上下界upper与lower计算结果即可。\n实现class Solution {using ll = long long;public:    int numberOfArrays(vector&lt;int&gt;&amp; differences, int lower, int upper) {        ll mn = 0, mx = 0;        ll cur = 0;        for (const auto&amp; x : differences) {            cur += x;            mn = min(mn, cur);            mx = max(mx, cur);        }        return max(upper - lower - (mx - mn) + 1, 0ll);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题781-森林中的兔子","url":"/2025/04/20/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98781-%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90/","content":"题意给定整数数组answers,其中answers[i]表示第i只兔子回答问题\"还有多少只兔子与你颜色相同\"的答案。\n求问兔子总数量的最小可能值\n思路并没有什么算法上的知识，就是一个比较简单的数学思维题。\n如果有1只兔子回答1，显然答案是2，因为问题是还有多少只也就是除你外有多少只与你同色\n如果有2只兔子回答1，显然答案是2，因为2只同色的问同样的问题答案相同是符合题意的\n如果有3只兔子回答1，显然答案是4，若3只兔子颜色相同那么它们的回答是不可能为1的，使得总数最小可以贪心的将其中两只配对，另一只独立，问题就变为了前两个问题的和\n…\n不难推出，回答为x的兔子，只可能与回答x的其他兔子同色，最多可以与另外x只回答均为x的兔子组成一个有x + 1只兔子的同色组\n记录各个回答的兔子个数，然后贪心地计算答案即可。\n实现class Solution {public:    int numRabbits(vector&lt;int&gt;&amp; answers) {        unordered_map&lt;int, int&gt; cnt;        for (const auto&amp; x : answers) {            cnt[x]++;        }        int ans = 0;        for (const auto&amp; [x, t] : cnt) {            ans += (t + x) / (x + 1) * (x + 1);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2563-统计公平数对的数目","url":"/2025/04/19/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982563-%E7%BB%9F%E8%AE%A1%E5%85%AC%E5%B9%B3%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums与定值lower和upper，求满足以下条件的数对(i, j)个数\n\n\n思路考虑固定nums[j]那么什么样的nums[i]满足条件呢，移项发现\n\n不难发现nums[i]越大lower - nums[i]与upper - nums[i]越小\n那么比较好实现的就是二分得到第一个满足条件的与最后一个不满足条件的\n实现class Solution {using ll = long long;public:    long long countFairPairs(vector&lt;int&gt;&amp; nums, int lower, int upper) {        ranges::sort(nums);        ll ans = 0;        const int n = nums.size();        for (int i = 0; i &lt; n; i++) {            int r = upper_bound(nums.begin(), nums.begin() + i, upper - nums[i]) - nums.begin();            int l = lower_bound(nums.begin(), nums.begin() + i, lower - nums[i]) - nums.begin();            ans += r - l;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2364-统计坏数对的数目","url":"/2025/04/18/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982364-%E7%BB%9F%E8%AE%A1%E5%9D%8F%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums，求满足以下条件的数对(i, j)个数\n\n思路这几天的每日一题都是类似的求数对或求三元组个数，应该可以感受到求不等于是没有求等于对数方便的。\n那么可以考虑正难则反，求出满足下列条件的数对(i, j)个数，再取补集即可。\n\n好像还是不是很好做，对于给定的i 或 j还是需要枚举另一个数进行筛选\n但是发现可以将式子移项变形\n\n就可以发现此时比较好做了，只需枚举每个数，记录其下标与其值之差即可。\n实现class Solution {using ll = long long;public:    long long countBadPairs(vector&lt;int&gt;&amp; nums) {        unordered_map&lt;int, int&gt; cnt;        ll ans = ll(nums.size()) * (ll(nums.size()) - 1) / 2;        for (int i = 0; i &lt; nums.size(); i++) {            ans -= cnt[i - nums[i]];            cnt[i - nums[i]]++;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2176-统计数组中相等且可以被整除的数对","url":"/2025/04/17/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982176-%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9B%B8%E7%AD%89%E4%B8%94%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%95%B4%E9%99%A4%E7%9A%84%E6%95%B0%E5%AF%B9/","content":"题意给定数组nums与定值k，求满足以下条件的下标 (i, j) 对数\n0 &lt;= i &lt; j &lt; nums.size()\nnums[i] == nums[j]\ni * j % k == 0\n思路首先这道题的数据范围比较小，是可以直接暴力进行的（没有预处理等操作暴力反而还更快些）\n但这样不太优雅，我们假定数据范围比较大时应该如何做呢\n首先考虑什么情况下 i * j % k == 0呢\n显然若i % k == 0 || j % k == 0时等式是成立的\n但若i、j均不为k的倍数呢，是否有可能乘积被k 整除，举例发现是可行的比如6 % 4 != 0, 10 % 4 != 0, 6 * 10 % 4 == 0 \n可以发现：\n\n若j % t == 0 可得i * j % k == 0\n那么枚举j再计算符合nums[i] == nums[j] 且 i % t == 0的条件的i个数即可\n此处使用哈希记录j之前的值为nums[j]及其对应下标的因数，如此只需统计cnt[(nums[j], t)]即可\n注意unordered_map的键值不能直接使用pair&lt;&gt;需要重载其运算符，或将nums[j] 与 t合并为一个数再进行哈希计算\n实现暴力实现\nclass Solution {public:    int countPairs(vector&lt;int&gt;&amp; nums, int k) {        int ans = 0;        for (int i = 0; i &lt; nums.size(); i++) {            for (int j = i + 1; j &lt; nums.size(); j++) {                if (nums[i] == nums[j] &amp;&amp; i * j % k == 0) ans++;            }        }        return ans;    }};\n\n\n\n其他实现\nconstexpr int N = 100;vector&lt;vector&lt;int&gt;&gt; factors(N + 1);int init = []() {    for (int i = 1; i &lt;= N; i++) {        for (int j = i; j &lt;= N; j += i) {            factors[j].push_back(i);        }    }    return 0;} ();class Solution {public:    int countPairs(vector&lt;int&gt;&amp; nums, int k) {        int ans = 0;        auto cal = [](int x, int f) -&gt; int {            return x &lt;&lt; 8 | f;        };        unordered_map&lt;int, int&gt; cnt;        for (int i = 0; i &lt; nums.size(); i++) {            int t = k / gcd(i, k);            ans += cnt[cal(nums[i], t)];            if (i &amp;&amp; nums[i] == nums[0]) ans++;            for (auto f : factors[i]) {                cnt[cal(nums[i], f)]++;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2537-统计好子数组的数目","url":"/2025/04/16/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982537-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums与定值k，求该nums中至少有k对相等数的子数组数目\n即有多少子数组arr至少含有k对(i, j)满足i &lt; j 且 arr[i]==arr[j]\n思路求满足条件的子数组个数，比较经典的思路就是双指针进行一个滑动窗口。\n维护区间内相等数的对数可以考虑使用哈希记录各个数出现的次数。\n枚举窗口的右端点，对于每个右端点其最左不满足条件的位置左侧所有位置均满足条件。\n实现class Solution {using ll = long long;public:    long long countGood(vector&lt;int&gt;&amp; nums, int k) {        ll ans = 0;        unordered_map&lt;int, int&gt; cnt;        for (int l = 0, r = 0, p = 0; r &lt; nums.size(); r++) {            p += cnt[nums[r]];            cnt[nums[r]]++;            while (p &gt;= k) {                cnt[nums[l]]--;                p -= cnt[nums[l]];                l++;            }            ans += l;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2179-统计数组中好三元组数目","url":"/2025/04/15/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982179-%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%BB%84%E4%B8%AD%E5%A5%BD%E4%B8%89%E5%85%83%E7%BB%84%E6%95%B0%E7%9B%AE/","content":"题意给定两[0, n - 1] 的排列nums1与nums2，求满足下列条件的三元组(i, j, k)的个数\ni, j, k的出现顺序在nums1与nums2中均一致为顺序出现，记p1_i 为i在nums1中出现的位置，p2_i为i在nums2中出现的位置，即：\n\n思路注意到此处三元组仅关注数出现的顺序而与数的具体值无关，可以考虑将nums1 中的各个数值映射到其对应的出现顺序。\n对于统计合法的三元组问题，可以考虑枚举中间值j再判断其前后满足条件的i与k数量，此处枚举j那么对于同一个j其合法的三元组个数即为：nums1 与 nums2 中均出现在 j 前的数的个数 * nums1 与 nums2 中均出现在 j 之后的数的个数\n那么枚举nums2中的元素，将每个元素视作三元组的j，使用与nums1相同的映射函数P：\n\n小于P(nums2[j])的数即为在nums1中，于nums2[j]之前所出现过的数；\n\n而i &lt; j | nums2[i]即是在nums2中，于nums2[j] 之前所出现过的数；\n\n大于P(nums2[j])的数即为在nums1中，于nums2[j]之后将出现的数；\n\n而i &gt; j | nums2[i]即是在nums2中，于nums2[j] 之后将出现的数；\n\n\n取并操作即可得到nums1 与 nums2 中均出现在 nums2[j] 前的数的个数 与 nums1 与 nums2 中均出现在 nums2[j] 之后的数的个数\n如何快速维护得到小于某个值且在之前出现过的值的个数呢，比较自然的可以想到树状数组，当然线段树等其他数据结构也是可行的。\n实现template&lt;typename T&gt;class Fenwick {private:    int n;    vector&lt;T&gt; a;public:    Fenwick(int x) {        n = x;        a.resize(x + 1);    }    void add(int x, T val) {        for ( ; x &lt;= n; x += (x &amp; -x)) {            a[x] += val;        }    }    T query(int x) {        T res = 0;        for ( ; x &gt; 0; x -= (x &amp; -x)) {            res += a[x];        }        return res;    }};class Solution {using ll = long long;public:    long long goodTriplets(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        ll ans = 0;        const int n = nums1.size();        vector&lt;int&gt; p(n);        for (int i = 0; i &lt; n; i++) {            p[nums1[i]] = i;        }        Fenwick&lt;int&gt; f(n);        for (int i = 0; i &lt; n; i++) {            int t = f.query(p[nums2[i]]);            ans += 1ll * t * (n - 1 - p[nums2[i]] - i + t);            f.add(p[nums2[i]] + 1, 1);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","fenwick"]},{"title":"力扣每日一题1534-统计好三元组","url":"/2025/04/14/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981534-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E4%B8%89%E5%85%83%E7%BB%84/","content":"题意给定数组arr，与三整数a、b、c，求满足以下条件的三元组(i, j, k)个数\n\n​\n\n\n思路注意到数组大小范围很小仅有1e2，直接暴力即可。\n当然也存在更加高效的做法，但我有点犯懒了，详细还是请见他人博客（\n实现class Solution {public:    int countGoodTriplets(vector&lt;int&gt;&amp; arr, int a, int b, int c) {        int ans = 0;        for (int i = 0; i &lt; arr.size(); i++) {            for (int j = i + 1; j &lt; arr.size(); j++) {                if (abs(arr[i] - arr[j]) &gt; a) continue;                for (int k = j + 1; k &lt; arr.size(); k++) {                    if (abs(arr[j] - arr[k]) &gt; b) continue;                    if (abs(arr[i] - arr[k]) &gt; c) continue;                    ans++;                }            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1922-统计好数字的数目","url":"/2025/04/13/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981922-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意若一个数字串满足偶数位均位偶数奇数位均为质数，则称其为好数字。\n问长度为给定n的好数字个数（可前导零）。\n思路个位数的偶数共有5个0, 2, 4, 6, 8\n个位数的质数共有4个2, 3, 5, 7\n且允许存在前导零，那么显然这是一个简单的数学问题\n记为even偶数位个数，odd为奇数位个数则有\n方案数\n唯一需要注意的是n较大 , 需用上快速幂，且答案较大需对1e9 + 7取模\n实现class Solution {using ll = long long;static constexpr ll mod = 1e9 + 7;public:    ll powMod(ll a, ll b) {        ll res = 1;        while (b) {            if (b &amp; 1) {                res = res * a % mod;            }            a = a * a % mod;            b &gt;&gt;= 1;        }        return res;    }    int countGoodNumbers(long long n) {        ll even = n / 2 + (n &amp; 1), odd = n / 2;        return powMod(5, even) * powMod(4, odd) % mod;    }};\n\n","categories":["做题笔记"],"tags":["cpp","math"]},{"title":"力扣每日一题3272-统计好整数的数目","url":"/2025/04/12/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983272-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意若一个数x是回文整数且被k整除则称其为k回文整数。\n若一个数y可以对其数位进行重排后变为k回文整数则称其为好整数（无前导零）。\n对于给定的数位n与个位数k，求问有多少个n位数为好整数。\n思路首先考虑得到k回文整数再将其重排得到好整数\n对于回文数，因为其前半部分与其后半部分反转后相同，故可以考虑枚举其前半部分。\n能否整除k仅需计算一下即可。\n而对于一个k回文整数有多少种合法重排方式，则是一个较为简单的排列组合问题，首先是第一位数不能为0,剩余位数可任意排序，又相同的数之间互换是相同的，故而可以推导出：\n记为该数为i的数位个数\n合法重排方案数\n显然当均相等时得到的方案数相同，再考虑对其使用哈希去重即可\n实现array&lt;int, 11&gt; f;int init = []() {    f[0] = 1;    for (int i = 1; i &lt;= 10; i++) {        f[i] = i * f[i - 1];    }    return 0;}();class Solution {using ll = long long;public:    long long countGoodIntegers(int n, int k) {        ll ans = 0;        int b = pow(10, (n + 1) / 2 - 1);        unordered_set&lt;string&gt; vis;        array&lt;int, 10&gt; cnt;        for (int i = b; i &lt; b * 10; i++) {            string s = to_string(i), t = s;            if (n &amp; 1) t.pop_back();            reverse(t.begin(), t.end());            s += t;            if (stoll(s) % k) continue;            ranges::sort(s);            if (vis.count(s)) continue;            vis.insert(s);            cnt.fill(0);            for (const auto&amp; ch : s) cnt[ch - '0']++;            ll res = (n - cnt[0]) * f[n - 1];            for (int i = 0; i &lt; 10; i++) {                res /= f[cnt[i]];            }            ans += res;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","组合数学"]},{"title":"力扣每日一题2843-统计对称整数的数目","url":"/2025/04/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982843-%E7%BB%9F%E8%AE%A1%E5%AF%B9%E7%A7%B0%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意2 * n位数字组成的整数x，若其前n与后n位数位和相等，则称其对称。\n求给定范围[low, high]内对称数的个数。\n思路注意到数据范围很小 直接遍历计数即可。\n但这样太不优雅了，若数据范围扩大该如何做呢，显然和昨天一样是可以通过数位dp来解决的，但尝试了一下感觉好麻烦哦，不想写，easy题有easy题的解法，摆了。\n实现class Solution {public:    static constexpr int mx = 20;    int countSymmetricIntegers(int low, int high) {        auto check = [](int x) -&gt; bool {            string s = to_string(x);            int n = s.size();            if (n &amp; 1) return false;            int sum = 0;            for (int i = 0; i &lt; n; i++) {                sum += (i &lt; n / 2 ? 1 : -1) * (s[i] - ' 0');            }            return sum == 0;        };        int ans = 0;        for (int i = low; i &lt;= high; i++) {            if (check(i)) ans++;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2999-统计强大整数的数目","url":"/2025/04/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982999-%E7%BB%9F%E8%AE%A1%E5%BC%BA%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定区间[start, finish] 、数位限制limit与后缀s，求区间范围内满足每一位数不超过limit且以s为后缀的数的个数。\n思路比较经典的数位dp。\n首先考虑如何计算区间[0, finish]即 满足条件 的x个数。\n在不考虑s为后缀仅考虑每一位限制为limit的条件情况下，从高位向低位递推\n记表示finish第j位\n 当i=0时表示到第j位严格小于finish且满足限制limit的方案个数，当i=1时表示到第j位严格等于finish且满足限制limit的方案个数，可以推到出以下转移方程$$\\left{\\right.$$再考虑如何满足以s为后缀\n记 为s的第j位\n同理可有$$\\left{\\right.$$最终即为所求。\n同理再求出范围[0, start)即[0, start - 1]内的方案数，两者相减即可得到[start, finish]内的方案数。\n实现class Solution {public:    using ll = long long;    long long numberOfPowerfulInt(long long start, long long finish, int limit, string s) {        reverse(s.begin(), s.end());        auto cal = [&amp;](ll t) -&gt; ll {            string num = to_string(t);            reverse(num.begin(), num.end());            vector dp(2, vector&lt;ll&gt; (max(num.size(), s.size()) + 1));            dp[1][max(num.size(), s.size())] = 1;            for (int i = num.size() - 1; i &gt;= 0; i--) {                int x = num[i] - '0';                if (i &gt;= s.size()) {                    if (x &gt; limit) {                        dp[0][i] += (limit + 1) * (dp[0][i + 1] + dp[1][i + 1]);                    } else {                        dp[1][i] += dp[1][i + 1];                        dp[0][i] += x * dp[1][i + 1] + (limit + 1) * dp[0][i + 1];                    }                } else {                    int y = s[i] - '0';                    if (x &gt; y) {                        dp[0][i] += dp[1][i + 1] + dp[0][i + 1];                    } else if (x == y) {                        dp[1][i] += dp[1][i + 1];                        dp[0][i] += dp[0][i + 1];                    } else {                        dp[0][i] += dp[0][i + 1];                    }                }            }            return dp[0][0] + dp[1][0];        };        return cal(finish) - cal(start - 1);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","数位dp"]},{"title":"网络学习","url":"/2025/04/09/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/","content":"由于我个人仍在学习当中，所学内容可能较为零散不成体系更多是以学习时间记录而非内容体系记录，所写可能也因此显得有些杂乱无章，当我建立起一个较为完整的知识体系框架后也许会回来整理吧。\n所记录的问题可能来自我网上冲浪所见或面试所遇我认为值得记录学习的，回答可能来自于网络资料、各路大模型回答以及一些我个人的理解，可能准确率并不太高，若有错漏还望不吝赐教。\n","categories":["学习笔记"],"tags":["note","network"]},{"title":"cpp学习","url":"/2025/04/09/cpp%E5%AD%A6%E4%B9%A0/","content":"由于我个人仍在学习当中，所学内容可能较为零散不成体系更多是以学习时间记录而非内容体系记录，所写可能也因此显得有些杂乱无章，当我建立起一个较为完整的知识体系框架后也许会回来整理吧。\n所记录的问题可能来自我网上冲浪所见或面试所遇我认为值得记录学习的，回答可能来自于网络资料、各路大模型回答以及一些我个人的理解，可能准确率并不太高，若有错漏还望不吝赐教。\n智能指针引用计数概念防止内存泄露。\n基本想法：对于动态分配的对象进行引用计数每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次， 每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。\nc++11引入智能指针概念，包含std::shared_ptr/std::unique_ptr/std::weak_ptr,头文件为&lt;memory&gt;\nshared_ptr可自动记录有多少个shared_ptr共同指向同一对象，当计数归零时自动释放对应对象内存\nstd::make_shared&lt;T&gt; (Args&amp;&amp;... args); // 创建对应对象并返回其指针.get(); // 获得原始指针.use_count(); // 查看对象引用计数\tauto p = ptr.get(); // 不会增加计数\tauto p = ptr; // 会增加计数.reset(); // 置空\n\nunique_ptr独占的智能指针, 禁止其他智能指针与其共享同一个对象\n\ncpp11没有提供std::make_unique, cpp委员会说是忘记了\n\nunique_ptr 用法shared_ptr与类似，但无法通过赋值拷贝给另一智能指针，但可以通过std::move将其转移给另一unique_ptr\n同时还可以通过.get()获取其原始指针后直接赋值给普通指针，但这样显然并不安全。\n","categories":["学习笔记"],"tags":["cpp","note"]},{"title":"力扣每日一题3375-使数组的值全部为K的最少操作次数","url":"/2025/04/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983375-%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%BC%E5%85%A8%E9%83%A8%E4%B8%BAK%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","content":"题意数h对于数组nums,若满足,则称h合法，即数组中大于h的数均相等。\n每次操作可以选择任意合法h使得nums中所有大于h的元素变为h\n求问将nums中所有数变为给定k值所需最少操作次数。\n思路当nums最小值小于k时显然是不存在合法操作的，因为不存在将元素值变大的操作。\n可以发现每次操作使得最大值变为次大值时有最优，此题本质可转化为数组中大于k的元素种类数。\n实现class Solution {public:    int minOperations(vector&lt;int&gt;&amp; nums, int k) {        ranges::sort(nums);        if (nums.front() &lt; k) return -1;        nums.erase(unique(nums.begin(), nums.end()), nums.end());        return nums.size() - (nums.front() == k);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3396-使数组元素互不相同所需的最少操作次数","url":"/2025/04/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983396-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%90%8C%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","content":"题意给出一数组，每次操作可以删除数组头三个元素，问使得数组元素互不相同所需最少操作次数。\n思路注意到数据范围很小，数组大小与元素大小均在[1, 100]\n可以考虑正着模拟删除操作，计算删除次数。\n也可以考虑反着操作，从尾开始添加元素，得到最长无重后缀，未添加的元素个数即为要删除的元素个数。\n实现正着模拟删除\nclass Solution {array&lt;int, 101&gt; vis;public:    int minimumOperations(vector&lt;int&gt;&amp; nums) {        vis.fill(0);        int ans = 0, cnt = 0;        for (const auto&amp; x : nums) {            if (vis[x] == 1) cnt++;            vis[x]++;        }        for (int i = 0; cnt &amp;&amp; i &lt; nums.size() - 2; i += 3) {            ans++;            cnt -= (--vis[nums[i]]) == 1;            cnt -= (--vis[nums[i + 1]]) == 1;            cnt -= (--vis[nums[i + 2]]) == 1;        }        ans += cnt &gt; 0;        return ans;    }};\n\n\n\n反着模拟添加\nclass Solution {array&lt;int, 101&gt; vis;public:    int minimumOperations(vector&lt;int&gt;&amp; nums) {        vis.fill(0);        for (int i = nums.size() - 1; i &gt;= 0; i--) {            if (vis[nums[i]]) {                return (i + 1 + 2) / 3;            }            vis[nums[i]]++;        }        return 0;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题416-分割等和子集","url":"/2025/04/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/","content":"题意给出整数数组nums，判断其是否可分割为两个和相等的子集\n思路分割为两个等和数组，换言而止就是将 nums分割为子集a 与b使得：\n\n注意到数据范围很小：\n\n\n即满足\n可以考虑使用dp判断是否存在子集和为 \n实现代码class Solution {public:    bool canPartition(vector&lt;int&gt;&amp; nums) {        int sum = accumulate(nums.begin(), nums.end(), 0);        if (sum &amp; 1) return false;        sum &gt;&gt;= 1;        vector&lt;bool&gt; dp(sum + 1);        dp[0] = true;        for (const auto&amp; x : nums) {            for (int i = sum - x; i &gt;= 0; i--) {                if (!dp[i])continue;                dp[i + x] = true;            }            if (dp.back()) return true;        }        return dp.back();    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","dp"]},{"title":"力扣每日一题368.最大整除子集","url":"/2025/04/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98368-%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86/","content":"题意给一个整数集合nums，找最大子集，满足子集元素两两之间一数为另一数的倍数。\n形式化：找出nums子集ans满足 使得ans大小最大\n思路注意到\n可以想到将集合升序排序后再进一步处理。\n又注意到\n即只需满足子集排序后相邻两数互为倍数可满足题设条件。\n可以考虑使用dp记录当前数为子集最大值时满足条件的子集最大大小\n\n实现代码class Solution {public:    vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        ranges::sort(nums);        vector&lt;int&gt; dp(n, 1), from(n);        iota(from.begin(), from.end(), 0);        int mx = 0, mxloc;        for (int i = 0; i &lt; n; i++) {            for (int j = i + 1; j &lt; n; j++) {                if (nums[j] % nums[i]) continue;                if (dp[j] &lt; dp[i] + 1) {                    dp[j] = dp[i] + 1;                    from[j] = i;                }            }            if (dp[i] &gt; mx) {                mx = dp[i];                mxloc = i;            }        }        vector&lt;int&gt; ans;        for (int i = mxloc; ; i = from[i]) {            ans.push_back(nums[i]);            if (i == from[i]) break;        }        return ans;    }};\n\n其他搭建博客后担心实在无东西可写，于是想到了写写力扣的每日一题。\n之前遇到较为麻烦的每日一题就会懒得写，在博客写这个也许既能让博客每日更新又能push我每天写题。\n当前目标就先定为拿下四月全勤徽章吧。\n","categories":["做题笔记"],"tags":["cpp","leetcode","dp"]},{"title":"第一篇博客","url":"/2025/04/06/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","content":"我是sfiisf，这是我兴趣使然创建的博客，现在还什么都没有，也不知道将来会有些什么。\n防止这个新生的博客太空，于是有了这篇自我介绍。\nsfiisf，这个名字是中二时期一拍大腿想出的名字，其中的内涵有些令人害羞尚且不好意思详细介绍，虽然有些后悔但回过神来时已经在很多地方留下这个名字了，只好延用至今。\n仔细想想，我是个乏善可陈且无趣的人，搜肠刮肚自我介绍到这就有点写不下去了。\n虽然不知道将来是我的分享欲先战胜我的懒惰，还是我的懒惰先战胜我的分享欲，但我是个怎么样的人，还是从我将来的文章来认识我吧！\nLove!\n","categories":["杂谈"],"tags":[]}]