[{"title":"力扣每日一题3396-使数组元素互不相同所需的最少操作次数","url":"/2025/04/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983396-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%90%8C%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","content":"题意给出一数组，每次操作可以删除数组头三个元素，问使得数组元素互不相同所需最少操作次数。\n思路注意到数据范围很小，数组大小与元素大小均在[1, 100]\n可以考虑正着模拟删除操作，计算删除次数。\n也可以考虑反着操作，从尾开始添加元素，得到最长无重后缀，未添加的元素个数即为要删除的元素个数。\n实现正着模拟删除\nclass Solution {array&lt;int, 101&gt; vis;public:    int minimumOperations(vector&lt;int&gt;&amp; nums) {        vis.fill(0);        int ans = 0, cnt = 0;        for (const auto&amp; x : nums) {            if (vis[x] == 1) cnt++;            vis[x]++;        }        for (int i = 0; cnt &amp;&amp; i &lt; nums.size() - 2; i += 3) {            ans++;            cnt -= (--vis[nums[i]]) == 1;            cnt -= (--vis[nums[i + 1]]) == 1;            cnt -= (--vis[nums[i + 2]]) == 1;        }        ans += cnt &gt; 0;        return ans;    }};\n\n\n\n反着模拟添加\nclass Solution {array&lt;int, 101&gt; vis;public:    int minimumOperations(vector&lt;int&gt;&amp; nums) {        vis.fill(0);        for (int i = nums.size() - 1; i &gt;= 0; i--) {            if (vis[nums[i]]) {                return (i + 1 + 2) / 3;            }            vis[nums[i]]++;        }        return 0;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题416-分割等和子集","url":"/2025/04/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/","content":"题意给出整数数组nums，判断其是否可分割为两个和相等的子集\n思路分割为两个等和数组，换言而止就是将 nums分割为子集a 与b使得：\n\n注意到数据范围很小：\n\n\n即满足\n可以考虑使用dp判断是否存在子集和为 \n实现代码class Solution {public:    bool canPartition(vector&lt;int&gt;&amp; nums) {        int sum = accumulate(nums.begin(), nums.end(), 0);        if (sum &amp; 1) return false;        sum &gt;&gt;= 1;        vector&lt;bool&gt; dp(sum + 1);        dp[0] = true;        for (const auto&amp; x : nums) {            for (int i = sum - x; i &gt;= 0; i--) {                if (!dp[i])continue;                dp[i + x] = true;            }            if (dp.back()) return true;        }        return dp.back();    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","dp"]},{"title":"力扣每日一题368.最大整除子集","url":"/2025/04/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98368-%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86/","content":"题意给一个整数集合nums，找最大子集，满足子集元素两两之间一数为另一数的倍数。\n形式化：找出nums子集ans满足 使得ans大小最大\n思路注意到\n可以想到将集合升序排序后再进一步处理。\n又注意到\n即只需满足子集排序后相邻两数互为倍数可满足题设条件。\n可以考虑使用dp记录当前数为子集最大值时满足条件的子集最大大小\n\n实现代码class Solution {public:    vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        ranges::sort(nums);        vector&lt;int&gt; dp(n, 1), from(n);        iota(from.begin(), from.end(), 0);        int mx = 0, mxloc;        for (int i = 0; i &lt; n; i++) {            for (int j = i + 1; j &lt; n; j++) {                if (nums[j] % nums[i]) continue;                if (dp[j] &lt; dp[i] + 1) {                    dp[j] = dp[i] + 1;                    from[j] = i;                }            }            if (dp[i] &gt; mx) {                mx = dp[i];                mxloc = i;            }        }        vector&lt;int&gt; ans;        for (int i = mxloc; ; i = from[i]) {            ans.push_back(nums[i]);            if (i == from[i]) break;        }        return ans;    }};\n\n其他搭建博客后担心实在无东西可写，于是想到了写写力扣的每日一题。\n之前遇到较为麻烦的每日一题就会懒得写，在博客写这个也许既能让博客每日更新又能push我每天写题。\n当前目标就先定为拿下四月全勤徽章吧。\n","categories":["做题笔记"],"tags":["cpp","leetcode","dp"]},{"title":"第一篇博客","url":"/2025/04/06/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","content":"我是sfiisf，这是我兴趣使然创建的博客，现在还什么都没有，也不知道将来会有些什么。\n防止这个新生的博客太空，于是有了这篇自我介绍。\nsfiisf，这个名字是中二时期一拍大腿想出的名字，其中的内涵有些令人害羞尚且不好意思详细介绍，虽然有些后悔但回过神来时已经在很多地方留下这个名字了，只好延用至今。\n仔细想想，我是个乏善可陈且无趣的人，搜肠刮肚自我介绍到这就有点写不下去了。\n虽然不知道将来是我的分享欲先战胜我的懒惰，还是我的懒惰先战胜我的分享欲，但我是个怎么样的人，还是从我将来的文章来认识我吧！\nLove!\n","categories":["杂谈"],"tags":[]}]