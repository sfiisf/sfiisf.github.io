[{"title":"力扣每日一题693-交替位二进制数","url":"/2026/02/18/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98693-%E4%BA%A4%E6%9B%BF%E4%BD%8D%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/","content":"题意给定正整数 n ，判断其二进制表示是否总为 0 1 交替出现。\n思路可以想到右移一位使得相邻位对上，而相邻位为 0 1 交替即代表异或结果为 1。因此若该数满足条件，则该数与其右移一位的数异或后可得一个低位均为 1 的数。验证该结果是否均为 1 即可。可以使其加一，则必为一个与原数无共同位的二的幂次。\n实现class Solution {public:    bool hasAlternatingBits(int n) {        unsigned x = (n &gt;&gt; 1) ^ n;        return !(x &amp; (x + 1));    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题401-二进制手表","url":"/2026/02/17/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98401-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8/","content":"题意有一个二进制手表，小时用四个灯 8 4 2 1 表示，分钟用六个灯 32 16 8 4 2 1 表示，若有 turnedOn 个灯亮着，求问所有可能表示的时间。\n思路数据范围显然很小，直接进行枚举判断即可。\n实现class Solution {public:    vector&lt;string&gt; readBinaryWatch(int turnedOn) {        vector&lt;string&gt; ans;        for (unsigned i = 0; i &lt;12; i++) {            for (unsigned j = 0; j &lt; 60; j++) {                if (popcount(i) + popcount(j) == turnedOn) {                    if (j &lt; 10) ans.push_back({to_string(i) + \":0\" + to_string(j)});                    else ans.push_back({to_string(i) + \":\" + to_string(j)});                }            }        }        return ans;       }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题190-颠倒二进制位","url":"/2026/02/16/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98190-%E9%A2%A0%E5%80%92%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%BD%8D/","content":"题意颠倒给定 32 位有符号整数的二进制位。\n思路可以直接逐位进行模拟，但这里其实是有个库函数 __builtin_bitreverse32 的，所以可以直接偷偷懒。\n实现class Solution {public:    int reverseBits(int n) {        return __builtin_bitreverse32(n);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题67-二进制求和","url":"/2026/02/15/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9867-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/","content":"题意给定两二进制字符串 a 与 b ，以二进制字符串的形式返回它们的和。\n思路没什么特别的，进行一个二进制求和模拟即可。\n实现class Solution {public:    string addBinary(string a, string b) {        if (a.size() &lt; b.size()) swap(a, b);        int n = a.size(), m = b.size();        ranges::reverse(a);        ranges::reverse(b);        for (int i = 0; i &lt; m - 1; i++) {            a[i] += b[i] - '0';            if (a[i] &gt; '1') {                a[i] -= 2;                a[i + 1] += 1;            }        }        a[m - 1] += b[m - 1] - '0';        for (int i = m - 1; i &lt; n - 1; i++) {            if (a[i] &gt; '1') {                a[i] -= 2;                a[i + 1] += 1;            }        }        if (a.back() &gt; '1') {            a.back() -= 2;            a += '1';        }                ranges::reverse(a);        return a;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题799-香槟塔","url":"/2026/02/14/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98799-%E9%A6%99%E6%A7%9F%E5%A1%94/","content":"题意给定金字塔形香槟塔，初始全为空，往最顶的玻璃杯倒入 poured 杯香槟，求问第 query_row 行 第 query_glass 个杯子中有多少酒。\n思路数据范围不很大 1 &lt;= query_row, query_glass &lt;= 100 ，我们直接就倒酒的这个流程进行模拟就好。\n实现class Solution {public:    double champagneTower(int poured, int query_row, int query_glass) {        vector f(query_row + 2, vector&lt;double&gt; (query_glass + 2));        f[0][0] = poured;        for (int i = 0; i &lt;= query_row; i++) {            for (int j = 0; j &lt;= query_glass; j++) {                if (f[i][j] &gt; 1) {                    f[i + 1][j] += (f[i][j] - 1) / 2;                    f[i + 1][j + 1] += (f[i][j] - 1) / 2;                }            }        }        return min(f[query_row][query_glass], 1.0);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3714-最长的平衡子串II","url":"/2026/02/13/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983714-%E6%9C%80%E9%95%BF%E7%9A%84%E5%B9%B3%E8%A1%A1%E5%AD%90%E4%B8%B2II/","content":"题意给定仅包含 a b c 的字符串 s ，找出最长的 子串中所有不同字符出现次数都相同的 子串的长度。\n思路和昨天题目是非常类似的，只是字符串长度扩大到了 1e5 ，但字符范围缩小到了 abc。那我们昨天的平方的做法是行不通了的，自然是想到从缩小了的范围去考虑。\n答案总共有三种情况，首先是仅包含一种字符，然后是仅包含两种字符，最后是包含 abc 三种。第一种比较简单不过多讲解；第二种我们做过类似的，实际上就是令某个字符视作 +1 另一字符视作 -1，找区间和为 0 的子串，我们这里需要枚举三种不同的选字符方式；第三种实际上也仅为第二种的扩展 cnt_a == cnt_b == cnt_c ，我们将其拆开为 cnt_a == cnt_b &amp;&amp; cnt_b == cnt_c ，也就是找两组数区间和均为 0 的子串。\n实现class Solution {using ll = long long;public:    int longestBalanced(string s) {        int ans = 0;        int n = s.size();                for (int i = 0, j; i &lt; n; i = j) {            for (j = i + 1; j &lt; n &amp;&amp; s[j] == s[i]; j++);            ans = max(ans, j - i);        }        auto cal = [&amp;](char x, char y) -&gt; void {            for (int i = 0; i &lt; n; i++) {                unordered_map&lt;int, int&gt; last;                last[0] = i - 1;                int cur = 0;                for ( ; i &lt; n &amp;&amp; (s[i] == x || s[i] == y); i++) {                    cur += s[i] == x ? 1 : -1;                    if (last.count(cur)) {                        ans = max(ans, i - last[cur]);                    } else {                        last[cur] = i;                    }                }            }        };        cal('a', 'b');        cal('a', 'c');        cal('b', 'c');        unordered_map&lt;ll, int&gt; last;        last[1ll * n &lt;&lt; 20 | n] = -1;        array&lt;int, 3&gt; cnt;        cnt.fill(0);        for (int i = 0; i &lt; n; i++) {            cnt[s[i] - 'a']++;            ll p = 1ll * (cnt[0] - cnt[1] + n) &lt;&lt; 20 | (cnt[1] - cnt[2] + n);            if (last.count(p)) {                ans = max(ans, i - last[p]);            } else {                last[p] = i;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3713-最长的平衡子串I","url":"/2026/02/12/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983713-%E6%9C%80%E9%95%BF%E7%9A%84%E5%B9%B3%E8%A1%A1%E5%AD%90%E4%B8%B2I/","content":"题意给定小写字母字符串 s ，找出最长的 子串中所有不同字符出现次数相同的子串 的长度\n思路和前两天的题目非常类似，但又很不同，又二十六种字符，重复出现有重复贡献，同时要排除未出现字符的影响。好像是有点难做的，好在数据范围不大 1 &lt;= len(s) &lt;= 1e3 ，那咱们简单范围简单做，进行一个平方的枚举范围就好。\n实现class Solution {public:    int longestBalanced(string s) {        int n = s.size();        int ans = 0;        array&lt;int, 26&gt; cnt;        for (int i = 0; i &lt; n; i++) {            cnt.fill(0);            for (int j = i; j &lt; n; j++) {                cnt[s[j] - 'a']++;                int cur = j - i + 1;                if (cur &lt; ans) continue;                bool ok = true;                for (int k = 0, t = 0; k &lt; 26; k++) {                    if (cnt[k] == 0) continue;                    else if (t == 0) t = cnt[k];                    else if (cnt[k] != t) ok = false;                }                if (ok) ans = max(ans, cur);            }        }        return ans;    }};\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3721-最长平衡子数组II","url":"/2026/02/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983721-%E6%9C%80%E9%95%BF%E5%B9%B3%E8%A1%A1%E5%AD%90%E6%95%B0%E7%BB%84II/","content":"题意给定整数数组 nums ，求不同偶数数量等于不同奇数数量的最长子数组长度。\n思路是的，与 昨天 的题目是一样的，只是数据范围进行了扩大: len(nums) 1500 -&gt; 1e5。但我们昨天的做法还是可行的。\n实现static constexpr int inf = 1e9;template&lt;class Info, class Tag&gt;struct LazySegmentTree {    int n;    std::vector&lt;Info&gt; info;    std::vector&lt;Tag&gt; tag;    LazySegmentTree() : n(0) {}    LazySegmentTree(int n_, Info v_ = Info()) {        init(n_, v_);    }    template&lt;class T&gt;    LazySegmentTree(std::vector&lt;T&gt; init_) {        init(init_);    }    void init(int n_, Info v_ = Info()) {        init(std::vector(n_, v_));    }    template&lt;class T&gt;    void init(std::vector&lt;T&gt; init_) {        n = init_.size();        info.assign(4 &lt;&lt; std::__lg(n), Info());        tag.assign(4 &lt;&lt; std::__lg(n), Tag());        std::function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) {            if (r - l == 1) {                info[p] = init_[l];                return;            }            int m = (l + r) / 2;            build(2 * p, l, m);            build(2 * p + 1, m, r);            pull(p);        };        build(1, 0, n);    }    void pull(int p) {        info[p] = info[2 * p] + info[2 * p + 1];    }    void apply(int p, const Tag &amp;v) {        info[p].apply(v);        tag[p].apply(v);    }    void push(int p) {        apply(2 * p, tag[p]);        apply(2 * p + 1, tag[p]);        tag[p] = Tag();    }    void modify(int p, int l, int r, int x, const Info &amp;v) {        if (r - l == 1) {            info[p] = v;            return;        }        int m = (l + r) / 2;        push(p);        if (x &lt; m) {            modify(2 * p, l, m, x, v);        } else {            modify(2 * p + 1, m, r, x, v);        }        pull(p);    }    void modify(int p, const Info &amp;v) {        modify(1, 0, n, p, v);    }    Info rangeQuery(int p, int l, int r, int x, int y) {        if (l &gt;= y || r &lt;= x) {            return Info();        }        if (l &gt;= x &amp;&amp; r &lt;= y) {            return info[p];        }        int m = (l + r) / 2;        push(p);        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);    }    Info rangeQuery(int l, int r) {        return rangeQuery(1, 0, n, l, r);    }    void rangeApply(int p, int l, int r, int x, int y, const Tag &amp;v) {        if (l &gt;= y || r &lt;= x) {            return;        }        if (l &gt;= x &amp;&amp; r &lt;= y) {            apply(p, v);            return;        }        int m = (l + r) / 2;        push(p);        rangeApply(2 * p, l, m, x, y, v);        rangeApply(2 * p + 1, m, r, x, y, v);        pull(p);    }    void rangeApply(int l, int r, const Tag &amp;v) {        return rangeApply(1, 0, n, l, r, v);    }    void half(int p, int l, int r) {        if (info[p].act == 0) {            return;        }        if ((info[p].min + 1) / 2 == (info[p].max + 1) / 2) {            apply(p, {-(info[p].min + 1) / 2});            return;        }        int m = (l + r) / 2;        push(p);        half(2 * p, l, m);        half(2 * p + 1, m, r);        pull(p);    }    void half() {        half(1, 0, n);    }        template&lt;class F&gt;    int findFirst(int p, int l, int r, int x, int y, F &amp;&amp;pred) {        if (l &gt;= y || r &lt;= x) {            return -1;        }        if (l &gt;= x &amp;&amp; r &lt;= y &amp;&amp; !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        push(p);        int res = findFirst(2 * p, l, m, x, y, pred);        if (res == -1) {            res = findFirst(2 * p + 1, m, r, x, y, pred);        }        return res;    }    template&lt;class F&gt;    int findFirst(int l, int r, F &amp;&amp;pred) {        return findFirst(1, 0, n, l, r, pred);    }    template&lt;class F&gt;    int findLast(int p, int l, int r, int x, int y, F &amp;&amp;pred) {        if (l &gt;= y || r &lt;= x) {            return -1;        }        if (l &gt;= x &amp;&amp; r &lt;= y &amp;&amp; !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        push(p);        int res = findLast(2 * p + 1, m, r, x, y, pred);        if (res == -1) {            res = findLast(2 * p, l, m, x, y, pred);        }        return res;    }    template&lt;class F&gt;    int findLast(int l, int r, F &amp;&amp;pred) {        return findLast(1, 0, n, l, r, pred);    }        void maintainL(int p, int l, int r, int pre) {        if (info[p].difl &gt; 0 &amp;&amp; info[p].maxlowl &lt; pre) {            return;        }        if (r - l == 1) {            info[p].max = info[p].maxlowl;            info[p].maxl = info[p].maxr = l;            info[p].maxlowl = info[p].maxlowr = -inf;            return;        }        int m = (l + r) / 2;        push(p);        maintainL(2 * p, l, m, pre);        pre = std::max(pre, info[2 * p].max);        maintainL(2 * p + 1, m, r, pre);        pull(p);    }    void maintainL() {        maintainL(1, 0, n, -1);    }    void maintainR(int p, int l, int r, int suf) {        if (info[p].difr &gt; 0 &amp;&amp; info[p].maxlowr &lt; suf) {            return;        }        if (r - l == 1) {            info[p].max = info[p].maxlowl;            info[p].maxl = info[p].maxr = l;            info[p].maxlowl = info[p].maxlowr = -inf;            return;        }        int m = (l + r) / 2;        push(p);        maintainR(2 * p + 1, m, r, suf);        suf = std::max(suf, info[2 * p + 1].max);        maintainR(2 * p, l, m, suf);        pull(p);    }    void maintainR() {        maintainR(1, 0, n, -1);    }};struct Tag {    int x = 0;    void apply(const Tag &amp;t) &amp; {        x += t.x;    }};struct Info {    int x = 0;    int mn = 0;    int mx = 0;    void apply(const Tag &amp;t) &amp; {        x += t.x;        mn += t.x;        mx += t.x;    }};Info operator+(const Info &amp;a, const Info &amp;b) {    return {-inf, min(a.mn, b.mn), max(a.mx, b.mx)};}class Solution {public:    int longestBalanced(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        LazySegmentTree&lt;Info, Tag&gt; StT(n + 1);        unordered_map&lt;int, int&gt; last;        int ans = 0, cur = 0;        StT.modify(0, {0, 0, 0});        for (int i = 1; i &lt;= n; i++) {            int v = nums[i - 1];            int p = (v &amp; 1) ? 1 : -1;            auto it = last.find(v);            if (it == last.end()) {                cur += p;                StT.rangeApply(i, n, {p});            } else {                StT.rangeApply((*it).second, i, {-p});            }            last[v] = i;            int j = StT.findFirst(0, n, [&amp;](const auto&amp; x) {                return x.mn &lt;= cur &amp;&amp; x.mx &gt;= cur;            });            if (j &gt;= 0) ans = max(ans, i - j);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3719-最长平衡子数组I","url":"/2026/02/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983719-%E6%9C%80%E9%95%BF%E5%B9%B3%E8%A1%A1%E5%AD%90%E6%95%B0%E7%BB%84I/","content":"题意给定整数数组 nums ，求不同偶数数量等于不同奇数数量的最长子数组长度。\n思路首先应该可以联想到与二进制字符串中01数相同的最大子段，我们是令 1 表示加一，0 表示减一，做了一个前缀和。\n这里进行了升级，同一个数对某个区间的贡献仅有一次。可以想到固定右端点枚举左端点，若某个数首次出现，其右所有点都应加上该数贡献；若非首次出现则抵消先前贡献即可。\n实现static constexpr int inf = 1e9;template&lt;class Info, class Tag&gt;struct LazySegmentTree {    int n;    std::vector&lt;Info&gt; info;    std::vector&lt;Tag&gt; tag;    LazySegmentTree() : n(0) {}    LazySegmentTree(int n_, Info v_ = Info()) {        init(n_, v_);    }    template&lt;class T&gt;    LazySegmentTree(std::vector&lt;T&gt; init_) {        init(init_);    }    void init(int n_, Info v_ = Info()) {        init(std::vector(n_, v_));    }    template&lt;class T&gt;    void init(std::vector&lt;T&gt; init_) {        n = init_.size();        info.assign(4 &lt;&lt; std::__lg(n), Info());        tag.assign(4 &lt;&lt; std::__lg(n), Tag());        std::function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) {            if (r - l == 1) {                info[p] = init_[l];                return;            }            int m = (l + r) / 2;            build(2 * p, l, m);            build(2 * p + 1, m, r);            pull(p);        };        build(1, 0, n);    }    void pull(int p) {        info[p] = info[2 * p] + info[2 * p + 1];    }    void apply(int p, const Tag &amp;v) {        info[p].apply(v);        tag[p].apply(v);    }    void push(int p) {        apply(2 * p, tag[p]);        apply(2 * p + 1, tag[p]);        tag[p] = Tag();    }    void modify(int p, int l, int r, int x, const Info &amp;v) {        if (r - l == 1) {            info[p] = v;            return;        }        int m = (l + r) / 2;        push(p);        if (x &lt; m) {            modify(2 * p, l, m, x, v);        } else {            modify(2 * p + 1, m, r, x, v);        }        pull(p);    }    void modify(int p, const Info &amp;v) {        modify(1, 0, n, p, v);    }    Info rangeQuery(int p, int l, int r, int x, int y) {        if (l &gt;= y || r &lt;= x) {            return Info();        }        if (l &gt;= x &amp;&amp; r &lt;= y) {            return info[p];        }        int m = (l + r) / 2;        push(p);        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);    }    Info rangeQuery(int l, int r) {        return rangeQuery(1, 0, n, l, r);    }    void rangeApply(int p, int l, int r, int x, int y, const Tag &amp;v) {        if (l &gt;= y || r &lt;= x) {            return;        }        if (l &gt;= x &amp;&amp; r &lt;= y) {            apply(p, v);            return;        }        int m = (l + r) / 2;        push(p);        rangeApply(2 * p, l, m, x, y, v);        rangeApply(2 * p + 1, m, r, x, y, v);        pull(p);    }    void rangeApply(int l, int r, const Tag &amp;v) {        return rangeApply(1, 0, n, l, r, v);    }    void half(int p, int l, int r) {        if (info[p].act == 0) {            return;        }        if ((info[p].min + 1) / 2 == (info[p].max + 1) / 2) {            apply(p, {-(info[p].min + 1) / 2});            return;        }        int m = (l + r) / 2;        push(p);        half(2 * p, l, m);        half(2 * p + 1, m, r);        pull(p);    }    void half() {        half(1, 0, n);    }        template&lt;class F&gt;    int findFirst(int p, int l, int r, int x, int y, F &amp;&amp;pred) {        if (l &gt;= y || r &lt;= x) {            return -1;        }        if (l &gt;= x &amp;&amp; r &lt;= y &amp;&amp; !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        push(p);        int res = findFirst(2 * p, l, m, x, y, pred);        if (res == -1) {            res = findFirst(2 * p + 1, m, r, x, y, pred);        }        return res;    }    template&lt;class F&gt;    int findFirst(int l, int r, F &amp;&amp;pred) {        return findFirst(1, 0, n, l, r, pred);    }    template&lt;class F&gt;    int findLast(int p, int l, int r, int x, int y, F &amp;&amp;pred) {        if (l &gt;= y || r &lt;= x) {            return -1;        }        if (l &gt;= x &amp;&amp; r &lt;= y &amp;&amp; !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        push(p);        int res = findLast(2 * p + 1, m, r, x, y, pred);        if (res == -1) {            res = findLast(2 * p, l, m, x, y, pred);        }        return res;    }    template&lt;class F&gt;    int findLast(int l, int r, F &amp;&amp;pred) {        return findLast(1, 0, n, l, r, pred);    }        void maintainL(int p, int l, int r, int pre) {        if (info[p].difl &gt; 0 &amp;&amp; info[p].maxlowl &lt; pre) {            return;        }        if (r - l == 1) {            info[p].max = info[p].maxlowl;            info[p].maxl = info[p].maxr = l;            info[p].maxlowl = info[p].maxlowr = -inf;            return;        }        int m = (l + r) / 2;        push(p);        maintainL(2 * p, l, m, pre);        pre = std::max(pre, info[2 * p].max);        maintainL(2 * p + 1, m, r, pre);        pull(p);    }    void maintainL() {        maintainL(1, 0, n, -1);    }    void maintainR(int p, int l, int r, int suf) {        if (info[p].difr &gt; 0 &amp;&amp; info[p].maxlowr &lt; suf) {            return;        }        if (r - l == 1) {            info[p].max = info[p].maxlowl;            info[p].maxl = info[p].maxr = l;            info[p].maxlowl = info[p].maxlowr = -inf;            return;        }        int m = (l + r) / 2;        push(p);        maintainR(2 * p + 1, m, r, suf);        suf = std::max(suf, info[2 * p + 1].max);        maintainR(2 * p, l, m, suf);        pull(p);    }    void maintainR() {        maintainR(1, 0, n, -1);    }};struct Tag {    int x = 0;    void apply(const Tag &amp;t) &amp; {        x += t.x;    }};struct Info {    int x = 0;    int mn = 0;    int mx = 0;    void apply(const Tag &amp;t) &amp; {        x += t.x;        mn += t.x;        mx += t.x;    }};Info operator+(const Info &amp;a, const Info &amp;b) {    return {-inf, min(a.mn, b.mn), max(a.mx, b.mx)};}class Solution {public:    int longestBalanced(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        LazySegmentTree&lt;Info, Tag&gt; StT(n + 1);        unordered_map&lt;int, int&gt; last;        int ans = 0, cur = 0;        StT.modify(0, {0, 0, 0});        for (int i = 1; i &lt;= n; i++) {            int v = nums[i - 1];            int p = (v &amp; 1) ? 1 : -1;            auto it = last.find(v);            if (it == last.end()) {                cur += p;                StT.rangeApply(i, n, {p});            } else {                StT.rangeApply((*it).second, i, {-p});            }            last[v] = i;            int j = StT.findFirst(0, n, [&amp;](const auto&amp; x) {                return x.mn &lt;= cur &amp;&amp; x.mx &gt;= cur;            });            if (j &gt;= 0) ans = max(ans, i - j);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1382-将二叉搜索树变平衡","url":"/2026/02/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981382-%E5%B0%86%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E5%8F%98%E5%B9%B3%E8%A1%A1/","content":"题意给定一棵二叉搜索树，返回与其结点值相同的二叉搜索平衡树。\n思路搜索树是对于每个结点其左子树的结点值均小于该点值且右子树的结点值均大于该结点值。可以想到用中序遍历得到该树所有结点值升序排序结果，每次取中点做根，左边部分做左子树右边部分做右子树，递归构造即可。\n实现/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) {} *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public:    TreeNode* balanceBST(TreeNode* root) {        vector&lt;int&gt; node;        auto dfs1 = [&amp;](this auto&amp;&amp; self, TreeNode* u) -&gt; void {            if (u == nullptr) return;            self(u-&gt;left);            node.push_back(u-&gt;val);            self(u-&gt;right);        };        dfs1(root);        auto dfs2 = [&amp;](this auto&amp;&amp; self, int l, int r) -&gt; TreeNode* {            if (l &gt; r) return nullptr;            int mid = (l + r) / 2;            return new TreeNode(node[mid], self(l, mid - 1), self(mid + 1, r));        };        return dfs2(0, node.size() - 1);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题110-平衡二叉树","url":"/2026/02/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98110-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","content":"题意给定一棵二叉树，判断它是否为平衡二叉树。\n思路进行一个 dfs，判断求出每个结点左右子树深度然后比较差值即可。\n实现/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) {} *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public:    bool isBalanced(TreeNode* root) {        auto dfs = [](this auto&amp;&amp; self, TreeNode* u) -&gt; int {            if (u == nullptr) return 0;            int l = self(u-&gt;left);            int r = self(u-&gt;right);            if (l == -1 || r == -1 || abs(l - r) &gt; 1) return -1;            return max(l, r) + 1;        };        return dfs(root) != -1;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1653-使字符串平衡的最少删除次数","url":"/2026/02/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981653-%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%9C%80%E5%B0%91%E5%88%A0%E9%99%A4%E6%AC%A1%E6%95%B0/","content":"题意给定仅由字符 a 与 b 组成的字符串 s ，每次操作可删除其内任意字符。求使得 s 满足不存在任意 i &lt; j &amp;&amp; s[i] == 'b' &amp;&amp; s[j] == 'a' 的最小操作次数。\n思路显然是要让 s 变为前半段全 a 后半段全 b 的形态。那么我们可以枚举这个分界点，删除该分界点之前的所有 b 与分界点之后的所有 a ，那也就是做一个前后缀和。\n实现class Solution {public:    int minimumDeletions(string s) {        int n = s.size();        vector&lt;int&gt; suf(n + 1);        for (int i = n - 1; i &gt;= 0; i--) {            suf[i] = suf[i + 1] + (s[i] == 'a');        }        int pre = 0;        int ans = n;        for (int i = 0; i &lt;= n; i++) {            ans = min(ans, pre + suf[i]);            if (i &lt; n) pre += s[i] == 'b';        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3634-使数组平衡的最少移除数目","url":"/2026/02/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983634-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%B9%B3%E8%A1%A1%E7%9A%84%E6%9C%80%E5%B0%91%E7%A7%BB%E9%99%A4%E6%95%B0%E7%9B%AE/","content":"题意给定整数数组 nums 和一个整数 k ，若一个数组最大元素的值不超过最小元素的 k 倍，则称其平衡。你可任意删除 nums 中元素，求使 nums 平衡需要删的最少元素个数。\n思路显然应该对数组进行排序后做一个滑动窗口，枚举最小找最大或反过来都是可以的。这里我是看数据范围不大在赛时写偷懒，就直接进行了多次二分。\n实现class Solution {public:    int minRemoval(vector&lt;int&gt;&amp; nums, int k) {        ranges::sort(nums);        const int n = nums.size();        int ans = n - 1;        for (int i = 0; i &lt; n; i++) {            int suf = n - (ranges::upper_bound(nums, 1ll * nums[i] * k) - nums.begin());            ans = min(ans, suf + i);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3379-转换数组","url":"/2026/02/05/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983379-%E8%BD%AC%E6%8D%A2%E6%95%B0%E7%BB%84/","content":"题意给定循环整数数组 nums ，返回答案数组 result 满足以下条件\n\n若 nums[i] &gt; 0 则 result[i] = nums[i + nums[i]]\n若 nums[i] &lt; 0 则 result[i] = nums[i - abs(nums[i])]\n若 nums[i] == 0 则 result[i] = nums[i]\n\n思路按题意模拟即可，注意各种取模操作不要越界就好。\n实现class Solution {public:    vector&lt;int&gt; constructTransformedArray(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        vector&lt;int&gt; ans(n);        for (int i = 0; i &lt; n; i++) {            if (nums[i] &gt; 0) ans[i] = nums[(i + nums[i]) % n];            else if (nums[i] &lt; 0) ans[i] = nums[((i + nums[i]) % n + n) % n];            else ans[i] = nums[i];        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3640-三段式数组II","url":"/2026/02/04/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983640-%E4%B8%89%E6%AE%B5%E5%BC%8F%E6%95%B0%E7%BB%84II/","content":"题意若一个数组先严格递增再严格递减最后再严格递增，则称其为三段式数组。给定整数数组 nums ，求其内和最大的三段式子数组。\n思路一个三段式数组需要维护四个点：首 尾 两个递增递减的转折点。我们可以维护这四个点进行一个滑动窗口，需注意到当前子段结束后当前最后一段可以作为下一个窗口的最后一段。那么求子段和就可以进行一个前缀和优化。\n同时因为数组内可能为负，因此需要额外注意处理首尾递增段的长度。\n实现class Solution {using ll = long long;static constexpr ll inf = 1ll &lt;&lt; 52;public:    long long maxSumTrionic(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        vector&lt;ll&gt; pre(n + 1);        for (int i = 0; i &lt; n; i++) {            pre[i + 1] = pre[i] + nums[i];        }        ll ans = -inf;        int l = 0, r = 0, p = 0, q = 0;        for ( ; r &lt; n; ) {            for ( ; p + 1 &lt; n &amp;&amp; nums[p + 1] &gt; nums[p]; ) {                p++;                r = max(r, p);                q = max(q, p);            }            if (l == p) {                l = p = q = r = l + 1;                continue;            }            for ( ; l + 1 &lt; p &amp;&amp; nums[l] &lt; 0; l++);            for ( ; q + 1 &lt; n &amp;&amp; nums[q + 1] &lt; nums[q]; ) {                q++;                r = max(r, q);            }            if (p == q) {                l = p = q = r = p + 1;                continue;            }            for ( ; r + 1 &lt; n &amp;&amp; nums[r + 1] &gt; nums[r]; ) {                if (l &lt; p &amp;&amp; p &lt; q &amp;&amp; q &lt; r) {                    ans = max(ans, pre[r + 1] - pre[l]);                }                r++;                if (l &lt; p &amp;&amp; p &lt; q &amp;&amp; q &lt; r) {                    ans = max(ans, pre[r + 1] - pre[l]);                }            }            if (r == q) {                l = p = q = r = q + 1;                continue;            }            l = q;            p = r;            q = r;            r = r + 1;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3637-三段式数组I","url":"/2026/02/03/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983637-%E4%B8%89%E6%AE%B5%E5%BC%8F%E6%95%B0%E7%BB%84I/","content":"题意若一个数组先严格递增再严格递减最后再严格递增，则称其为 三段式数组。给定整数数组 nums ，判断其是否为三段式数组。\n思路数据范围不大，题也不难，应该是有很多写法的，这里我是写了一个状态机。\n实现class Solution {public:    bool isTrionic(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        int cur = 0;        for (int i = 1; i &lt; n; i++) {            if (nums[i] &gt; nums[i - 1] &amp;&amp; cur == 0) cur = 1;            else if (nums[i] &gt; nums[i - 1] &amp;&amp; cur == 1) continue;            else if (nums[i] &lt; nums[i - 1] &amp;&amp; cur == 1) cur = 2;            else if (nums[i] &lt; nums[i - 1] &amp;&amp; cur == 2) continue;            else if (nums[i] &gt; nums[i - 1] &amp;&amp; cur == 2) cur = 3;            else if (nums[i] &gt; nums[i - 1] &amp;&amp; cur == 3) continue;            else cur = 4;        }        return cur == 3;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3013-将数组分成最小总代价的子数组II","url":"/2026/02/02/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983013-%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E6%9C%80%E5%B0%8F%E6%80%BB%E4%BB%A3%E4%BB%B7%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84II/","content":"题意定义数组的代价为数组的首元素大小。给定正整数数组 nums，要将其分割为 k 个连续且互不相交的子数组，同时第二个子数组的首元素与最后一个子数组的首元素距离不超过 dist。求这些子数组的总最小代价。\n思路和昨天的题目还是非常类似的，只是分割为 3 个改为了 k 个，同时限制了第二个与最后一个的距离。但思想还是非常类似的，首先第一个子数组的代价是固定的，同时第二个子数组与最后一个子数组的距离有限制，那么问题就转换为了除第一个数之外，所有的长度为 dist 的子数组中前 k - 1 小的数的和的最小值。\n求各个子段的前 k - 1 小的数，可以想到使用对顶堆进行滑动窗口，在维护一下大顶堆中的和即可。\n实现class Solution {using ll = long long;static constexpr ll inf = 1e18;public:    ll minimumCost(vector&lt;int&gt;&amp; nums, int k, int dist) {        ll ans = inf;        ll cur = 0;        int sz = 0;        priority_queue&lt;int&gt; big;        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;&gt;&gt; small;        unordered_map&lt;int, int&gt; del;        auto _deal = [&amp;]() -&gt; void {            while (!big.empty() &amp;&amp; del.count(big.top()) &amp;&amp; del[big.top()]) {                del[big.top()]--;                big.pop();            }            while (!small.empty() &amp;&amp; del.count(small.top()) &amp;&amp; del[small.top()]) {                del[small.top()]--;                small.pop();            }        };        auto _add = [&amp;](int x) -&gt; void {            _deal();            if (sz == k - 1) {                if (big.top() &lt;= x) {                    small.push(x);                } else {                    cur += x - big.top();                    small.push(big.top());                    big.pop();                    _deal();                    big.push(x);                }            } else {                big.push(x);                cur += x;                sz++;            }        };        auto _del = [&amp;](int x) -&gt; void {            _deal();            if (big.top() &lt; x) {                del[x]++;            } else {                del[x]++;                cur -= x - small.top();                big.push(small.top());                small.pop();            }            _deal();        };        int n = nums.size();        for (int l = 1, r = 1; r &lt; n; r++) {            _add(nums[r]);            if (r - l &gt; dist) _del(nums[l++]);            if (r - l == dist) ans = min(ans, cur);        }        return ans + nums.front();    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3010-将数组分成最小总代价的子数组I","url":"/2026/02/01/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983010-%E5%B0%86%E6%95%B0%E7%BB%84%E5%88%86%E6%88%90%E6%9C%80%E5%B0%8F%E6%80%BB%E4%BB%A3%E4%BB%B7%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84I/","content":"题意定义一个数组的代价为该数组的首元素。给定整数数组 nums ，将其完整划分为三个连续且无交集的子数组，使得这三个子数组总代价最小。\n思路第一个子数组的代价是无法改变的，是首个元素大小。那么问题就变成了求除首元素外 最小元素 与 次小元素 的和加上首元素。那么有许多方法，直接排序或维护两个数遍历都是可以的，这里我是直接调库了。\n实现class Solution {public:    int minimumCost(vector&lt;int&gt;&amp; nums) {        nth_element(nums.begin() + 1, nums.begin() + 2, nums.end());        return accumulate(nums.begin(),nums.begin() + 3, 0);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题744-寻找比目标字母大的最小字母","url":"/2026/01/31/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98744-%E5%AF%BB%E6%89%BE%E6%AF%94%E7%9B%AE%E6%A0%87%E5%AD%97%E6%AF%8D%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%97%E6%AF%8D/","content":"题意给定非递减字符数组 letters，找出 letters 中大于字符 target 的最小字符。\n思路数组已经排序，那么直接进行一个二分就好。\n实现class Solution {public:    char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) {        auto it = ranges::upper_bound(letters, target);        return it == letters.end() ? letters.front() : *it;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2977-转换字符串的最小成本II","url":"/2026/01/30/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982977-%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%ACII/","content":"题意给定两小写字母字符串 source 和 target ，以及两个等长小写字母字符串数组 original 和 changed ，以及一个与这两字符串数组等长的整数数组 cost 。其中 cost[i] 表示将字符串 original[i] 改为 changed[i] 的代价。每次操作可任选 source 中的子串进行修改操作，但任意操作的范围要么相同要么互不相交。求将 source 转为 target 所需的最小代价。\n思路和昨天题目非常类似但难度又非常不同。昨天单次修改为单字符，今天为修改子串，但好在限制了每次修改的子串要么相同要么互不相交。\n那么显然是要将原字符串分割为多个子串，分别进行修改操作求最小代价，那应该是进行一个 记搜 或 dp。\n进行分割后不同的字符串之间互相转换的最小代价就与昨天类似，是一个全源最短路，使用 Floyd 即可。\n剩下的问题就是如何处理分割字符串，首先想到是使用哈希，根据长度进行分组再转 Floyd，但后续 dp 操作时每增加一个字符就要哈希一次所需代价还是较大的，要么我们自行实现字符串哈希使其可以做到尾加字符时 O(1) 地计算哈希值，要么使用更高效的方法。那就可以想到使用字典树进行处理。\n实现static constexpr int N = 26;static constexpr int M = 5e5;static int tot = 1, num = 0;static array&lt;int, N + 1&gt; trie[M];static void _clear(int x) {    trie[x].fill(0);}static void _init() {    num = 0;    tot = 1;    _clear(tot);}static int _add(const string&amp; s) {    int u = 1;    for (const auto&amp; ch : s) {        int&amp; v = trie[u][ch - 'a'];        if (v == 0) {            v = ++tot;            _clear(v);        }        u = v;    }    if (trie[u][N] == 0) trie[u][N] = ++num;    return trie[u][N];}static int _nxt(int u, char ch) {    return trie[u][ch - 'a'];}class Solution {using ll = long long;static constexpr ll inf = 1e18;public:    ll minimumCost(string source, string target, vector&lt;string&gt;&amp; original, vector&lt;string&gt;&amp; changed, vector&lt;int&gt;&amp; cost) {        _init();        int n = source.size(), m = original.size();        vector&lt;int&gt; oid(m), cid(m);        for (int i = 0; i &lt; m; i++) {            oid[i] = _add(original[i]);            cid[i] = _add(changed[i]);        }        vector dis(num + 1, vector&lt;ll&gt; (num + 1, inf));        for (int i = 1; i &lt;= num; i++) dis[i][i] = 0;        for (int i = 0; i &lt; m; i++) {            ll&amp; x = dis[oid[i]][cid[i]];            x = min(x, 1ll * cost[i]);        }        for (int k = 1; k &lt;= num; k++) {            for (int i = 1; i &lt;= num; i++) {                if (dis[i][k] == inf) continue;                for (int j = 1; j &lt;= num; j++) {                    dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);                }            }        }        vector&lt;ll&gt; f(n + 1, inf);        f[n] = 0;        for (int i = n - 1; i &gt;= 0; i--) {            if (source[i] == target[i]) f[i] = f[i + 1];            int x = 1, y = 1;            for (int j = i; j &lt; n; j++) {                x = _nxt(x, source[j]);                y = _nxt(y, target[j]);                if (x == 0 || y == 0) break;                if (trie[x][N] == 0 || trie[y][N] == 0) continue;                f[i] = min(f[i], f[j + 1] + dis[trie[x][N]][trie[y][N]]);            }        }        if (f[0] == inf) return -1;        return f[0];    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2976-转换字符串的最小成本I","url":"/2026/01/29/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982976-%E8%BD%AC%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E6%88%90%E6%9C%ACI/","content":"题意给定等长小写字母字符串 source 和 target ，以及两个等长小写字符数组 original 和 changed 与一个与这两字符数组等长的整数数组 cost。对于任意 source 中字符若存在 ch=original[i] 则可令该字符花费代价 cost[i] 变为 changed[i] 。求令 source 变为 target 所需的最小代价。\n思路可以首先处理出不同字符互相转换所需的最小代价，也就是一个 26 * 26 的最短路。对于全员最短路就可以用 Floyd 算法进行处理，得到各最小代价后遍历求和即可。\n实现class Solution {using ll = long long;static constexpr ll inf = 1e18;static constexpr int N = 26;public:    ll minimumCost(string source, string target, vector&lt;char&gt;&amp; original, vector&lt;char&gt;&amp; changed, vector&lt;int&gt;&amp; cost) {        vector e(N, vector&lt;ll&gt; (N, inf));        for (int i = 0; i &lt; N; i++) e[i][i] = 0;        int n = source.size(), m = original.size();        for (int i = 0; i &lt; m; i++) {            ll&amp; x = e[original[i] - 'a'][changed[i] - 'a'];            x = min(x, 1ll * cost[i]);        }        for (int k = 0; k &lt; N; k++)        for (int i = 0; i &lt; N; i++)        for (int j = 0; j &lt; N; j++)            e[i][j] = min(e[i][j], e[i][k] + e[k][j]);                ll ans = 0;        for (int i = 0; i &lt; n; i++) {            ll c = e[source[i] - 'a'][target[i] - 'a'];            if (c == inf) return -1;            ans += c;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3651-带传送的最小路径成本","url":"/2026/01/28/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983651-%E5%B8%A6%E4%BC%A0%E9%80%81%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E6%88%90%E6%9C%AC/","content":"题意给定 m * n 的矩阵 grid 。有两种移动方式，一种为向左或向下移动到相邻格，代价为目标格子的值；另一种为传送至任意值小于等于当前位置的单元格，代价为 0，但至多传送 k 次。求从左上角到右下角所需最小代价。\n思路走格子最小代价，很自然想到使用 dp，但这里多了一个传送操作。我们观察数据范围 2 &lt;= n, m &lt;= 80 &amp;&amp; 0 &lt;= k &lt;= 10 ，这个数据范围是不大的，但搜也是不行的。但我们想到若第 i 次传送到值为 x 的格子，那么一定是来自于第 i - 1 次传送且值大于等于 x 的格子，可以想到使用一个后缀 min 维护传送最小代价，跑 k 次 dp 即可。\n实现class Solution {public:    int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) {        const int n = grid.size(), m = grid.front().size();        const int inf = 1e9;        int mx = 0;        for (const auto&amp; vec : grid) mx = max(mx, ranges::max(vec));        vector ump(k + 1, vector&lt;int&gt; (mx + 1, inf));        vector f(k + 1, vector (n, vector&lt;int&gt; (m, inf)));        f[0][0][0] = 0;        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; m; j++) {                if (i &amp;&amp; j) f[0][i][j] = min(f[0][i - 1][j], f[0][i][j - 1]) + grid[i][j];                else if (i) f[0][i][j] = f[0][i - 1][j] + grid[i][j];                else if (j) f[0][i][j] = f[0][i][j - 1] + grid[i][j];                ump[0][grid[i][j]] = min(ump[0][grid[i][j]], f[0][i][j]);            }        }        for (int t = 1; t &lt;= k; t++) {            for (int i = mx - 1; i &gt;= 0; i--) {                ump[t - 1][i] = min(ump[t - 1][i], ump[t - 1][i + 1]);            }            for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; m; j++) {                f[t][i][j] = min(f[t][i][j], ump[t - 1][grid[i][j]]);            }                        for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; m; j++) {                if (i &amp;&amp; j) f[t][i][j] = min(f[t][i][j], min(f[t][i - 1][j], f[t][i][j - 1]) + grid[i][j]);                else if (i) f[t][i][j] = min(f[t][i][j], f[t][i - 1][j] + grid[i][j]);                else if (j) f[t][i][j] = min(f[t][i][j], f[t][i][j - 1] + grid[i][j]);                ump[t][grid[i][j]] = min(ump[t][grid[i][j]], f[t][i][j]);            }        }                int ans = inf;        for (int t = 0; t &lt;= k; t++) {            ans = min(ans, f[t][n - 1][m - 1]);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3650-边反转的最小路径总成本","url":"/2026/01/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983650-%E8%BE%B9%E5%8F%8D%E8%BD%AC%E7%9A%84%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E6%80%BB%E6%88%90%E6%9C%AC/","content":"题意给定一个边有向且带权的图，权值表示为过该边的代价。同时每个节点有一个一次性开关，可用于单次地反转某条边，经过反转的边代价翻倍。问从第一个点到最后一个点所需最小代价。\n思路最短路首先想到的是迪杰斯特拉，不太一样的是我们每个结点有一个一次性反向的开关。但仔细一想，这其实是不影响的，我们每个点最多是访问一次的，开关的使用限制并不影响决策。因此我们只是多了一些双倍代价的反向边而已。\n实现class Solution {static constexpr int inf = 1e9;public:    int minCost(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {        vector&lt;vector&lt;array&lt;int, 2&gt;&gt;&gt; e(n);        for (const auto&amp; vec : edges) {            int u = vec[0], v = vec[1], w = vec[2];            e[u].push_back({v, w});            e[v].push_back({u, 2 * w});        }        vector dis(n, inf);        priority_queue&lt;array&lt;int, 2&gt;, vector&lt;array&lt;int, 2&gt;&gt;, greater&lt;&gt;&gt; pq;        pq.push({0, 0});        while (!pq.empty()) {            auto [cost, u] = pq.top();            pq.pop();            if (dis[u] &lt;= cost) continue;            dis[u] = cost;            for (const auto&amp; [v, w] : e[u]) {                if (cost + w &gt;= dis[v]) continue;                pq.push({cost + w, v});            }        }        int ans = dis[n - 1];        if (ans == inf) return -1;        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1200-最小绝对差","url":"/2026/01/26/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981200-%E6%9C%80%E5%B0%8F%E7%BB%9D%E5%AF%B9%E5%B7%AE/","content":"题意给定各不相同的整数数组 arr ，找出所有最小绝对差的元素对，升序返回。\n思路绝对差最小一定出现在排序后的相邻元素，因为排序后相邻元素之绝对差一定小于非相邻元素。故排序后遍历找最小，并记录对应数对即可。\n实现class Solution {public:    vector&lt;vector&lt;int&gt;&gt; minimumAbsDifference(vector&lt;int&gt;&amp; arr) {        vector&lt;vector&lt;int&gt;&gt; ans;        int mn = INT_MAX;        int n = arr.size();        ranges::sort(arr);        for (int i = 1; i &lt; n; i++) {            int diff = arr[i] - arr[i - 1];            if (mn &gt; diff) {                ans = {{arr[i - 1], arr[i]}};                mn = diff;            } else if (mn == diff) {                ans.push_back({arr[i - 1], arr[i]});            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1984-学生分数的最小差值","url":"/2026/01/25/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981984-%E5%AD%A6%E7%94%9F%E5%88%86%E6%95%B0%E7%9A%84%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC/","content":"题意给定整数数组 nums 表示多个学生的成绩，从中任选出 k 个学生，使得这几个学生中成绩最高与最低分差值最小化，求该最小差。\n思路所选择的学生应该是排序后连续的 k 个，因为若不连续则其差值一定更大。故排序后枚举首尾即可。\n实现class Solution {public:    int minimumDifference(vector&lt;int&gt;&amp; nums, int k) {        int n = nums.size();        ranges::sort(nums);        int ans = INT_MAX;        for (int i = 0, j = k - 1; j &lt; n; i++, j++) {            ans = min(ans, nums[j] - nums[i]);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1877-数组中最大数对和的最小值","url":"/2026/01/24/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981877-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AF%B9%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/","content":"题意给定偶长的整数数组 nums ，将其两两配对，使得最大数对和最小。\n思路最大与最小、次大与次小…这样的贪心是比较符合直觉的。证明也并不难，因为最大数若不与最小数配对，其和一定大于最大与最小和。\n实现class Solution {public:    int minPairSum(vector&lt;int&gt;&amp; nums) {        int ans = 0;        ranges::sort(nums);        int n = nums.size();        for (int l = 0, r = n - 1; l &lt; r; l++, r--) {            ans = max(ans, nums[l] + nums[r]);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3510-移除最小数对使数组有序II","url":"/2026/01/23/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983510-%E7%A7%BB%E9%99%A4%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AF%B9%E4%BD%BF%E6%95%B0%E7%BB%84%E6%9C%89%E5%BA%8FII/","content":"题意给定数组 nums ，每次操作将选择最左 相邻元素对和最小的的一对 删除，在原位置加入它们的和。求令该数组变为非递减最小的操作次数。\n思路题目与昨天是完全一样的，只是数据范围进行了扩大，数组大小从 50 扩大到了 1e5，也就是卡掉了暴力。但为我们 昨日的做法 是没有问题的。\n实现class Solution {using ll = long long;static constexpr ll inf = 1e18;public:    int minimumPairRemoval(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        set&lt;array&lt;ll, 2&gt;&gt; sum;        set&lt;array&lt;ll, 2&gt;&gt; index{{0, nums[0]}};        int cnt = 0;        for (int i = 1; i &lt; n; i++) {            index.insert({i, nums[i]});            sum.insert({nums[i] + nums[i - 1], i - 1});            cnt += nums[i - 1] &gt; nums[i];        }        int ans = 0;        while (cnt) {            ans++;            auto [s, cur] = *sum.begin();            sum.erase(sum.begin());            auto it = index.lower_bound({cur, -inf});            auto nxt = next(it);            auto [it0, it1] = *it;            auto [nxt0, nxt1] = *nxt;            cnt -= it1 &gt; nxt1;            if (it != index.begin()) {                auto [itt0 ,itt1] = *prev(it);                cnt -= itt1 &gt; it1;                cnt += itt1 &gt; s;                sum.erase({itt1 + it1, itt0});                sum.insert({itt1 + s, itt0});            }            auto itt = next(nxt);            if (itt != index.end()) {                auto [itt0, itt1] = *itt;                cnt -= nxt1 &gt; itt1;                cnt += s &gt; itt1;                sum.erase({nxt1 + itt1, nxt0});                sum.insert({s + itt1, it0});            }            index.erase(it);            index.erase(nxt);            index.insert({it0, s});        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3507-移除最小数对使数组有序I","url":"/2026/01/22/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983507-%E7%A7%BB%E9%99%A4%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AF%B9%E4%BD%BF%E6%95%B0%E7%BB%84%E6%9C%89%E5%BA%8FI/","content":"题意给定数组 nums ，每次操作将选择最左 相邻元素对和最小的的一对 删除，在原位置加入它们的和。求令该数组变为非递减最小的操作次数。\n思路我们选择维护 相邻元素和及其位置 当前剩余元素位置及其大小 相邻且递减的元素个数，模拟删除操作即可。\n实现class Solution {using ll = long long;static constexpr ll inf = 1e18;public:    int minimumPairRemoval(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        set&lt;array&lt;ll, 2&gt;&gt; sum;        set&lt;array&lt;ll, 2&gt;&gt; index{{0, nums[0]}};        int cnt = 0;        for (int i = 1; i &lt; n; i++) {            index.insert({i, nums[i]});            sum.insert({nums[i] + nums[i - 1], i - 1});            cnt += nums[i - 1] &gt; nums[i];        }        int ans = 0;        while (cnt) {            ans++;            auto [s, cur] = *sum.begin();            sum.erase(sum.begin());            auto it = index.lower_bound({cur, -inf});            auto nxt = next(it);            auto [it0, it1] = *it;            auto [nxt0, nxt1] = *nxt;            cnt -= it1 &gt; nxt1;            if (it != index.begin()) {                auto [itt0 ,itt1] = *prev(it);                cnt -= itt1 &gt; it1;                cnt += itt1 &gt; s;                sum.erase({itt1 + it1, itt0});                sum.insert({itt1 + s, itt0});            }            auto itt = next(nxt);            if (itt != index.end()) {                auto [itt0, itt1] = *itt;                cnt -= nxt1 &gt; itt1;                cnt += s &gt; itt1;                sum.erase({nxt1 + itt1, nxt0});                sum.insert({s + itt1, it0});            }            index.erase(it);            index.erase(nxt);            index.insert({it0, s});        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3315-构造最小位运算数组II","url":"/2026/01/21/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983315-%E6%9E%84%E9%80%A0%E6%9C%80%E5%B0%8F%E4%BD%8D%E8%BF%90%E7%AE%97%E6%95%B0%E7%BB%84II/","content":"题意给定质数数组 nums，求答案数组 ans 使得对于每一个下标 i 均满足 ans[i] | (ans[i] + 1) == nums[i] ，同时 ans[i] 尽可能小，若无法满足则 ans[i] == -1\n思路那与 昨天 其实是完全一样的，只是 nums[i] 的取值范围从 1e3 提高到了 1e9 ，也就是卡掉了暴力枚举的做法，但我们的做法是不受影响的。\n实现class Solution {public:    vector&lt;int&gt; minBitwiseArray(vector&lt;int&gt;&amp; nums) {        for (auto&amp; x : nums) {            if (x &amp; 1) {                for (int i = 1; ; i++) {                    if (!(x &gt;&gt; i &amp; 1)) {                        x ^= 1 &lt;&lt; (i - 1);                        break;                    }                }            } else {                x = -1;            }        }        return nums;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3314-构造最小位运算数组I","url":"/2026/01/20/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983314-%E6%9E%84%E9%80%A0%E6%9C%80%E5%B0%8F%E4%BD%8D%E8%BF%90%E7%AE%97%E6%95%B0%E7%BB%84I/","content":"题意给定质数数组 nums，求答案数组 ans 使得对于每一个下标 i 均满足 ans[i] | (ans[i] + 1) == nums[i] ，同时 ans[i] 尽可能小，若无法满足则 ans[i] == -1\n思路x 与 x + 1 一定是一奇一偶，相或则一定是奇数，所以偶数统统无解。而奇数，我们手玩几个数不难发现应转为二进制消去其尾连续 1 的最高位即可。\n实现class Solution {public:    vector&lt;int&gt; minBitwiseArray(vector&lt;int&gt;&amp; nums) {        for (auto&amp; x : nums) {            if (x &amp; 1) {                for (int i = 1; ; i++) {                    if (!(x &gt;&gt; i &amp; 1)) {                        x ^= 1 &lt;&lt; (i - 1);                        break;                    }                }            } else {                x = -1;            }        }        return nums;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1292-元素和小于等于阈值的正方形的最大边长","url":"/2026/01/19/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981292-%E5%85%83%E7%B4%A0%E5%92%8C%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E%E9%98%88%E5%80%BC%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E8%BE%B9%E9%95%BF/","content":"题意给定 m * n 的矩阵 mat 与一个整数阈值 threshold 。求最大元素和小于等于 threshold 的正方形边长。\n思路求某个矩形元素和大小，比较自然想到二维前缀和。再枚举求一下最大长即可。\n实现class Solution {public:    int maxSideLength(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int threshold) {        int n = mat.size(), m = mat.back().size();        vector pre(n + 1, vector&lt;int&gt; (m + 1));        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; m; j++) {                pre[i + 1][j + 1] = pre[i + 1][j] + pre[i][j + 1] + mat[i][j] - pre[i][j];            }        }        int ans = 0;        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; m; j++) {                for ( ; i + ans &lt;= n &amp;&amp; j + ans &lt;= m; ans++) {                    int sum = pre[i + ans][j + ans] - pre[i][j + ans] - pre[i + ans][j] + pre[i][j];                    if (sum &gt; threshold) break;                }            }        }        return ans - 1;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1895-最大的幻方","url":"/2026/01/18/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981895-%E6%9C%80%E5%A4%A7%E7%9A%84%E5%B9%BB%E6%96%B9/","content":"题意给定 m * n 的矩阵 grid ，求最大的 每一行每一列以及对角线和都相等 的正方形大小。\n思路也没什么特别好的方法，同时数据范围也比较小 1 &lt;= n, m &lt;= 50 ，进行一个暴力验证就好。\n实现class Solution {public:    int largestMagicSquare(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {        int ans = 0;        int n = grid.size(), m = grid.back().size();        auto cal = [&amp;](int x, int y) -&gt; int {            int res = 0;            vector&lt;int&gt; c, r;            for (int len = 1; ; len++) {                if (x + len &gt; n || y + len &gt; m) break;                c.push_back(0); r.push_back(0);                bool ok = true;                int f = 0, g = 0;                for (int i = 0; i &lt; len - 1; i++) {                    r.back() += grid[x + len - 1][y + i];                    c.back() += grid[x + i][y + len - 1];                }                for (int i = 0; i &lt; len; i++) {                    r[i] += grid[x + i][y + len - 1];                    c[i] += grid[x + len - 1][y + i];                    ok &amp;= (r[i] == r[0]) &amp;&amp; (c[i] == c[0]);                    f += grid[x + i][y + i];                    g += grid[x + i][y + len - 1 - i];                }                if (ok &amp;&amp; f == g &amp;&amp; f == r[0]) res = max(res, len);            }            return res;        };        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; m; j++) {                ans = max(ans, cal(i, j));            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3047-求交集区域内的最大正方形面积","url":"/2026/01/17/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983047-%E6%B1%82%E4%BA%A4%E9%9B%86%E5%8C%BA%E5%9F%9F%E5%86%85%E7%9A%84%E6%9C%80%E5%A4%A7%E6%AD%A3%E6%96%B9%E5%BD%A2%E9%9D%A2%E7%A7%AF/","content":"题意给定二维平面上的多个矩阵，用数组 bottomLeft 与 topRight 分别表示各矩阵的左下角与右上角坐标。求可放入某两矩形交集的最大正方形面积。\n思路数据范围不是很大，最多有 1e3 个不同矩阵，也没什么比较好的方法，进行一个枚举即可。枚举两个矩形的交集，求可放其中的最大正方形，再取最大。\n实现class Solution {using ll = long long;public:    ll largestSquareArea(vector&lt;vector&lt;int&gt;&gt;&amp; bottomLeft, vector&lt;vector&lt;int&gt;&gt;&amp; topRight) {        int n = bottomLeft.size();        int ans = 0;        for (int i = 0; i &lt; n; i++) {            int adx = bottomLeft[i][0], ady = bottomLeft[i][1];            int aux = topRight[i][0], auy = topRight[i][1];            for (int j = i + 1; j &lt; n; j++) {                int bdx = bottomLeft[j][0], bdy = bottomLeft[j][1];                int bux = topRight[j][0], buy = topRight[j][1];                ans = max(ans,                     min(min(aux, bux) - max(adx, bdx), min(auy, buy) - max(ady, bdy))                );            }        }        return 1ll * ans * ans;     }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2975-移除栅栏得到的正方形田地的最大面积","url":"/2026/01/16/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982975-%E7%A7%BB%E9%99%A4%E6%A0%85%E6%A0%8F%E5%BE%97%E5%88%B0%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%94%B0%E5%9C%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E9%9D%A2%E7%A7%AF/","content":"题意给定有边框的 (m - 1) * (n - 1) 矩形田地，其中有横纵栅栏用数组 hFences 与 vFences 表示栅栏的位置。可以任意移除某些栅栏，求可形成的最大正方形田地面积。\n思路要形成正方形，则横纵能空出相同长度的空地，即存在两栅栏差相等。这没有什么技巧吧，这题的数据范围也较小，进行一个暴力枚举记录横纵可能出现的长，取共有最长即可。\n实现class Solution {static constexpr int mod = 1e9 + 7;using ll = long long;public:    int maximizeSquareArea(int m, int n, vector&lt;int&gt;&amp; hFences, vector&lt;int&gt;&amp; vFences) {        hFences.push_back(1); hFences.push_back(m);        vFences.push_back(1), vFences.push_back(n);        ranges::sort(hFences); ranges::sort(vFences);        int h = hFences.size(), v = vFences.size();        unordered_set&lt;int&gt; hlen;        for (int i = 0; i &lt; h; i++)            for (int j = i + 1; j &lt; h; j++)                hlen.insert(hFences[j] - hFences[i]);                int mx = 0;        for (int i = 0; i &lt; v; i++)            for (int j = i + 1; j &lt; v; j++)                if (hlen.count(vFences[j] - vFences[i]))                    mx = max(mx, vFences[j] - vFences[i]);        if (mx == 0) return -1;        return 1ll * mx * mx % mod;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2943-最大化网格图中正方形空洞的面积","url":"/2026/01/15/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982943-%E6%9C%80%E5%A4%A7%E5%8C%96%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E6%AD%A3%E6%96%B9%E5%BD%A2%E7%A9%BA%E6%B4%9E%E7%9A%84%E9%9D%A2%E7%A7%AF/","content":"题意给定 n + 2 * m + 2 的网格图，并给定不为最上下左右的横线集合 hBars 与竖线集合 vBars。可任意删除给定集合中的线条，求可得最大中无线条的正方形面积。\n思路显然对于这些线条我们应该能删尽删，求得可行最大边长后再还原回去即可。对于可行最大边长，应为横竖集合中最长连续子段中的较小值，面积即为边长平方。\n实现class Solution {public:    int maximizeSquareHoleArea(int n, int m, vector&lt;int&gt;&amp; hBars, vector&lt;int&gt;&amp; vBars) {        ranges::sort(hBars);        ranges::sort(vBars);        auto cal = [](vector&lt;int&gt;&amp; a) -&gt; int {            int res = 1;            int n = a.size();            for (int i = 0; i &lt; n; ) {                int j = 1;                for ( ; i + j &lt; n &amp;&amp; a[i] + j == a[i + j]; j++);                res = max(res, j);                i += j;            }            return res;        };        int mn = min(cal(vBars), cal(hBars));        return (mn + 1) * (mn + 1);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3453-分割正方形II","url":"/2026/01/14/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983453-%E5%88%86%E5%89%B2%E6%AD%A3%E6%96%B9%E5%BD%A2II/","content":"题意给定数组 squares 表示多个与坐标轴平行的可能互相重叠的正方形。找到一个最小的纵坐标，使得其对应的水平线使得其上下的图形面积相等（重叠区域不重复计数）。\n思路与昨天的题目仅仅相差一个字，就是重复区域不再重复计数，但是难度就提升了非常多。因为重叠区域不好计算所以我们不能再使用二分了，只能进行一个扫描线操作。\n实现template&lt;class Info, class Tag&gt;struct SegmentTree {    int n;    vector&lt;Info&gt; info;    vector&lt;Tag&gt; tag;    SegmentTree() : n(0) {}    SegmentTree(int n_, Info v_ = Info()) {        init(n_, v_);    }    template&lt;class T&gt;    SegmentTree(vector&lt;T&gt; init_) {        init(init_);    }    void init(int n_, Info v_ = Info()) {        init(vector&lt;Info&gt;(n_, v_));    }    template&lt;class T&gt;    void init(vector&lt;T&gt; init_) {        n = init_.size();        info.assign(4 &lt;&lt; __lg(n), Info());        tag.assign(4 &lt;&lt; __lg(n), Tag());        function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) {            if (r - l == 1) {                info[p] = init_[l];                return;            }            int m = (l + r) / 2;            build(2 * p, l, m);            build(2 * p + 1, m, r);            pull(p);        };        build(1, 0, n);    }    void pull(int p) {        info[p] = info[2 * p] + info[2 * p + 1];    }    void apply(int p, const Tag &amp;v) {        info[p].apply(v);        tag[p].apply(v);    }    void push(int p) {        apply(2 * p, tag[p]);        apply(2 * p + 1, tag[p]);        tag[p] = Tag();    }    void set(int p, int l, int r, int x, const Info &amp;v) {        if (r - l == 1) {            info[p] = v;            return;        }        int m = (l + r) / 2;        push(p);        if (x &lt; m) {            set(2 * p, l, m, x, v);        } else {            set(2 * p + 1, m, r, x, v);        }        pull(p);    }    void set(int p, const Info &amp;v) {        set(1, 0, n, p, v);    }    Info query(int p, int l, int r, int x, int y) {        if (l &gt;= y || r &lt;= x) {            return Info();        }        if (l &gt;= x &amp;&amp; r &lt;= y) {            return info[p];        }        int m = (l + r) / 2;        push(p);        return query(2 * p, l, m, x, y) + query(2 * p + 1, m, r, x, y);    }    Info query(int l, int r) {        return query(1, 0, n, l, r);    }    void update(int p, int l, int r, int x, int y, const Tag &amp;v) {        if (l &gt;= y || r &lt;= x) {            return;        }        if (l &gt;= x &amp;&amp; r &lt;= y) {            apply(p, v);            return;        }        int m = (l + r) / 2;        push(p);        update(2 * p, l, m, x, y, v);        update(2 * p + 1, m, r, x, y, v);        pull(p);    }    void update(int l, int r, const Tag &amp;v) {        return update(1, 0, n, l, r, v);        }};struct Tag {    int add = 0;    void apply(Tag t) {        add += t.add;    }};struct Info {    int mi = 0;    int cnt = 0;    void apply(Tag t) {        mi += t.add;    }};Info operator+(const Info &amp;a, const Info &amp;b) {    if (a.mi &lt; b.mi) {        return a;    } else if (a.mi &gt; b.mi) {        return b;    } else {        return {a.mi, a.cnt + b.cnt};    }}using S = SegmentTree&lt;Info, Tag&gt;;class Solution {using ll = long long;public:    double separateSquares(vector&lt;vector&lt;int&gt;&gt;&amp; squares) {        vector&lt;array&lt;int, 4&gt;&gt; f;        vector&lt;int&gt; a;        for (const auto&amp; s : squares) {            int x = s[0], y = s[1], len = s[2];            a.push_back(x);            a.push_back(x + len);            f.push_back({y, x, x + len, 1});            f.push_back({y + len, x, x + len, -1});        }        ranges::sort(f);        ranges::sort(a);        int n = a.erase(unique(a.begin(), a.end()), a.end()) - a.begin();        int length = a.back() - a.front();        S StT(n);        for (int i = 0; i &lt; n - 1; i++) {            StT.set(i, {0, a[i + 1] - a[i]});        }        vector&lt;array&lt;ll, 2&gt;&gt; record;        ll cur = 0;        int m = f.size();        for (int i = 0; i &lt; m - 1; i++) {            auto [y, tl, tr, t] = f[i];            int l = ranges::lower_bound(a, tl) - a.begin();            int r = ranges::lower_bound(a, tr) - a.begin();            StT.update(l, r, {t});            auto res = StT.query(0, n);            int p = res.mi == 0 ? res.cnt : 0;            record.push_back({cur, length - p});            cur += 1ll * (length - p) * (f[i + 1][0] - y);        }        int lo = ranges::lower_bound(record, cur, {}, [](auto&amp; node) {            return node[0] * 2;        }) - record.begin() - 1;        auto [res, len] = record[lo];        return f[lo][0] + (cur - res * 2) / (len * 2.0);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3453-分割正方形I","url":"/2026/01/13/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983453-%E5%88%86%E5%89%B2%E6%AD%A3%E6%96%B9%E5%BD%A2I/","content":"题意给定数组 squares 表示多个与坐标轴平行的可能互相重叠的正方形。找到一个最小的纵坐标，使得其对应的水平线使得其上下的图形面积相等（重叠区域重复计数）。\n思路首先想到的是二分，二分水平线的位置然后根据正方形与水平线的位置关系计算某部分面积。只是这里因为面积涉及到浮点数计算，所以我们最好不要使用值域二分而是使用次数二分，主要是因为浮点数的精度误差可能导致答案误差与过多的时间开销。\n实现class Solution {using ll = long long;public:    double separateSquares(vector&lt;vector&lt;int&gt;&gt;&amp; squares) {        ll sum = 0;        for (const auto&amp; s : squares) {            sum += 1ll * s[2] * s[2];        }        double m = sum / 2.0;        auto cal = [&amp;](double h) -&gt; double {            double res = 0;            for (const auto&amp; s : squares) {                int x = s[0], y = s[1], l = s[2];                if (1.0 * (y + l) &lt;= h) res += 1.0 * l * l;                else if (1.0 * y &gt;= h) ;                else res += 1.0 * l * (h - y);            }            return res;        };        double lo = 0, hi = 1e9;        int T = 64;        while (T--) {            double mid = (lo + hi) / 2;            if (cal(mid) &gt;= m) hi = mid;            else lo = mid;        }        return lo;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1266-访问所有点的最小时间","url":"/2026/01/12/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981266-%E8%AE%BF%E9%97%AE%E6%89%80%E6%9C%89%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4/","content":"题意给定多个二维点用数组 points 表示，初始位于首个点，每秒可以沿坐标轴方向移动一个单位长度距离或斜向移动 sqrt(2) 个单位长度到相邻点。必须按给定顺序访问这些点，求到达最后一个点最少花费多少时间。\n思路必须按顺序访问，那仅需关注两点之间距离。手玩一下可以发现若两点不在同行或同列，肯定是优先使用斜向距离，最多斜向 min(abs(cur_x - nxt_x), abs(cur_y - nxt_y)) 次，到达同行或同列后沿坐标轴方向移动剩余距离即 max(abs(cur_x - nxt_x), abs(cur_y - nxt_y)) - min(abs(cur_x - nxt_x), abs(cur_y - nxt_y))。所以答案就是两者相加，横纵坐标差的最大值。\n实现class Solution {public:    int minTimeToVisitAllPoints(vector&lt;vector&lt;int&gt;&gt;&amp; points) {        int ans = 0;        int n = points.size();        int cx = points[0][0], cy = points[0][1];        for (int i = 1; i &lt; n; i++) {            int nx = points[i][0], ny = points[i][1];            ans += max(abs(nx - cx), abs(ny - cy));            cx = nx; cy = ny;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题85-最大矩形","url":"/2026/01/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9885-%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2/","content":"题意给定 01 矩阵，找出仅包含 1 的面积最大的矩形的面积。\n思路我们应该有做过类似的题，但我有点想不起来是哪题了。\n假如以某行为底，以底向上的连续 1 的个数为高，那么这题就是一个经典的 柱形图最大矩形面积。进行一个枚举中心向两边扩展可得最大面积，即做一个单调栈求每个数前后缀的第一个小于该数的位置即可。\n扩展到这个题目，就是枚举每一行，若某位置为 1 则高度加上之前累计，若为 0 则高度清零，然后做上述过程即可。\n实现class Solution {public:    int maximalRectangle(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) {        int n = matrix.size(), m = matrix.back().size();        int ans = 0;        vector&lt;int&gt; h(m);        for (const auto&amp; line : matrix) {            vector&lt;int&gt; pre(m, -1);            vector&lt;int&gt; stk;            for (int i = 0; i &lt; m; i++) {                if (line[i] == '1') h[i]++;                else h[i] = 0;                while (!stk.empty() &amp;&amp; h[stk.back()] &gt;= h[i]) stk.pop_back();                if (!stk.empty()) pre[i] = stk.back();                stk.push_back(i);             }            stk.clear();            for (int i = m - 1; i &gt;= 0; i--) {                while (!stk.empty() &amp;&amp; h[stk.back()] &gt;= h[i]) stk.pop_back();                int nxt = stk.empty() ? m : stk.back();                ans = max(ans, (nxt - pre[i] - 1) * h[i]);                stk.push_back(i);            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题712-两个字符串的最小ASCII删除和","url":"/2026/01/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98712-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%B0%8FASCII%E5%88%A0%E9%99%A4%E5%92%8C/","content":"题意给定两个字符串 s1 和 s2 ，可任意删除这两字符串中的字符，求使得两字符串相等所需删除字符的 ASCII 值的最小和。\n思路那么实际就是仅运行删除操作的编辑距离，只是代价转换为了所删除字符的 ASCII 值；或者看作最长公共子序列也是可以的。求最小删除也可以转换为最大保留，就是一个很经典的 dp 问题了。\n实现class Solution {public:    int minimumDeleteSum(string s1, string s2) {        int n = s1.size(), m = s2.size();        int sum = accumulate(s1.begin(), s1.end(), 0) + accumulate(s2.begin(), s2.end(), 0);        vector f(n + 1, vector&lt;int&gt; (m + 1));        for (int i = 1; i &lt;= n; i++) {            for (int j = 1; j &lt;= m; j++) {                if (s1[i - 1] == s2[j - 1]) {                    f[i][j] = f[i - 1][j - 1] + int(s1[i - 1]);                } else {                    f[i][j] = max(f[i - 1][j], f[i][j - 1]);                }            }        }        return sum - f[n][m] * 2;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题865-具有所有最深节点的最小子树","url":"/2026/01/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98865-%E5%85%B7%E6%9C%89%E6%89%80%E6%9C%89%E6%9C%80%E6%B7%B1%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%A0%91/","content":"题意给定一颗二叉树，求包含所有最深结点的最小子树。\n思路换而言之就是求所有最深结点的 LCA。解决树形深度问题，很容易是想到使用 dfs 求深度，同时递归的 归 过程又暗合了 LCA 的性质。\n实现/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) {} *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public:    TreeNode* subtreeWithAllDeepest(TreeNode* root) {        int mx = -1;        TreeNode* ans = nullptr;        auto dfs = [&amp;](this auto&amp;&amp; self, TreeNode* u, int dep = 0) -&gt; int {            if (u == nullptr) {                mx = max(mx, dep - 1);                return dep - 1;            }            int l = self(u-&gt;left, dep + 1);            int r = self(u-&gt;right, dep + 1);            if (l == r &amp;&amp; l == mx) {                ans = u;            }            return max(l, r);        };        dfs(root);        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1458-两个子序列的最大点积","url":"/2026/01/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981458-%E4%B8%A4%E4%B8%AA%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%82%B9%E7%A7%AF/","content":"题意给定两个整数数组 nums1 和 nums2 ，返回这两个数组中两个长度相等的非空子序列的最大点积。\n思路比较明显的是 dp，枚举两个数组中各数的乘积加上当前两数之前可得的最大点积。两个数组各数的乘积可以看作一个二维矩阵，其前可得最大点积即为当前位置左上的最大值，可以想到用前缀max维护。\n实现class Solution {static constexpr int inf = 1e9;public:    int maxDotProduct(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        int n = nums1.size(), m = nums2.size();        vector f(n + 2, vector&lt;int&gt; (m + 2, -inf));        for (int i = 1; i &lt;= n; i++) {            for (int j = 1; j &lt;= m; j++) {                f[i][j] = max(f[i][j], max(f[i - 1][j - 1], 0) + nums1[i - 1] * nums2[j - 1]);                f[i][j + 1] = max(f[i][j + 1], f[i][j]);                f[i + 1][j] = max(f[i + 1][j], f[i][j]);            }        }        return f[n][m];    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1339-分裂二叉树的最大乘积","url":"/2026/01/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981339-%E5%88%86%E8%A3%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/","content":"题意给定一棵二叉树，删除其中一条边使其变为两棵树，使得两棵树的节点和之积最大，求最大积。\n思路若 v 的父节点为 u ，我们删除边 (u, v)，显然可以得到两部分：v 及其子树、u 所在树除去 v 及其子树；所得乘积即为 v子树和 乘以 整棵树和 - v字数和。由此我们可以想到使用 dfs 求出整个树的和以及各节点子树和即可。\n实现/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) {} *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {using ll = long long;static constexpr int mod = 1e9 + 7;public:    int maxProduct(TreeNode* root) {        ll ans = 0;        int sum = 0;                auto dfs1 = [&amp;](this auto&amp;&amp; self, TreeNode* u) -&gt; int {            if (u == nullptr) return 0;            sum += u-&gt;val;            u-&gt;val += self(u-&gt;left);            u-&gt;val += self(u-&gt;right);            return u-&gt;val;        };        dfs1(root);        auto dfs2 = [&amp;](this auto&amp;&amp; self, TreeNode* u) -&gt; void {            if (u == nullptr) return;            ans = max(ans, 1ll * u-&gt;val * (sum - u-&gt;val));            self(u-&gt;left);            self(u-&gt;right);        };        dfs2(root);        return ans % mod;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1161-最大层内元素和","url":"/2026/01/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981161-%E6%9C%80%E5%A4%A7%E5%B1%82%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C/","content":"题意给定一颗二叉树，求和最大的层号。\n思路很自然想到层序遍历树的每一层以求每层和再进行比较，层序遍历就会先想到 bfs。\n实现/** * Definition for a binary tree node. * struct TreeNode { *     int val; *     TreeNode *left; *     TreeNode *right; *     TreeNode() : val(0), left(nullptr), right(nullptr) {} *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */class Solution {public:    int maxLevelSum(TreeNode* root) {        if (root == nullptr) return -1;                vector&lt;int&gt; f;        queue&lt;pair&lt;TreeNode* , int&gt;&gt; q;        q.emplace(root, 0);        while (!q.empty()) {            auto [u, d] = q.front();            q.pop();            if (u == nullptr) continue;            if (d &gt;= f.size()) f.push_back(0);            f[d] += u-&gt;val;            q.emplace(u-&gt;left, d + 1);            q.emplace(u-&gt;right, d + 1);        }        int mx = INT_MIN, ans;        for (int i = 0; i &lt; f.size(); i++) {            if (mx &lt; f[i]) {                mx = f[i];                ans = i;            }        }        return ans + 1;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1975-最大方阵和","url":"/2026/01/05/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981975-%E6%9C%80%E5%A4%A7%E6%96%B9%E9%98%B5%E5%92%8C/","content":"题意给定 n * n 的整数方阵 matrix 。每次操作可任选两个相邻元素使它们均乘以 -1。求方阵最大和。\n思路所给图像为方阵，那么任意两个数之间一定存在路径使得除首尾外所有点被选取两次，换言之我们每次可任选两个数使得其正负同时颠倒。贪心地，若负数的个数为偶数个，我们可使得所有负数变为整数，答案即为所有数的绝对值之和；若负数个数为奇数个，我们可令绝对值最小的数为负数，其余数均为正数，再求和即可。/\n实现class Solution {using ll = long long;public:    long long maxMatrixSum(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {        ll ans = 0;        int mn = INT_MAX, fmn = INT_MAX;        int fcnt = 0;        for (const auto&amp; m : matrix) {            for (auto x : m) {                if (x &gt;= 0) {                    ans += x;                    mn = min(mn, x);                } else {                    ans -= x;                    fmn = min(fmn, -x);                    fcnt++;                }            }        }        if (fcnt &amp; 1) ans -= min(fmn, mn) &lt;&lt; 1;        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1390-四因数","url":"/2026/01/04/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981390-%E5%9B%9B%E5%9B%A0%E6%95%B0/","content":"题意给定正整数数组 nums ，求其中恰有四个因数的整数的所有因素和。\n思路数据范围不是很大 1 &lt;= nums.size() &lt;= 1e4 1 &lt;= nums[i] &lt;= 1e5。那我们可以先预处理出范围内所有数的因子个数，再求出各个数的因子和即可。\n实现static constexpr int N = 1e5;int fac_cnt[N + 1];int fac_sum[N + 1];int init = []() {    for (int i = 1; i &lt;= N; i++) {        for (int j = i; j &lt;= N; j += i) {            fac_cnt[j]++;            fac_sum[j] += i;        }    }    return 0;} ();class Solution {public:    int sumFourDivisors(vector&lt;int&gt;&amp; nums) {        int ans = 0;        for (int x : nums) {            if (fac_cnt[x] == 4) ans += fac_sum[x];        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1411-给Nx3网格图涂色的方案数","url":"/2026/01/03/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981411-%E7%BB%99Nx3%E7%BD%91%E6%A0%BC%E5%9B%BE%E6%B6%82%E8%89%B2%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/","content":"题意给定 n * 3 的网格，仅能使用三种不同的颜色，要求每个格子与其相邻的格子颜色不同。求问有多少种涂色方式。\n思路很明显是一个dp的问题，问题是怎么dp呢。\n我们先想想若仅有 1 * 3 的网格有多少种涂色方式呢，这里我们用0、1、2分别表示不同的颜色。\n010 020 121 101 212 202012 021 102 120 201 210\n\n显然是仅有以上 12 种情况，同时可以归纳为两种类型 ABA 与 ABC 型，即首尾相同与首尾不同的类型。\n在归纳的基础上推导下一行合法的种类，显然一个 ABA 型下一行可以存在 3 个 ABA 型与 2 个 ABC 型；一个 ABC 型下一行可以存在 2 个 ABA 型与 2 个 ABC 型。\n由此可以得到每行的递推公式。\n实现class Solution {using ll = long long;static constexpr int mod = 1e9 + 7;public:    int numOfWays(int n) {        ll f = 6, g = 6;        for (int i = 1; i &lt; n; i++) {            ll nf = (3 * f + 2 * g) % mod;            ll ng = (2 * f + 2 * g) % mod;            f = nf; g = ng;        }        return (f + g) % mod;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题961-在长度2N的数组中找出重复N次的元素","url":"/2026/01/02/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98961-%E5%9C%A8%E9%95%BF%E5%BA%A62N%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8DN%E6%AC%A1%E7%9A%84%E5%85%83%E7%B4%A0/","content":"题意给定偶长的整数数组 nums，其中有 nums.size() / 2 + 1 种元素，有一个元素恰重复了 nums.size() / 2 次，找到这个重复多次的元素。 \n思路第一反应答案是绝对众数，那直接上摩尔投票就好。 WA 一发后才想起来摩尔投票要求所求数的出现次数严格大于 ceil(nums.size() / 2)，这里就不太适用了。但是仔细一想，还是可以用的，我们再仔细看看题目，可以注意到有且仅有答案出现了多次，其余数均只出现了一次；我们先排除掉首项，若首项为答案则剩余部分首项一定再出现一次则直接返回首项即可；若首项不为答案，剩余部分就满足了摩尔投票的使用条件。\n实现class Solution {public:    int repeatedNTimes(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        int ans = -1, cnt = 0;        for (int i = 1; i &lt; n; i++) {            if (nums[i] == nums.front()) return nums.front();            if (cnt == 0) ans = nums[i];            if (nums[i] == ans) cnt++;            else cnt--;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题66-加一","url":"/2026/01/01/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9866-%E5%8A%A0%E4%B8%80/","content":"题意给定整数数组 digit 表示一个大整数的各个数位。令该大整数加 1 ，返回表示结果的数位数组。\n思路那么是一个非常简单的模拟题，模拟一下加法中的进位过程即可。具体的就是在最后一位加上一，然后从低到高位检查每一位是否大于等于 10 ，若是则令该位减 10 然后给下一位进行进位即可。仅需注意最高位若需进位则需让数组多一个元素即可。\n实现class Solution {public:    vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) {        int n = digits.size();        digits.back() += 1;        for (int i = n - 1; i &gt; 0; i--) {            if (digits[i] &gt;= 10) {                digits[i] -= 10;                digits[i -  1]++;            }        }        if (digits[0] &gt;= 10) {            digits[0] -= 10;            digits.insert(digits.begin(), 1);        }        return digits;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1970-你能穿过矩阵的最后一天","url":"/2025/12/31/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981970-%E4%BD%A0%E8%83%BD%E7%A9%BF%E8%BF%87%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/","content":"题意给定 row * col 大小的陆地，每天都会有一个新的陆地变为水域用数组 cells 表示。可任选最上面一行的某个陆地位置出发，每次可以往上下左右任意相邻的陆地格子移动。问哪一天是可以从最上面一行陆地走到最下面一行陆地的最后一天。\n思路那方法还是有很多的，与时间相关最简单的方法还是想到使用二分，二分时间然后进行检查，检查就是一个很常规的联通性问题，bfs dfs都是可以的。\n也可以换一个角度想，从最后一天往前推，即为全是水域的矩阵每天会多一块陆地。那么第一次使得最上最下两行联通的天数即为答案。联通性问题很自然可以想到使用并查集进行维护，每一块陆地可以使得其上下左右的陆地联通。\n实现class Solution {static constexpr array&lt;int, 2&gt; nxt[] = {    {0, 1}, {0, -1}, {1, 0}, {-1, 0}};public:    int latestDayToCross(int row, int col, vector&lt;vector&lt;int&gt;&gt;&amp; cells) {        int n = cells.size();        auto check = [&amp;](int t) -&gt; bool {            vector mp(row, vector&lt;int&gt; (col));            for (int i = 0; i &lt;= t; i++) {                mp[cells[i][0] - 1][cells[i][1] - 1] = 1;            }            queue&lt;array&lt;int, 2&gt;&gt; q;            for (int i = 0; i &lt; col; i++) {                if (mp[0][i] == 0) q.push({0, i});            }            while (!q.empty()) {                auto [x, y] = q.front();                q.pop();                if (mp[x][y] != 0) continue;                if (x == row - 1) return true;                mp[x][y] = 2;                for (auto [tx, ty] : nxt) {                    int nx = tx + x, ny = ty + y;                    if (nx &lt; 0 || nx &gt;= row || ny &lt; 0 || ny &gt;= col || mp[nx][ny] != 0) continue;                    q.push({nx, ny});                }            }            return false;        };        int lo = 0, hi = n - 1;        while (lo &lt; hi) {            int mid = (lo + hi + 1) / 2;            if (check(mid)) lo = mid;            else hi = mid - 1;        }        return lo + 1;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题840-矩阵中的幻方","url":"/2025/12/30/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98840-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E5%B9%BB%E6%96%B9/","content":"题意给定矩阵 grid ，求其内存在几个幻方。幻方定义为 3 * 3 的矩阵，同时每一行每一列每个对角线的和相同，同时数字 1 ~ 9 均出现且仅出现一次。\n思路也没什么好的办法，就进行一个求每行每列和进行检查的暴力就好。只是为了方便实现，可以数学推导一下，首先 1 ~ 9 均出现且仅出现一次则和为 45 ，每行列对角线和相同则均为 45 / 3 == 15，由此可以稍微简化一下实现的复杂度。\n实现class Solution {public:    int numMagicSquaresInside(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {        int n = grid.size(), m = grid.back().size();        int ans = 0;        auto check = [&amp;](int i, int j) -&gt; bool {            if (grid[i - 1][j - 1] != 5) return false;            int mask = 0;            for (int x = 0; x &lt; 3; x++) {                int c = 0, r = 0;                for (int y = 0; y &lt; 3; y++) {                    mask |= 1 &lt;&lt; grid[i - x][j - y];                    c += grid[i - x][j - y];                    r += grid[i - y][j - x];                }                if (c != 15 || r != 15) return false;            }            return mask == 1022;        };        for (int i = 2; i &lt; n; i++)             for (int j = 2; j &lt; m; j++)                 ans += check(i, j);        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题756-金字塔转换矩阵","url":"/2025/12/29/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98756-%E9%87%91%E5%AD%97%E5%A1%94%E8%BD%AC%E6%8D%A2%E7%9F%A9%E9%98%B5/","content":"题意给定一堆长度为 3 的字符串 allowed 表示一些可选的字母三角形。同时给出一个字符串 bottom 表示一个金字塔底座。求问给定的 allowed 与 bottom 是否可以补全出一个完整的金字塔，使得该金字塔每一个小三角形均可在 allowed 中找到。\n思路数据范围实在很小，2 &lt;= bottom.length() &lt;= 6 &amp;&amp; 0 &lt;= allow.length() &lt;= 216 &amp;&amp; 所有字符来自 {'A', 'B', 'C', 'D', 'E', 'F'}\n那咱们直接进行一个暴搜就好，根据底座一层层往上枚举可选的字符，直到到顶或无可选字符。\n实现class Solution {static constexpr int N = 6;public:    bool pyramidTransition(string bottom, vector&lt;string&gt;&amp; allowed) {        int n = bottom.size();        bool ans = false;        vector&lt;string&gt; f(N, \"######\");        vector allow(N, vector&lt;string&gt; (N));        for (const auto&amp; s : allowed) {            allow[s[0] - 'A'][s[1] - 'A'] += s[2];        }        for (int i = 0; i &lt; n; i++) f[0][i] = bottom[i];        auto dfs = [&amp;](this auto&amp;&amp; self, int i, int j) -&gt; void {            if (i == n - 1) {                ans = true;                return;            }            if (allow[f[i][j - 1] - 'A'][f[i][j] - 'A'].empty()) return;            for (auto&amp; ch : allow[f[i][j - 1] - 'A'][f[i][j] - 'A']) {                f[i + 1][j - 1] = ch;                if (j == n - i - 1) self(i + 1, 1);                else self(i, j + 1);                if (ans) return;            }        };        dfs(0, 1);        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1351-统计有序矩阵中的负数","url":"/2025/12/28/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981351-%E7%BB%9F%E8%AE%A1%E6%9C%89%E5%BA%8F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B4%9F%E6%95%B0/","content":"题意给定二维整数矩阵 grid，其中各行各列均以非严格递减的顺序排列。统计其中负数的数量。\n思路数据范围并不大，可以直接进行一个暴力遍历。\n但题目已经保证了各行各列均递减排序，那么其实有着非常好的性质。比如一个数若是负数，则其所在列行数大于其的数均为负数；若一个数为正数，则其左上的元素一定为正数。由此优化一下遍历方式即可。\n实现class Solution {public:    int countNegatives(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {        int n = grid.size(), m = grid.back().size();        int ans = 0;        for (int i = 0, j = m - 1; i &lt; n &amp;&amp; j &gt;= 0; ) {            if (grid[i][j] &gt;= 0) {                i++;            } else {                ans += n - i;                j--;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2402-会议室III","url":"/2025/12/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982402-%E4%BC%9A%E8%AE%AE%E5%AE%A4III/","content":"题意有 n 个会议室，同时给出多个会议的开始与结束时间用数组 meetings 表示。每场会议会在未占用且编号最小的会议室举办；若当前无可用会议室则会议延期直到有空会议室，且会议时长不会改变；若有多个会议均处于延期状态会优先分配给原定开始时间最早的会议。求举办最多次会议的会议室编号。\n思路那么我们模拟一下会议分配的过程就好了，对于在开会议的会议室根据其结束时间进行排序，同时维护空闲的会议室，按开始时间的顺序给各个会议分配会议室，最终统计各个会议室开会次数即可。\n实现class Solution {using ll = long long;public:    int mostBooked(int n, vector&lt;vector&lt;int&gt;&gt;&amp; meetings) {        vector&lt;int&gt; cnt(n);        priority_queue&lt;pair&lt;ll, int&gt;, vector&lt;pair&lt;ll, int&gt;&gt;, greater&lt;&gt;&gt; busy;        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;&gt;&gt; free;        for (int i = 0; i &lt; n; i++) free.push(i);        ranges::sort(meetings);        for (auto&amp; m : meetings) {            ll s = m[0], e = m[1];            while (!busy.empty() &amp;&amp; busy.top().first &lt;= s) {                free.push(busy.top().second);                busy.pop();            }            if (free.empty()) {                auto [t, id] = busy.top();                busy.pop();                cnt[id]++;                busy.push({t + e - s, id});            } else {                int id = free.top();                free.pop();                cnt[id]++;                busy.push({e, id});            }        }        int mx = 0, ans = 0;        for (int i = 0; i &lt; n; i++) {            if (cnt[i] &gt; mx) {                mx = cnt[i];                ans = i;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2483-商店的最少代价","url":"/2025/12/26/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982483-%E5%95%86%E5%BA%97%E7%9A%84%E6%9C%80%E5%B0%91%E4%BB%A3%E4%BB%B7/","content":"题意给定字符串 customers 表示每时刻是否有顾客到来，在初始商店是营业的，可任选一个时刻关闭商店不再营业。若营业期间某时刻无客到来则代价加一，若歇业期间某时刻有客到来则代价加一。求代价最小的前提下最早的关门时间。\n思路某时刻关门的代价为：关门之前的无客数量与关门后的有客数量之和。进行一个前后缀处理前后信息即可。\n实现class Solution {public:    int bestClosingTime(string customers) {        int n = customers.size();        int ans = 0, mn = n;        vector&lt;int&gt; suf(n + 1);        for (int i = n - 1; i &gt;= 0; i--) {            suf[i] = suf[i + 1] + (customers[i] == 'Y');        }        for (int i = 0, c = 0; i &lt;= n; i++) {            int cur = c + suf[i];            if (cur &lt; mn) {                mn = cur;                ans = i;            }            c += customers[i] == 'N';        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3075-幸福值最大化的选择方案","url":"/2025/12/25/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983075-%E5%B9%B8%E7%A6%8F%E5%80%BC%E6%9C%80%E5%A4%A7%E5%8C%96%E7%9A%84%E9%80%89%E6%8B%A9%E6%96%B9%E6%A1%88/","content":"题意给定多个小孩的幸福值用非负整数数组 happiness 表示。用 k 轮筛选出 k 个孩子，每一轮中所有未被选中的孩子幸福值减一但不会降至负数。求可获得的最大幸福值之和。\n思路比较明显是进行一个从大到小贪 k 个孩子就好。\n实现class Solution {using ll = long long;public:    long long maximumHappinessSum(vector&lt;int&gt;&amp; happiness, int k) {        ll ans = 0;        int n = happiness.size();        ranges::sort(happiness, greater());        for (int i = 0; i &lt; n &amp;&amp; k; i++, k--) {            happiness[i] -= i;            if (happiness[i] &lt;= 0) break;            ans += happiness[i];        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3074-重新分装苹果","url":"/2025/12/24/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983074-%E9%87%8D%E6%96%B0%E5%88%86%E8%A3%85%E8%8B%B9%E6%9E%9C/","content":"题意给定正整数数组 apple 和 capacity 分别表示多袋苹果的苹果个数与多个箱子可容纳苹果的个数。求最少需要多少个箱子可将所有苹果装完。\n思路每袋的苹果均可以拆分开来装入不同箱子，那显然就是简单的贪心操作，从大到小排序遍历箱子，第一个前缀和大于苹果数量的即为答案。\n实现class Solution {public:    int minimumBoxes(vector&lt;int&gt;&amp; apple, vector&lt;int&gt;&amp; capacity) {        int n = capacity.size();        int sum = accumulate(apple.begin(), apple.end(), 0);        ranges::sort(capacity, greater());        for (int i = 0, cur = 0; i &lt; n; i++) {            cur += capacity[i];            if (cur &gt;= sum) return i + 1;        }        return -1;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2054-两个最好的不重叠活动","url":"/2025/12/23/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982054-%E4%B8%A4%E4%B8%AA%E6%9C%80%E5%A5%BD%E7%9A%84%E4%B8%8D%E9%87%8D%E5%8F%A0%E6%B4%BB%E5%8A%A8/","content":"题意给定多个活动的开始结束时间及其价值用数组 envents 表示，最多同时参加两个时间不重叠的活动，求可参加活动的价值最大和。\n思路有蛮多实现方法的，比如按结束时间排序后维护已结束活动然后进行二分。这里我选择对时间离散化后进行一个后缀max，维护每个时间点之后开始的活动可得的最大价值，然后枚举结束时间，求最大即可。\n实现class Solution {public:    int maxTwoEvents(vector&lt;vector&lt;int&gt;&gt;&amp; events) {        vector&lt;int&gt; t;        for (auto&amp; e : events) {            t.push_back(e[0]);            t.push_back(e[1]);        }        ranges::sort(t);        int m = t.erase(unique(t.begin(), t.end()), t.end()) - t.begin();        vector&lt;int&gt; f(m + 1);        for (auto&amp; e : events) {            int it = ranges::lower_bound(t, e[0]) - t.begin();            f[it] = max(f[it], e[2]);        }        for (int i = m - 1; i &gt;= 0; i--) f[i] = max(f[i], f[i + 1]);        int ans = 0;        for (auto&amp; e : events) {            int it = ranges::lower_bound(t, e[1]) - t.begin();            ans = max(ans, f[it + 1] + e[2]);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题960-删列造序III","url":"/2025/12/22/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98960-%E5%88%A0%E5%88%97%E9%80%A0%E5%BA%8FIII/","content":"题意给定多个等长字符串组成的数组 strs ，将这些字符串排成列，每次操作可以任意删除所有字符串某一列的字母。若想使得操作后所有的字符串中所有剩余字母按升序排序，即每行字符升序排序，最少需要多少次操作。\n思路乍一看好难，细一想确实好难，想不到什么特别棒的方法。但仔细一看数据范围 1 &lt;= strs.size() &lt;= 100 1 &lt;= strs[i].size() &lt;= 100 ，那其实就很好做了。将其视作一个最长递增子序列，只是比较函数需要重载一下即可，用 dp 的方式去写， 1 &lt;= strs.size() * strs.size() * strs[i].size() &lt;= 1e6 显然是可以接受的。\n实现class Solution {public:    int minDeletionSize(vector&lt;string&gt;&amp; strs) {        int n = strs.size(), m = strs.back().size();        vector&lt;int&gt; f(m, 1);        auto x_leq_y = [&amp;](int x, int y) -&gt; bool {            for (int i = 0; i &lt; n; i++) {                if (strs[i][x] &gt; strs[i][y]) return false;            }            return true;        };        for (int i = 0; i &lt; m; i++) {            for (int j = 0; j &lt; i; j++) {                if (x_leq_y(j, i)) {                    f[i] = max(f[i], f[j] + 1);                }            }        }        return m - ranges::max(f);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题955-删列造序II","url":"/2025/12/21/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98955-%E5%88%A0%E5%88%97%E9%80%A0%E5%BA%8FII/","content":"题意给定多个等长字符串组成的数组 strs ，将这些字符串排成列，每次操作可以任意删除所有字符串某一列的字母，若想使所有字符串按字典序升序排序，最少需要多少次操作。\n思路和昨天的题目还是非常类似的，只是昨天要求为每列均升序，今天要求为整个字符串升序。那只需维护每个字符串剩余的部分进行遍历检查即可。\n实现class Solution {public:    int minDeletionSize(vector&lt;string&gt;&amp; strs) {        int ans = 0;        int n = strs.size(), m = strs.back().size();        vector&lt;string&gt; pre(n);        for (int i = 0; i &lt; m; i++) {            bool del = false;            for (int j = 1; j &lt; n; j++) {                if (pre[j] + strs[j][i] &lt; pre[j - 1] + strs[j - 1][i]) {                    ans++;                    del = true;                    break;                }            }            if (!del) {                for (int j = 0; j &lt; n; j++) pre[j] += strs[j][i];            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题944-删列造序","url":"/2025/12/20/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98944-%E5%88%A0%E5%88%97%E9%80%A0%E5%BA%8F/","content":"题意给定由等长字符串组成的数组 strs ，将这些字符串排成列，删除其中不是非严格递增的列，求总共需要删除多少列。\n思路遍历检查每个列是否为递增的即可。\n实现class Solution {public:    int minDeletionSize(vector&lt;string&gt;&amp; strs) {        int n = strs.size(), m = strs.back().size();        int ans = 0;        for (int i = 0; i &lt; m; i++) {            for (int j = 1; j &lt; n; j++) {                if (strs[j][i] &lt; strs[j - 1][i]) {                    ans++;                    break;                }            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2092-找出知晓秘密的所有专家","url":"/2025/12/19/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982092-%E6%89%BE%E5%87%BA%E7%9F%A5%E6%99%93%E7%A7%98%E5%AF%86%E7%9A%84%E6%89%80%E6%9C%89%E4%B8%93%E5%AE%B6/","content":"题意给定数组 meetings 表示多个会议，其中 meeting[i] = [x_i, y_i, time_i] 表示在 time_i 时 x_i 与 y_i 处于同一个会议。每人可以同时参与多个会议，若会议中有人知道秘密则所有参会者均会知道秘密，同时秘密的传播是瞬时的，所有人均可在知道秘密的瞬间向其他人分享秘密。初始有 0 与 firstPerson 知道秘密，求开完所有会后所有知道秘密的人。\n思路参加同一个会议就可以知道秘密，由此我们可以比较自然的想到使用并查集处理每个会议，将所有参与同一个会议的人合并起来，最终与 0 同处一个并查集即表示其知道秘密。\n但仔细一想，是有些疏漏的，并查集不具备时间的属性，而会议是有的。比如：甲乙开会时无人知晓秘密，但会将其合入同一并查集，之后乙与指导秘密的丙开会，则使得甲乙丙同处一个并查集但实际应仅有乙丙知道秘密。所以我们需要使用到撤销合并的操作，此处相对比较简单，我们仅关心每人是否知道了秘密，所以不用上太高级的内容，只需合并过后检查其是否会知晓秘密即是否与 0 同集即可，若不知晓则撤销该操作即将其父节点设为自己即可。同时我们需要将会议按时间进行排序，顺序的去处理每个会议，同时因秘密可以瞬时传播，所以我们需一起处理同时发生的所有会议。\n实现struct DSU {\tvector&lt;int&gt; fa, sz;\tDSU() {}\tDSU(int n) {\t\tinit(n);\t}\tvoid init(int n) {\t\tfa.resize(n);\t\tiota(fa.begin(), fa.end(), 0);\t\tsz.assign(n, 1);\t}\tint find(int x) {\t\twhile(x != fa[x]) {\t\t\tx = fa[x] = fa[fa[x]];\t\t}\t\treturn x;\t}\tbool same(int x, int y) {\t\treturn find(x) == find(y);\t}\tbool merge(int x, int y) {\t\tx = find(x); y = find(y);\t\tif(x == y) return false;\t\tsz[x] += sz[y];\t\tfa[y] = x;\t\treturn true;\t}\tint size(int x) {\t\treturn sz[find(x)];\t}};class Solution {public:    vector&lt;int&gt; findAllPeople(int n, vector&lt;vector&lt;int&gt;&gt;&amp; meetings, int firstPerson) {        DSU dsu(n);        int m = meetings.size();        ranges::sort(meetings, [&amp;](const auto&amp; x, const auto&amp; y) {            return x[2] &lt; y[2];        });        dsu.merge(0, firstPerson);        for (int i = 0; i &lt; m; ) {            int j = i;            for ( ; j &lt; m &amp;&amp; meetings[j][2] == meetings[i][2]; j++) {                int x = meetings[j][0], y = meetings[j][1];                dsu.merge(x, y);            }            for (int k = i; k &lt; j; k++) {                int x = meetings[k][0], y = meetings[k][1];                if (!dsu.same(x, 0)) {                    dsu.fa[x] = x;                    dsu.fa[y] = y;                }            }            i = j;        }        vector&lt;int&gt; ans;        for (int i = 0; i &lt; n; i++) {            if (dsu.same(i, 0)) ans.push_back(i);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3652-按策略买卖股票的最佳时机","url":"/2025/12/18/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983652-%E6%8C%89%E7%AD%96%E7%95%A5%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/","content":"题意给定整数数组 prices 和 strategy 分别表示每日股价与每日操作策略，其中每日策略有买入/卖出/持有三种。同时给定偶数 k ，可以对 strategy 进行最多一次修改：选择连续 k 天的策略，将前 k / 2 天操作均修改为持有，将后 k / 2 天操作均改为卖出。假定没有预算与持股等限制，求可获最大利润。\n思路修改某个子区间的操作，可以想到使用前缀和处理记录当前位置之前均改为持有以及均改为卖出对最终利润的影响。再通过枚举修改区间的左右边界进行求利润最大即可。\n实现class Solution {using ll = long long;public:    long long maxProfit(vector&lt;int&gt;&amp; prices, vector&lt;int&gt;&amp; strategy, int k) {        const int n = prices.size();        ll ans = 0;        vector&lt;ll&gt; hold(n + 1), sole(n + 1);        for (int i = 0; i &lt; n; i++) {            if (strategy[i] == 1) {                ans += prices[i];                hold[i + 1] = hold[i] - prices[i];                sole[i + 1] = sole[i];            } else if (strategy[i] == 0) {                sole[i + 1] = sole[i] + prices[i];                hold[i + 1] = hold[i];            } else {                ans -= prices[i];                hold[i + 1] = hold[i] + prices[i];                sole[i + 1] = sole[i] + prices[i] * 2;             }        }        ll mx = 0;        for (int l = 0, m = k / 2 - 1, r = k - 1; r &lt; n; l++, m++, r++) {            mx = max(mx, hold[m + 1] - hold[l] + sole[r + 1] - sole[m + 1]);        }        return ans + mx;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3573-买卖股票的最佳时机V","url":"/2025/12/17/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983573-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BAV/","content":"题意给定正整数数组 prices 表示每天的股票价格，同时我们仅能进行 k 笔交易，可进行如下类型的交易：\n\n普通交易：第 i 天买入，第 j 天卖出，获利 prices[j] - prices[i]\n做空交易：第 i 天卖出，第 j 天买入，获利 prices[i] - prices[j]\n\n必须在当前交易结束后才可进行下一笔交易，求可获最大总利润。\n思路数据范围比较合适，同时状态间的转移关系也比较明显，还是可以比较自然想到使用dp的。\n我们最多可以进行 k 笔交易，即最多可以买入 k 次卖出 k 次，因此我们可以将 k 次交易拆分为 2 * k 次操作，这样方便进行状态的转移。\n同时我们有两种交易方式，那么我们其实仅有 3 种不同状态：1. 上一交易已完成可以任意开始下一交易； 2. 正在进行普通交易，已买入股票等待卖出； 3. 正在进行做空交易，已卖出股票等待买入。状态1通过开始对应交易进入对应交易状态，状态23通过完成当前交易回到状态1。最终答案显然是取状态1的最大值即可。\n实现class Solution {using ll = long long;static constexpr ll inf = 1e18;public:    ll maximumProfit(vector&lt;int&gt;&amp; prices, int k) {        int n = prices.size();        vector&lt;array&lt;ll, 3&gt;&gt; f(2 * k + 1, {-inf, -inf, -inf});        f[0][0] = 0;        for (int i = 0; i &lt; n; i++) {            for (int j = min(2 * k, i + 1); j &gt; 0; j--) {                f[j][0] = max({f[j][0], f[j - 1][1] + prices[i], f[j - 1][2] - prices[i]});                f[j][1] = max(f[j][1], f[j - 1][0] - prices[i]);                f[j][2] = max(f[j][2], f[j - 1][0] + prices[i]);            }        }        ll ans = -inf;        for (int i = 0; i &lt;= 2 * k; i++) {            ans = max(ans, f[i][0]);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3562-折扣价交易股票的最大利润","url":"/2025/12/16/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983562-%E6%8A%98%E6%89%A3%E4%BB%B7%E4%BA%A4%E6%98%93%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/","content":"题意给定长度为 n 的数组 present 与 future 表示这 n 个员工当天购买股票的价格与明天可以卖出的价格。同时给出二维数组 hierarchy 表示员工之间直接的上下属关系。若某员工的直系上司购买了股票，则该员工可半价购买。在给定预算 budget 下，该公司的最大利润是多少。\n思路员工间的上下属关系可以转换为一棵树。那在不用考虑预算的情况下，显然是进行一个树形dp即可：递归处理每个结点，根据当前结点是否可以半价购买进行状态转移。\n但加上预算要求应该怎么做呢，首先想到增加一个维度用来处理预算。记当前结点为 u 购买价格为 c 还剩预算 x ，若购买当前结点则所有子树剩余预算为 c - x 且直接的子节点可以半价购买；若不购买当前结点则剩余预算为 c 且直接的子节点只能原价购买。若所有子节点已经处理完毕，显然是要做一个树上背包的操作处理得到当前结点的最大价值。\n实现class Solution {public:    int maxProfit(int n, vector&lt;int&gt;&amp; present, vector&lt;int&gt;&amp; future, vector&lt;vector&lt;int&gt;&gt;&amp; hierarchy, int budget) {        vector&lt;vector&lt;int&gt;&gt; e(n);        for (const auto&amp; h : hierarchy) {            int u = h[0], v = h[1];            u--; v--;            e[u].push_back(v);        }        vector f(n, vector&lt;array&lt;int, 2&gt;&gt; (budget + 1));        vector g(n, vector&lt;array&lt;int, 2&gt;&gt; (budget + 1));        auto dfs = [&amp;](this auto&amp;&amp; self, int u) -&gt; void {            for (auto v : e[u]) {                self(v);                for (int i = budget; i &gt;= 0; i--) {                    for (int j = 0; j &lt;= i; j++) {                        for (int k = 0; k &lt; 2; k++) {                            f[u][i][k] = max(f[u][i][k], f[u][i - j][k] + g[v][j][k]);                        }                    }                }            }            for (int i = 0; i &lt;= budget; i++) {                for (int k = 0; k &lt; 2; k++) {                    int c = k ? present[u] / 2 : present[u];                    if (i &gt;= c) {                        g[u][i][k] = max(f[u][i][0], f[u][i - c][1] + future[u] - c);                    } else {                        g[u][i][k] = f[u][i][0];                    }                }            }        };        dfs(0);        return g[0][budget][0];    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2110-股票平滑下跌阶段的数目","url":"/2025/12/15/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982110-%E8%82%A1%E7%A5%A8%E5%B9%B3%E6%BB%91%E4%B8%8B%E8%B7%8C%E9%98%B6%E6%AE%B5%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定正整数数组 prices 表示某支股票的历史股价。若连续一天或多天每日股价比前一日股价恰好少 1 则称该阶段为平滑下降阶段。求所有平滑下降阶段的数目。\n思路那好像是有写过几次很类似的题目了。咱们直接进行一个滑动窗口求出当前最长平滑下降阶段，再用等差数列求和公式求出该段总贡献即可。\n实现class Solution {using ll = long long;public:    ll getDescentPeriods(vector&lt;int&gt;&amp; prices) {        ll ans = 0;        int n = prices.size();        for (int i = 0; i &lt; n; ) {            int j = i + 1;            for ( ; j &lt; n &amp;&amp; prices[j] == prices[j - 1] - 1; j++);            ans += 1ll * (j - i + 1) * (j - i) / 2;            i = j;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2147-分隔长廊的方案数","url":"/2025/12/14/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982147-%E5%88%86%E9%9A%94%E9%95%BF%E5%BB%8A%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/","content":"题意给定一条由座位与植物组成的长廊，需往其间空隙上放屏风使得长廊被分割为若干个恰有两座位的子段。求有多少种不同放置方案。\n思路假如我们先把所有的植物移除，那么放置方案显然是确定且唯一的。那不同的放置方案实际上就是，将座位按连续的两两分组，不同组之间的空隙数量之积。简单模拟计算即可。\n实现class Solution {static constexpr int mod = 1e9 + 7;public:    int numberOfWays(string corridor) {        int n = corridor.size();        int ans = 1, t = 0, last = -1;        for (int i = 0; i &lt; n; i++) {            if (corridor[i] == 'S') {                t++;                if (t &gt; 2 &amp;&amp; (t &amp; 1)) {                    ans = 1ll * ans * (i - last) % mod;                }                last = i;            }        }        if ((t &amp; 1) || t == 0) return 0;        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3606-优惠券校验器","url":"/2025/12/13/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983606-%E4%BC%98%E6%83%A0%E5%88%B8%E6%A0%A1%E9%AA%8C%E5%99%A8/","content":"题意给定三个等长数组 code、businessLine 和 isActive 分别表示多个优惠券的标识符、业务类别以及有效状态。若一个优惠券的标识符仅由字母数字与下划线组成，且业务类别属于 electronics /grocery/pharmacy/restaurant  之一，同时处于有效状态则称该优惠券有效。返回所有有效优惠券的标识符，以业务类型进行排序，相同业务类型的优惠券按标识符字典序升序排序。\n思路也没什么特别的做法，就是遍历优惠券，按题设条件判断其是否有效，分组排序后合并即可。\n实现unordered_map&lt;string, int&gt; s2i = {    {\"electronics\", 0}, {\"grocery\", 1}, {\"pharmacy\", 2}, {\"restaurant\", 3}};class Solution {public:    vector&lt;string&gt; validateCoupons(vector&lt;string&gt;&amp; code, vector&lt;string&gt;&amp; businessLine, vector&lt;bool&gt;&amp; isActive) {        vector&lt;vector&lt;string&gt;&gt; s(4);        int n = code.size();        for (int i = 0; i &lt; n; i++) {            if (isActive[i] &amp;&amp; s2i.count(businessLine[i])) {                bool ok = !code[i].empty();                for (auto&amp; ch : code[i]) {                    if (!isalpha(ch) &amp;&amp; !isdigit(ch) &amp;&amp; ch != '_') {                        ok = false;                        break;                    }                }                if (ok) s[s2i[businessLine[i]]].emplace_back(move(code[i]));            }        }        vector&lt;string&gt; ans;        for (auto&amp; vec : s) {            ranges::sort(vec);            ans.insert(ans.end(), vec.begin(), vec.end());        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3433-统计用户被提及情况","url":"/2025/12/12/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983433-%E7%BB%9F%E8%AE%A1%E7%94%A8%E6%88%B7%E8%A2%AB%E6%8F%90%E5%8F%8A%E6%83%85%E5%86%B5/","content":"题意给定数组 events 表示一堆消息，具体的 events[i] = [type_i, time_i, mentions_i] 。\n\n若 type_i 为 MESSAGE 表示在 time_i 时一组用户被消息提及。\n其中若 mentions_i 为 ALL 表示给所有用户发送消息，包括离线用户\n若 mentions_i 为 HERE 表示给所有在线用户发送消息\n若为多个由空格分隔的 id&lt;numer&gt; 表示给对应 numer 的用户发送消息，即使对方离线\n\n\n若 type_i 为 OFFLINE 表示 mentions_i 表示的用户在 time_i 开始离线 60 个单位时间，并会在 time_i + 60 时自动再次上线。\n\n求所有用户被提及到的总次数。\n思路没什么特别的算法，就是根据题意进行模拟即可。只是这里需要注意给出来的事件并非是按时间顺序排好的，需要先排序一下，同时相同时间下优先处理下线逻辑。\n实现class Solution {public:    vector&lt;int&gt; countMentions(int numberOfUsers, vector&lt;vector&lt;string&gt;&gt;&amp; events) {        ranges::sort(events, [&amp;](const auto&amp; x, const auto&amp; y) {            int xt = stoi(x[1]), yt = stoi(y[1]);            if (xt == yt) return x[0] == \"OFFLINE\";            return xt &lt; yt;        });        vector&lt;int&gt; ans(numberOfUsers);        vector&lt;int&gt; onlineT(numberOfUsers);        int curT = 0;        for (const auto&amp; e : events) {            auto message = e[0], ti = e[1], mentions = e[2];            int t = stoi(ti);            if (message == \"MESSAGE\") {                if (mentions == \"ALL\") {                    for (auto&amp; x : ans) x++;                } else if (mentions == \"HERE\") {                    for (int i = 0; i &lt; numberOfUsers; i++) {                        if (onlineT[i] &lt;= t) ans[i]++;                    }                } else {                    int m = mentions.size();                    for (int i = 0; i &lt; m; i++) {                        if (!isdigit(mentions[i])) continue;                        int j = i + 1;                        for ( ; j &lt; m &amp;&amp; isdigit(mentions[j]); j++);                        int id = stoi(mentions.substr(i, j - i));                        ans[id]++;                        i = j;                    }                }            } else {                int id = stoi(mentions);                onlineT[id] = t + 60;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3531-统计被覆盖的建筑","url":"/2025/12/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983531-%E7%BB%9F%E8%AE%A1%E8%A2%AB%E8%A6%86%E7%9B%96%E7%9A%84%E5%BB%BA%E7%AD%91/","content":"题意给定 n * n 大小的城市，以及所有建筑位置 buildings 。若某建筑上下左右方向上都至少存在一个建筑则称其被覆盖，求该城市被覆盖建筑个数。 \n思路使用哈希记录每个横纵轴最大最小位置的建筑，对于某建筑若其不为所在横纵轴最大/最小建筑则其被覆盖。\n实现class Solution {public:    int countCoveredBuildings(int n, vector&lt;vector&lt;int&gt;&gt;&amp; buildings) {        vector&lt;int&gt; xmn(n + 1, n), ymn(n + 1, n), xmx(n + 1, 0), ymx(n + 1, 0);        for (const auto&amp; b : buildings) {            int x = b[0], y = b[1];            xmn[y] = min(xmn[y], x);            xmx[y] = max(xmx[y], x);            ymn[x] = min(ymn[x], y);            ymx[x] = max(ymx[x], y);        }        int ans = 0;        for (const auto&amp; b : buildings) {            int x = b[0], y = b[1];            ans += (xmn[y] &lt; x &amp;&amp; xmx[y] &gt; x &amp;&amp; ymn[x] &lt; y &amp;&amp; ymx[x] &gt; y);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3577-统计计算机解锁顺序排列数","url":"/2025/12/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983577-%E7%BB%9F%E8%AE%A1%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%A3%E9%94%81%E9%A1%BA%E5%BA%8F%E6%8E%92%E5%88%97%E6%95%B0/","content":"题意给定数组 complexity 表示多台上锁的计算机的密码复杂度。若要解锁编号为 i 的计算机需用已解锁的计算机 j 解锁且要求 j &lt; i &amp;&amp; complexity[j] &lt; complexity[i] 。初始编号为 0 的计算机已解锁。问有多少种 [0, 1, 2..., n - 1] 的排列解锁顺序能将所有计算机解锁。  \n思路咋一看有点复杂，但实际难点全在读懂题目上了。我们要按排列的方式一个一个去解锁所有的计算机，初始仅有 0 是解锁了的，所以 0 是固定好在首位的。若之后存在复杂度小于等于首个复杂度的必定无法解锁，这是可由解锁条件直接推出的。若之后所有数均严格 大于首个复杂度，那显然排序方式是不影响的，因为每台均可由首台解锁，则答案为 (n - 1)!\n实现class Solution {static constexpr int mod = 1e9 + 7;public:    int countPermutations(vector&lt;int&gt;&amp; complexity) {        int ans = 1;        int n = complexity.size();        for (int i = 1; i &lt; n; i++) {            if (complexity[i] &lt;= complexity[0]) return 0;            ans = 1ll * ans * i % mod;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3583-统计特殊三元组","url":"/2025/12/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983583-%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E4%B8%89%E5%85%83%E7%BB%84/","content":"题意给定整数数组 nums ，返回满足以下条件的三元组 (i, j, k) 个数:\n\n0 &lt;= i &lt; j &lt; k &lt; nums.size\nnums[i] == nums[j] * 2 == nums[k]\n\n思路比较容易想到的实现思路是使用哈希维护各个数出现的个数，前后扫一趟得出前后缀为当前数两倍的数的个数，然后枚举中间值求解。\n但我们需要求的仅为三元组个数，可以通过类似 dp 的思想维护一下 元组 i 的个数 与 元组 (i, j) &amp;&amp; nums[i] == 2 * nums[j] 的个数，由此即可推出 (i, j, k) 的个数，相较而言可以少扫描一次，常数级别上稍稍快些。\n实现class Solution {using ll = long long;static constexpr int mod = 1e9 + 7;public:    int specialTriplets(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        unordered_map&lt;int, ll&gt; f0, f1;        ll ans = 0;        for (int x : nums) {            if (x % 2 == 0) ans += f1[x &gt;&gt; 1];            f1[x] += f0[x &lt;&lt; 1];            f0[x]++;        }        return ans % mod;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1925-统计平方和三元组的数目","url":"/2025/12/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981925-%E7%BB%9F%E8%AE%A1%E5%B9%B3%E6%96%B9%E5%92%8C%E4%B8%89%E5%85%83%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定正整数 n ，求满足 1 &lt;= a, b, c &lt;= n &amp;&amp; a^2 + b^2 == c^2 的三元组 (a, b, c) 的个数。\n思路勾股数是有很多有意思的数学上的性质，但这里数据范围实在不大 1 &lt;= n &lt;= 250 咱们就简单问题简单做，进行一个暴力模拟即可。\n实现class Solution {public:    int countTriples(int n) {        int ans = 0;        for (int i = 1; i &lt;= n; i++) {            for (int j = i + 1; j &lt;= n; j++) {                int k = i * i + j * j;                int sk = sqrt(k);                if (sk &lt;= n &amp;&amp; sk * sk == k) ans += 2;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1523-在区间范围内统计奇数数目","url":"/2025/12/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981523-%E5%9C%A8%E5%8C%BA%E9%97%B4%E8%8C%83%E5%9B%B4%E5%86%85%E7%BB%9F%E8%AE%A1%E5%A5%87%E6%95%B0%E6%95%B0%E7%9B%AE/","content":"题意给定非负整数 low 和 high ，求 [low, high] 之间的奇数个数。\n思路可以想到求一个数 x 及其之前的所有非负奇数的个数有 (x + 1) / 2 个。只需要分别求出 low 与 high 之前的奇数个数然后做差即可。\n实现class Solution {public:    int countOdds(int low, int high) {        return (high + 1 &gt;&gt; 1) - (low &gt;&gt; 1);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3578-统计极差最大为K的分割方式数","url":"/2025/12/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983578-%E7%BB%9F%E8%AE%A1%E6%9E%81%E5%B7%AE%E6%9C%80%E5%A4%A7%E4%B8%BAK%E7%9A%84%E5%88%86%E5%89%B2%E6%96%B9%E5%BC%8F%E6%95%B0/","content":"题意给定整数数组 nums 与一个整数 k 。求该数组有多少种划分方法，使得每个子数组极差不超过 k 。\n思路显然是进行一个 dp，不过我们需要维护一个区间的方案数以及最大最小值。这几个技巧我们先前都有联系过，就不过多赘述了。\n实现class Solution {static constexpr int mod = 1e9 + 7;public:    int countPartitions(vector&lt;int&gt;&amp; nums, int k) {        int n = nums.size();        vector&lt;int&gt; f(n + 1);        f[0] = 1;        deque&lt;int&gt; mn, mx;                for (int i = 0, l = 0, pre = 0; i &lt; n; i++) {            pre += f[i];            if (pre &gt;= mod) pre -= mod;            for ( ; !mn.empty() &amp;&amp; nums[mn.back()] &gt;= nums[i]; mn.pop_back());            mn.push_back(i);            for ( ; !mx.empty() &amp;&amp; nums[mx.back()] &lt;= nums[i]; mx.pop_back());            mx.push_back(i);            for ( ; nums[mx.front()] - nums[mn.front()] &gt; k; ) {                pre = (pre - f[l] + mod) % mod;                l++;                for ( ; !mn.empty() &amp;&amp; mn.front() &lt; l; mn.pop_front());                for ( ; !mx.empty() &amp;&amp; mx.front() &lt; l; mx.pop_front());            }            f[i + 1] = pre;        }        return f[n];    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3432-统计元素和差值为偶数的分区方案","url":"/2025/12/05/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983432-%E7%BB%9F%E8%AE%A1%E5%85%83%E7%B4%A0%E5%92%8C%E5%B7%AE%E5%80%BC%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E5%88%86%E5%8C%BA%E6%96%B9%E6%A1%88/","content":"题意给定整数数组 nums ，将整个数组分为两个非空的子数组，求两子数组元素和之差为偶数的分割方案数。\n思路使用前缀和优化求两段子数组和的过程，然后枚举所分割的点即可。\n实现class Solution {public:    int countPartitions(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        int ans = 0;        vector&lt;int&gt; pre(n);        for (int i = 0; i &lt; n; i++) {            if (i) pre[i] += pre[i - 1];            pre[i] += nums[i];        }        for (int i = 0; i &lt; n - 1; i++) {            if (!((pre[i] &lt;&lt; 1) - pre.back() &amp; 1)) ans++;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2211-统计道路上的碰撞次数","url":"/2025/12/04/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982211-%E7%BB%9F%E8%AE%A1%E9%81%93%E8%B7%AF%E4%B8%8A%E7%9A%84%E7%A2%B0%E6%92%9E%E6%AC%A1%E6%95%B0/","content":"题意给定字符串 directions 表示一排车的初始方向。若两辆车以相反的方向相撞则碰撞次数加 2 ；若移动车辆撞上静止车辆则移动次数加 1 。两车相撞后均保持停止在相撞位置。问最终总相撞次数。\n思路若从左往右遍历，显然只有向右与静止的车辆需要记录，进行一个模拟即可。\n实现class Solution {public:    int countCollisions(string directions) {        int ans = 0;        int t = 0;        char last = '#';        for (const auto&amp; ch : directions) {            if (ch == 'L') {                if (last == 'R') {                    ans += t + 1;                    t = 0;                    last = 'S';                    continue;                } else if (last == 'S') {                    ans++;                    last = 'S';                    continue;                }            } else if (ch == 'S') {                if (last == 'R') {                    ans += t;                    t = 0;                    last = 'S';                    continue;                }            } else {                t++;            }            last = ch;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3625-统计梯形的数目II","url":"/2025/12/03/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983625-%E7%BB%9F%E8%AE%A1%E6%A2%AF%E5%BD%A2%E7%9A%84%E6%95%B0%E7%9B%AEII/","content":"题意给定二维点集 points ，求可以组成多少梯形。\n思路和昨天的题很类似，只是没有了含一对边平行于 x 轴的限制。同时数据范围也小了很多 4 &lt;= points.size() &lt;= 500 。\n那我们其实可以暴力去求点两两之间组成线段的斜率与截距，任意两斜率相同且截距不同的线段均可组成一个梯形。但需要注意，这样判断会将平行四边形计算两次，需对平行四边形进行去重，具体的，平行四边形两对角线中点重合，可借此进行去重处理。\n实现class Solution {public:    int countTrapezoids(vector&lt;vector&lt;int&gt;&gt;&amp; points) {        int ans = 0;        unordered_map&lt;double, unordered_map&lt;double, int&gt;&gt; line;        unordered_map&lt;int, unordered_map&lt;double, int&gt;&gt; cnt;        int n = points.size();        for (int i = 0; i &lt; n; i++) {            for (int j = i + 1; j &lt; n; j++) {                int dx = points[i][0] - points[j][0];                int dy = points[i][1] - points[j][1];                double a = dx != 0 ? 1.0 * dy / dx : DBL_MAX;                double b = dx != 0 ? 1.0 * (points[i][1] * dx - points[i][0] * dy) / dx : points[i][0];                line[a][b]++;                cnt[((points[i][0] + points[j][0] + 2000) &lt;&lt; 16) | (points[i][1] + points[j][1] + 2000)][a]++;            }        }        for (auto&amp; [_, l] : line) {            int pre = 0;            for (auto&amp; [__, t] : l) {                ans += pre * t;                pre += t;            }        }        for (auto&amp; [_, l] : cnt) {            int pre = 0;            for (auto&amp; [__, t] : l) {                ans -= pre * t;                pre += t;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3623-统计梯形的数目I","url":"/2025/12/02/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983623-%E7%BB%9F%E8%AE%A1%E6%A2%AF%E5%BD%A2%E7%9A%84%E6%95%B0%E7%9B%AEI/","content":"题意给定二维坐标点集，求可从点集中组成多少个有一对边平行 x 轴的水平梯形。\n思路用哈希记录各纵坐标的点数，同纵坐标的点可以两两组成条边，而各不同纵坐标的边可两两组成一个水平梯形。\n实现using ll = long long;static constexpr ll mod = 1e9 + 7;ll powMod(ll a, ll b) {\tll res = 1;\twhile(b) {\t\tif(b &amp; 1) res = res * a % mod;\t\ta = a * a % mod;\t\tb &gt;&gt;= 1;\t}\treturn res;}class Solution {public:    int countTrapezoids(vector&lt;vector&lt;int&gt;&gt;&amp; points) {        unordered_map&lt;int, int&gt; cnt;        for (const auto&amp; vec : points) {            int x = vec[0], y = vec[1];            cnt[y]++;        }        ll ans = 0;        vector&lt;ll&gt; tmp;        ll inv2 = powMod(2, mod - 2);        for (const auto&amp; [y, t] : cnt) {            if (t &lt; 2) continue;            // ans = ans * t % mod * (t - 1) % mod * powMod(2, mod - 2) % mod;            tmp.push_back(1ll * t * (t - 1) % mod * inv2 % mod);        }        if (tmp.size() &lt; 2) return 0;        ll pre = 0;        for (const auto&amp; x : tmp) {            ans = (ans + x * pre % mod) % mod;            pre = (pre + x) % mod;         }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2141-同时运行N台电脑的最长时间","url":"/2025/12/01/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982141-%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8CN%E5%8F%B0%E7%94%B5%E8%84%91%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4/","content":"题意给定正整数 n 与正整数数组 batteries 分别表示电脑数量与各电池的电量。每个电池同一时间可以供给一台电脑，每一单位电量可以供给一单位时间。求问最多可以同时开启所有电脑多长时间。\n思路咱们先想想，要求所有电脑开启 x 时间如何判断是否可行。若一个电池电量大于等于 x ，显然其全程只能供给一个，因为同一电池同一时间仅能供给一台电脑。而剩余的电池总电量仅需大于等于剩余电脑与总时之积即可。\n由此我们可以想到对答案进行一个二分即可。\n实现class Solution {using ll = long long;public:    ll maxRunTime(int n, vector&lt;int&gt;&amp; batteries) {        int m = batteries.size();        auto check = [&amp;](ll x) -&gt; bool {            int t = n;            ll sum = 0;            for (auto&amp; b : batteries) {                if (b &gt;= x) t--;                else sum += b;            }            return t &lt;= 0 || sum / t &gt;= x;        };                ll lo = 0, hi = accumulate(batteries.begin(), batteries.end(), 0ll) / n;        while (lo &lt; hi) {            ll mid = (lo + hi + 1) / 2;            if (check(mid)) {                lo = mid;            } else {                hi = mid - 1;            }        }        return lo;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1590-使数组和能被P整除","url":"/2025/11/30/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981590-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E8%83%BD%E8%A2%ABP%E6%95%B4%E9%99%A4/","content":"题意给定正整数数组 nums 与一个正整数 p ，移除 nums 最短子数组使得其内剩余元素和能被 p 整除，不可将 nums 全部移除。求问最短移除的长度。\n思路移除某子数组使得剩余和如何如何，我们可以自然想到使用前缀和进行处理。需使得剩余元素和能被 p 整除即为 p 的倍数，那么所移除的子数组和应当与整个数组元素和同余于 p 。这里 p 的范围较大，故使用哈希处理上一个同余位置即可。\n实现class Solution {public:    int minSubarray(vector&lt;int&gt;&amp; nums, int p) {        int n = nums.size();        unordered_map&lt;int, int&gt; ump;        ump[0] = -1;        int sum = accumulate(nums.begin(), nums.end(), 0ll) % p;        if (sum == 0) return 0;        int ans = n;        for (int i = 0, pre = 0; i &lt; n; i++) {            pre = (pre + nums[i]) % p;            if (ump.count((pre - sum + p) % p)) ans = min(ans, i - ump[(pre - sum + p) % p]);            ump[pre] = i;        }        return ans == n ? -1 : ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3512-使数组和能被K整除的最少操作次数","url":"/2025/11/29/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983512-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%92%8C%E8%83%BD%E8%A2%ABK%E6%95%B4%E9%99%A4%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","content":"题意给定正整数数组 nums 与一个正整数 k ，每次操作可任选 nums 中一个数减一，求问令数组元素之和能被 k 整除所需最小操作次数。\n思路需要使得和为 k 的倍数，那对那个元素操作其实是没差的。同时仅有减操作，因此仅需操作数组和对 k 取余即可。\n实现class Solution {public:    int minOperations(vector&lt;int&gt;&amp; nums, int k) {        return accumulate(nums.begin(), nums.end(), 0) % k;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2872-可以被K整除连通块的最大数目","url":"/2025/11/28/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982872-%E5%8F%AF%E4%BB%A5%E8%A2%ABK%E6%95%B4%E9%99%A4%E8%BF%9E%E9%80%9A%E5%9D%97%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E7%9B%AE/","content":"题意给定一棵树，以及一正整数数组 value 表示各结点权值。可任意删除树的边，若最终各联通块的权值和可以被 k 整除，则称其为合法分割。求问合法分割最多有多少连通块。\n思路一个数是 k 的倍数，那么其减去另一个小于其的 k 的倍数则仍是 k 的倍数。因此我们这里开搜，若某点子树和为 k 的倍数则将其切割出去，由此得到的答案一定是最大的。\n不过要注意数据范围，可能会超 int 的。\n实现class Solution {using ll = long long;public:    int maxKDivisibleComponents(int n, vector&lt;vector&lt;int&gt;&gt;&amp; edges, vector&lt;int&gt;&amp; values, int k) {        vector&lt;vector&lt;int&gt;&gt; adj(n);        for (const auto&amp; e : edges) {            int u = e[0], v = e[1];            adj[u].push_back(v);            adj[v].push_back(u);        }        int ans = 0;        auto dfs = [&amp;](this auto&amp;&amp; self, int u, int fa) -&gt; ll {            ll sum = values[u];            for (auto v : adj[u]) {                if (v == fa) continue;                sum += self(v, u);            }            sum %= k;            if (sum == 0) {                ans++;            }            return sum;        };        dfs(0, -1);        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3381-长度可被K整除的子数组的最大元素和","url":"/2025/11/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983381-%E9%95%BF%E5%BA%A6%E5%8F%AF%E8%A2%ABK%E6%95%B4%E9%99%A4%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E5%92%8C/","content":"题意给定整数数组 nums 和一个正整数 k 。返回 nums 中一个非空子数组的最大和要求该子数组长度可以被 k 整除。\n思路比较自然想到使用前缀和处理子数组的和。那么子数组长度可被 k 整除应该怎么处理呢，类似于先前做过的最长子数组和问题（当且仅当前一数大于等于零时将其加入当前维护的子数组），只是这里步长从 1 变为了 k ，当且仅当前 k 数和大于等于零时将其加入当前维护的子数组。\n实现class Solution {using ll = long long;public:    ll maxSubarraySum(vector&lt;int&gt;&amp; nums, int k) {        int n = nums.size();        ll ans = -1e18;        vector&lt;ll&gt; pre(n + 1);        for (int i = 0; i &lt;= n; i++) {            if (i &lt; n) pre[i + 1] = pre[i] + nums[i];            if (i &gt;= k) {                ans = max(ans, pre[i] - pre[i - k]);                pre[i] = min(pre[i], pre[i - k]);            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2435-矩阵中和能被K整除的路径","url":"/2025/11/26/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982435-%E7%9F%A9%E9%98%B5%E4%B8%AD%E5%92%8C%E8%83%BD%E8%A2%ABK%E6%95%B4%E9%99%A4%E7%9A%84%E8%B7%AF%E5%BE%84/","content":"题意给定 n * m 的矩阵 grid 与一个正整数 k，初始位于矩阵左上角 (0, 0) 目的地为右下角 (n - 1, m - 1) ，每步仅能往下或往右。求路径和能被 k 整除的路径数目。对 1e9 + 7 取余。\n思路那很明显就是两个经典的dp问题组合起来，一个是合法路径数目，一个是和为某数倍数的方案数，没什么新的东西，将两者结合起来即可。\n实现class Solution {static constexpr int mod = 1e9 + 7;public:    int numberOfPaths(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int k) {        int n = grid.size(), m = grid.back().size();        vector f(n, vector (m, vector&lt;int&gt; (k)));        f[0][0][grid[0][0] % k] = 1;        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; m; j++) {                auto add = [&amp;](vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y) {                    for (int z = 0; z &lt; k; z++) {                        int&amp; t = x[(z + grid[i][j]) % k];                        t += y[z];                        if (t &gt;= mod) t -= mod;                    }                };                if (i) add(f[i][j], f[i - 1][j]);                if (j) add(f[i][j], f[i][j - 1]);            }        }        return f.back().back()[0];    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1015-可被K整除的最小整数","url":"/2025/11/25/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981015-%E5%8F%AF%E8%A2%ABK%E6%95%B4%E9%99%A4%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B4%E6%95%B0/","content":"题意给定正整数 k， 找出可以被 k 整除且仅含数字 1 的最小正整数的长度。\n思路换而言之，找到最小全 1 且模 k 为 0 的数，显然我们仅需维护余数部分，每次乘十加一再取余即可。\n实现class Solution {public:    int smallestRepunitDivByK(int k) {        if (k % 2 == 0) return -1;        int ans = 1;        vector&lt;bool&gt; vis(k);        for (int cur = 1 % k; cur != 0; cur = (10 * cur + 1) % k, ans++) {            if (vis[cur]) return -1;            vis[cur] = true;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1018-可被5整除的二进制前缀","url":"/2025/11/24/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981018-%E5%8F%AF%E8%A2%AB5%E6%95%B4%E9%99%A4%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%89%8D%E7%BC%80/","content":"题意给定二进制数组 nums ，定义 x_i 表示 nums[0 : i + 1] 表示的数，判断每个 x_i 是否为 5 的倍数。\n思路很容易就想到遍历数组将先前累计的数左移一位或上当前数进行模拟。但是注意到这里数组比较长有 1e5 ，就算是 python 直接模拟也是会爆范围的，所以需要优化一下。一个数什么情况下是 5 的倍数呢，显然是个位数为 0 或 5 时，因此我们仅需模拟记录当前数的个位数即可，即每次模 10 运算。\n实现class Solution {public:    vector&lt;bool&gt; prefixesDivBy5(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        vector&lt;bool&gt; ans(n);        for (int i = 0, cur = 0; i &lt; n; i++) {            cur = (cur &lt;&lt; 1) | nums[i];            if (cur &gt;= 10) cur -= 10;            if (cur == 0 || cur == 5) ans[i] = true;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1262-可被三整除的最大和","url":"/2025/11/23/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981262-%E5%8F%AF%E8%A2%AB%E4%B8%89%E6%95%B4%E9%99%A4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/","content":"题意给定正整数数组 nums 返回能被三整除的元素最大和。\n思路那也是一个比较经典的dp了。\n实现class Solution {static constexpr int inf = 1e9;public:    int maxSumDivThree(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; f{0, -inf, -inf};        for (auto&amp; x : nums) {            auto nf = f;            for (int i = 0; i &lt; 3; i++) {                nf[(i + x) % 3] = max(nf[(i + x) % 3], f[i] + x);            }            swap(f, nf);        }        return f[0];    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3190-使所有元素都可以被3整除的最少操作数","url":"/2025/11/22/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983190-%E4%BD%BF%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E9%83%BD%E5%8F%AF%E4%BB%A5%E8%A2%AB3%E6%95%B4%E9%99%A4%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0/","content":"题意给定正整数数组 nums ，每次操作可以任选一个数加减一，求问将整个数组变为 3 的倍数最少需要多少次操作。\n思路换言而止需要每个数模 3 等于 0 ，而一个数模 3 仅有三种可能 0\\1\\2。显然为1时减为2时加即可，也就是非零情况均仅需一次操作。\n实现class Solution {public:    int minimumOperations(vector&lt;int&gt;&amp; nums) {        int ans = 0;        for (auto&amp; x : nums) {            if (x % 3) ans++;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1930-长度为3的不同回文子序列","url":"/2025/11/21/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981930-%E9%95%BF%E5%BA%A6%E4%B8%BA3%E7%9A%84%E4%B8%8D%E5%90%8C%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/","content":"题意给定小写字母字符串 s， 返回其中长度为 3 的不同回文子序列个数。\n思路长度为 3 的回文串首尾相同而中间任意。故而可以考虑前后缀处理每个位置之前/之后出现了哪些字符，枚举中间字符，使用哈希去重即可。这里因为只有小写字母数据范围较小，所以我使用了位运算优化空间。\n实现class Solution {public:    int countPalindromicSubsequence(string s) {        int n = s.size();        vector&lt;int&gt; pre(n);        for (int i = 1; i &lt; n; i++) {            pre[i] = pre[i - 1] | (1 &lt;&lt; (s[i - 1] - 'a'));        }        int suf = 0;        int ans = 0;        array&lt;int, 26 * 26&gt; vis; vis.fill(0);        for (int i = n - 1; i &gt;= 0; i--) {            for (int j = 0; j &lt; 26; j++) {                if ((pre[i] &gt;&gt; j &amp; 1) &amp;&amp; (suf &gt;&gt; j &amp; 1) &amp;&amp; !vis[j * 26 + (s[i] - 'a')]) {                    vis[j * 26 + (s[i] - 'a')] = 1;                    ans++;                }            }            suf |= 1 &lt;&lt; (s[i] - 'a');        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题757-设置交集大小至少为2","url":"/2025/11/20/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98757-%E8%AE%BE%E7%BD%AE%E4%BA%A4%E9%9B%86%E5%A4%A7%E5%B0%8F%E8%87%B3%E5%B0%91%E4%B8%BA2/","content":"题意给定一堆区间的左右端点用二维数组 intervals 表示。需要满足每个区间都至少有两个点在答案集合中，求问答案集合的最小大小。\n思路咱们不妨先简化一下问题：假如每个区间只需要一个点在答案集合中，这应该怎么做呢。可以想到将区间按右端点进行排序从小到大进行遍历，只需维护最后一个加入答案集合的点以及尚无点在答案集合内的区间，若某个区间即将移除仍无点在集合中则将其右端点加入至集合即可。\n那么问题扩展至每个区间需要两个点，很自然就可以想到维护最后两个加入的点即可，当区间移出时则就有三种情况：区间内无点、有一点、有两点，进行一个分类讨论即可。\n实现class Solution {public:    int intersectionSizeTwo(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {        ranges::sort(intervals, [&amp;](const auto&amp; x, const auto&amp; y) {            if (x[1] == y[1]) return x[0] &gt; y[0];            return x[1] &lt; y[1];        });        int ans = 0;        int f = -1, s = -1;        for (const auto&amp; q : intervals) {            int l = q[0], r = q[1];            if (l &lt;= f) continue;            else if (l &lt;= s) f = s;            else {                f = r - 1;                ans++;            }            s = r;            ans++;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2154-将找到的值乘以2","url":"/2025/11/19/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982154-%E5%B0%86%E6%89%BE%E5%88%B0%E7%9A%84%E5%80%BC%E4%B9%98%E4%BB%A52/","content":"题意给定整数数组 nums 和一个整数 original 。重复以下步骤：\n\n若 nums 中存在 original 则令 original 乘以二\n如 nums 中不存在 original 则停止操作\n\n返回最终的 original\n思路比较简单的做法就是将数组排序后遍历/二分。\n但仔细观察可以发现一个复杂度低一些的做法：一个数不断乘以二，那么就是原数的 2,4,8... 倍，即原数的二的幂次倍，由此遍历一遍记录出现过的二的幂次倍，找出第一个未出现的即可。利用位运算的性质还可以把空间复杂度也降低。\n实现class Solution {public:    int findFinalValue(vector&lt;int&gt;&amp; nums, int original) {        ranges::sort(nums);        int l = 0;        for (auto it = lower_bound(nums.begin(), nums.end(), original); it != nums.end() &amp;&amp; *it == original; it = lower_bound(nums.begin() + l, nums.end(), original)) {            l = it - nums.begin();            original &lt;&lt;= 1;        }        return original;    }};\n\nclass Solution {public:    int findFinalValue(vector&lt;int&gt;&amp; nums, int original) {        int mask = 0;        for (auto&amp; x : nums) {            if (x % original) continue;            int k = x / original;            if ((k &amp; -k) == k) mask |= k;        }        mask = ~mask;        return original * (mask &amp; -mask);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题717-1比特与2比特字符","url":"/2025/11/18/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98717-1%E6%AF%94%E7%89%B9%E4%B8%8E2%E6%AF%94%E7%89%B9%E5%AD%97%E7%AC%A6/","content":"题意给定以 0 结尾的 01 数组 bits。其中有两种特殊字符，一种用一个 0 表示，一种以 10 或 11 表示。求问给定数组 bits 是否以第一种字符结尾。\n思路注意到以 1 开头的字符一定需要两个字母，以 0 开头的一定仅需一个字母，从头进行一个模拟即可。\n实现class Solution {public:    bool isOneBitCharacter(vector&lt;int&gt;&amp; bits) {        int n = bits.size();        bool ans = false;        for (int i = 0; i &lt; n; i++) {            ans = bits[i] == 0;            if (!ans) i++;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1437-是否所有1都至少相隔k个元素","url":"/2025/11/17/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981437-%E6%98%AF%E5%90%A6%E6%89%80%E6%9C%891%E9%83%BD%E8%87%B3%E5%B0%91%E7%9B%B8%E9%9A%94k%E4%B8%AA%E5%85%83%E7%B4%A0/","content":"题意给定 0/1 数组 nums 以及一个整数 k 。判断数组内所有 1 之间是否至少相隔 k 个元素。\n思路显然仅需判断相邻 1 之间是否满足条件即可，那么只需记录上一个 1 出现的位置，遍历一躺进行判断即可。\n实现class Solution {public:    bool kLengthApart(vector&lt;int&gt;&amp; nums, int k) {        int n = nums.size();        for (int i = 0, last = -k - 1; i &lt; n; i++) {            if (nums[i]) {                if (i - last &lt;= k) return false;                last = i;            }        }        return true;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1513-仅含1的子串数","url":"/2025/11/16/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981513-%E4%BB%85%E5%90%AB1%E7%9A%84%E5%AD%90%E4%B8%B2%E6%95%B0/","content":"题意给定二进制字符串 s， 返回仅有 1 的子串个数，答案模 1e9 + 7\n思路可以先想想给定一个全 1 的字符串，其有多少个子串，显然应该是一个等差数列求和：设其长度为 n 则有 n 个长度为 1 的子串，有 n - 1 个长度为 2 的子串….有 1 个长度为 n 的子串。\n那问题就转换为了有多少个全 1 的子串且它们长度各为多少，简单模拟一下即可。\n实现class Solution {static constexpr int mod = 1e9 + 7;public:    int numSub(string s) {        int n = s.size();        int ans = 0;        for (int i = 0, j = 0; i &lt; n; i++) {            if (s[i] == '0') continue;            for (j = i + 1; j &lt; n &amp;&amp; s[j] == '1'; j++);            ans += (1ll * (j - i + 1) * (j - i) &gt;&gt; 1) % mod;            if (ans &gt;= mod) ans -= mod;            i = j - 1;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3234-统计1显著的字符串的数量","url":"/2025/11/15/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983234-%E7%BB%9F%E8%AE%A11%E6%98%BE%E8%91%97%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%95%B0%E9%87%8F/","content":"题意给定二进制字符串，返回满足 1 个数大于等于 0 个数的平方的子字符串个数。\n思路第一反应是进行一个前缀和加树状数组，但细想这是不对的，因为平方是没有前缀和性质的。\n应该进行一个滑动窗口枚举 0 的数量。\n实现class Solution {public:    int numberOfSubstrings(string s) {        int ans = 0;        vector&lt;int&gt; pos{-1};        int n = s.size();        for (int i = 0; i &lt; n; i++) {            if (s[i] == '0') pos.push_back(i);            else {                ans += i - pos.back();            }            int m = pos.size();            for (int j = m - 1; j &gt; 0; j--) {                int z = m - j;                int o = i - pos[j] + 1 - z;                if (z * z &gt;= n) break;                ans += max(0, pos[j] - max(z * z - o, 0) - pos[j - 1]);            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2536-子矩阵元素加1","url":"/2025/11/14/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982536-%E5%AD%90%E7%9F%A9%E9%98%B5%E5%85%83%E7%B4%A0%E5%8A%A01/","content":"题意给定一个正整数 n ，表示一个 n * n 初始全为 0 的整数矩阵 mat。以及一个询问数组 query ，其中每个询问形如 query[i] = [row1, col1, row2, col2] 表示给左上角为 (row1, col1) 右下角为 (row2, col2) 的子矩阵所有元素加 1。返回所有询问操作后的矩阵。\n思路那就是一个非常经典的二维差分与前缀和的题目。\n不太熟悉可以先想想一维的情况：给定一维数组，多次询问表示给一个区间所有元素加减某个数，仅需返回所有操作后的结果，处理每个操作复杂度需为 O(1)。\n然后就是一个升维的操作，觉得比较复杂可以先简单画个图辅助一下思考。\n实现class Solution {public:    vector&lt;vector&lt;int&gt;&gt; rangeAddQueries(int n, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {        vector ans(n, vector&lt;int&gt; (n));        for (const auto&amp; q : queries) {            int r1 = q[0], c1 = q[1], r2 = q[2], c2 = q[3];            ans[r1][c1]++;            if (c2 + 1 &lt; n &amp;&amp; r2 + 1 &lt; n) ans[r2 + 1][c2 + 1]++;            if (c2 + 1 &lt; n) ans[r1][c2 + 1]--;            if (r2 + 1 &lt; n) ans[r2 + 1][c1]--;        }        for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; n; j++) {                if (i &amp;&amp; j) ans[i][j] += ans[i - 1][j] + ans[i][j - 1] - ans[i - 1][j - 1];                else if (i) ans[i][j] += ans[i - 1][j];                else if (j) ans[i][j] += ans[i][j - 1];            }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3228-将1移动到末尾的最大操作次数","url":"/2025/11/13/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983228-%E5%B0%861%E7%A7%BB%E5%8A%A8%E5%88%B0%E6%9C%AB%E5%B0%BE%E7%9A%84%E6%9C%80%E5%A4%A7%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","content":"题意给定二进制字符串数组 s 。每次可任选满足 0 &lt; i &lt; s.size() - 1 &amp;&amp; s[i] == '1' &amp;&amp; s[i + 1] == '0' 的 i 使得 s[i] 向后移动到字符串末尾或下一个 1 。求最多可以操作多少次。\n思路手玩一下可以发现，每次选择最前面的可操作 i 可以得到最大操作数。具体地每有一个  10 前面的所有 1 均可以添加到答案中。\n实现class Solution {public:    int maxOperations(string s) {        int n = s.size();        int ans = 0;        for (int i = 0, t = 0; i &lt; n - 1; i++) {            if (s[i] == '1') {                t++;                if (s[i + 1] == '0') {                    ans += t;                }            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2654-使数组所有元素变成1的最少操作次数","url":"/2025/11/12/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982654-%E4%BD%BF%E6%95%B0%E7%BB%84%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E5%8F%98%E6%88%901%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","content":"题意给定正整数数组 nums，每次操作可任选 0 &lt;= i &lt; n - 1 使得 nums[i] = gcd(nums[i], nums[i + 1]) ，求将 nums 全变为 1 需要操作多少次。 \n思路首先我们想想如果整个数组  gcd 不为 1 ，显然此时题目无解。\n若数组初始含 1 ，显然所需操作次数为不为 1 的数的个数，因为1和任意数gcd均为1.\n若数组不含 1 ，我们首先需要用最少的次数将数组变出一个 1， 再结合上一行思路得到答案。而变出一个 1 显然就是找到最小 gcd 为 1 的子数组的长度减一。此处数据范围较小 1 &lt;= nums.size() 因此可以直接暴力地去做；也可以利用一个数组 gcd 变换次数最多是 log 级别地简化这个过程。\n实现class Solution {public:    int minOperations(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        int g = 0, t = 0;        for (auto x : nums) {            t += x == 1;            g = gcd(g, x);        }        if (g != 1) return -1;        if (t) return n - t;        int mn = n;        vector&lt;array&lt;int, 2&gt;&gt; f;        for (int i = 0; i &lt; n; i++) {            f.push_back({nums[i], i});            vector&lt;array&lt;int, 2&gt;&gt; nf;            for (const auto&amp; x : f) {                t = gcd(x[0], nums[i]);                if (!nf.empty() &amp;&amp; nf.back()[0] == t) nf.back()[1] = x[1];                else nf.push_back({t, x[1]});            }            swap(f, nf);            if (f[0][0] == 1) mn = min(mn, i - f[0][1]);        }        return mn + n - 1;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题474-一和零","url":"/2025/11/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98474-%E4%B8%80%E5%92%8C%E9%9B%B6/","content":"题意给定二进制字符串数组 strs 以及两个正整数 n 和 m。返回 strs 的最大子集的大小，满足该子集中最多有 n 个 1 和 m 个 0\n思路数据范围都并不是很大，其中 1 &lt;= n, m &lt;= 100 1 &lt;= strs.size() &lt;= 600，那也就是说 1 &lt;= n * m * strs.size() &lt;= 6e6\n那还是比较自然的可以想到 背包dp，枚举每个字符串以及在当前有几个零几个一下选择该字符串即可。\n记当前所举字符串为 s ，其中含一个数为  含零个数为 ，同时当前子集含有 i 个一 j 个零，有递推公式\n\n实现class Solution {public:    int findMaxForm(vector&lt;string&gt;&amp; strs, int m, int n) {        vector f(n + 1, vector&lt;int&gt; (m + 1, -1));        f[0][0] = 0;        for (const auto&amp; s : strs) {            int o = count(s.begin(), s.end(), '1');            int z = s.size() - o;            for (int i = n - o; i &gt;= 0; i--)                for (int j = m - z; j &gt;= 0; j--) {                    if (f[i][j] == -1) continue;                    f[i + o][j + z] = max(f[i + o][j + z], f[i][j] + 1);                }        }        int ans = 0;        for (int i = 0; i &lt;= n; i++) ans = max(ans, ranges::max(f[i]));        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3542-将所有元素变为0的最少操作次数","url":"/2025/11/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983542-%E5%B0%86%E6%89%80%E6%9C%89%E5%85%83%E7%B4%A0%E5%8F%98%E4%B8%BA0%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","content":"题意给定非负整数数组 nums，每次操作可任选子数组将其中所有最小非负整数设为 0。求将 nums 变为全零数组的最小操作次数。\n思路贪心地想，我们每次操作会希望尽可能多地改变数组，会希望每次操作尽可能长地包含非 0 数，多次这样的操作后当前数组的最小非零数就都变为零了，就会把数组分割为更多的小块即更多的子问题。由此我们可以想到分治。\n一个较小的数会将数组分割为多个子数组，同时多个同一块的相同数可以仅一次操作全部处理，由此可以想到使用单调栈对上述分割操作进行模拟即可。\n实现class Solution {public:    int minOperations(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; stk;        int ans = 0;        for (const auto&amp; x : nums) {            while (!stk.empty() &amp;&amp; stk.back() &gt; x) {                stk.pop_back();            }            if (!stk.empty() &amp;&amp; stk.back() == x) continue;            stk.push_back(x);            if (x) ans++;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2169-得到0的操作数","url":"/2025/11/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982169-%E5%BE%97%E5%88%B00%E7%9A%84%E6%93%8D%E4%BD%9C%E6%95%B0/","content":"题意给定两个非负整数 num1 和 num2 。在每次操作中若 num1 &gt;= num2 则 num1 -= num2，反之若 num1 &lt; num2 则 num2 -= num1 。直到 num1 或 num2 为 0，求总操作数。\n思路数据范围并不是很大，均不大于 1e5，直接暴力模拟是可以接受的。\n但这个过程我们很容易联想到辗转相减法，那实际上的过程和辗转相除法是非常类似的，进行一个加速优化。\n实现class Solution {public:    int countOperations(int num1, int num2) {        int ans = 0;        while (num2) {            ans += num1 / num2;            num1 %= num2;            swap(num1, num2);        }        return ans;    }};s\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1611-使整数变为 0 的最少操作次数","url":"/2025/11/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981611-%E4%BD%BF%E6%95%B4%E6%95%B0%E5%8F%98%E4%B8%BA-0-%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","content":"题意给定非负整数 n ，每次操作可任选以下其一进行\n\n翻转 n 二进制下的最低位\n若 n 二进制下第 i - 1 为 1 且剩余低位均为 0 ，则翻转第 i 位\n\n问将 n 变为 0 的最小操作数。\n思路想想怎么让 00100 变成 0 呢\n首先若想 100 第3位变为0仅能使用操作二，换言而之需要第2位为1剩余低位为0即需变为 110而需使第2位变为1同样仅能使用操作二，即需先使第1位为1最低位为1则仅需一次操作一即可故而有操作100-&gt;101-&gt;111-&gt;110-&gt;010-&gt;011-&gt;001-&gt;000\n\n可以发现，若想使得第 i 位翻转，需先使得 i - 1 位为 1 且其余低位为 0 。可以想到是一个递归的问题。\n实现class Solution {public:    int minimumOneBitOperations(int n) {        int ans = 0;        while (n) {            ans = ((n &amp; -n) &lt;&lt; 1) - 1 - ans;            n ^= n &amp; -n;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2528-最大化城市的最小电量","url":"/2025/11/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982528-%E6%9C%80%E5%A4%A7%E5%8C%96%E5%9F%8E%E5%B8%82%E7%9A%84%E6%9C%80%E5%B0%8F%E7%94%B5%E9%87%8F/","content":"题意给定数组 stations 表示 n 个城市的供电站个数。以及两个整数 r 和 k ，其中 r 表示每个供电站的供电范围，具体的城市 i 的供电站可供 |j - i| &lt;= r 的城市 j ；还可以额外在任意城市再建造 k 个供电站。求所有城市中最小电量的最大值。\n思路求最小值的最大，那很显然应该是一个二分，我们二分答案，进行一个 check 。\n如何检查一个答案 x 是否可行呢。我们这里也别将电站视作建在某点覆盖某个半径为 r 的区域了，我们简化为建在某点覆盖其后的 2 * r 的区域。由此贪心地，若当前城市供电数不足 x 时就在此处建立对应额外的电站，若最终新建的个数小于等于 k 即表明答案 x 可行。\n如何表示一个城市被覆盖的数量呢，比较自然是可以想到使用拆分与前缀和的。\n实现class Solution {using ll = long long;static constexpr int N = 1e5;public:    ll maxPower(vector&lt;int&gt;&amp; stations, int r, int k) {        const int n = stations.size();        vector&lt;ll&gt; f(n + 1);        for (int i = 0; i &lt; n; i++) {            int left = max(0, i - r);            int right = min(n, i + r + 1);            f[left] += stations[i];            f[right] -= stations[i];        }        auto check = [&amp;](ll x) -&gt; bool {            auto tf = f;            int t = k;            for (int i = 0; i &lt; n; i++) {                if (i) tf[i] += tf[i - 1];                ll dif = x - tf[i];                if (dif &gt; 0) {                    t -= dif;                    if (t &lt; 0) return false;                    tf[i] += dif;                    tf[min(n, i + 2 * r + 1)] -= dif;                }            }            return true;        };                ll lo = 0, hi = 1ll * N * n + k;        while (lo &lt; hi) {            ll mid = lo + hi + 1 &gt;&gt; 1;            if (check(mid)) lo = mid;            else hi = mid - 1;        }        return lo;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3607-电网维护","url":"/2025/11/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983607-%E7%94%B5%E7%BD%91%E7%BB%B4%E6%8A%A4/","content":"题意有 c 个初始为开启的电站，标志从 1~c 编号。给定数组 connections 表示某些电站之间两两双向连接。可互达的电站称为一个电网。同时有询问数组 queries ：\n\n若 queries_i == [1, x] 表示对 x 进行检查，若 x 仍在线则返回 x ，否则返回其所在电网中编号最小的在线电站，若无在线电站返回 -1 \n若 queries_i == [2, x] 表示将 x 关停\n\n返回所有 [1, x] 的查询结果。\n思路所有连接都是双向的，那直接使用并查集进行处理，同一个连通块的为同一电网，记录当前所在电网的所有电站并维护最小在线电站即可。\n实现struct DSU {    int n;    vector&lt;int&gt; fa;    DSU(int x) {        n = x;        fa.resize(x);        ranges::iota(fa, 0);    }    int find(int x) {        if (fa[x] == x) return x;        return fa[x] = find(fa[x]);    }    bool merge(int x, int y) {        x = find(x);        y = find(y);        if (x == y) return false;        if (x &gt; y) swap(x, y);        fa[y] = x;        return true;    }};class Solution {public:    vector&lt;int&gt; processQueries(int c, vector&lt;vector&lt;int&gt;&gt;&amp; connections, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {        DSU dsu(c);        vector&lt;bool&gt; online(c, true);        for (const auto&amp; e : connections) {            int u = e[0] - 1, v = e[1] - 1;            dsu.merge(u, v);        }        unordered_map&lt;int, vector&lt;int&gt;&gt; ump;        unordered_map&lt;int, int&gt; index;        for (int i = 0; i &lt; c; i++) {            int f = dsu.find(i);            ump[f].push_back(i);        }        vector&lt;int&gt; ans;        for (const auto&amp; q : queries) {            int op = q[0], x = q[1] - 1;            if (op == 1) {                if (online[x]) ans.push_back(x + 1);                else {                    int f = dsu.fa[x];                    if (index[f] &gt;= ump[f].size()) ans.push_back(-1);                    else ans.push_back(ump[f][index[f]] + 1);                }            } else {                online[x] = false;                int f = dsu.fa[x];                while (index[f] &lt; ump[f].size() &amp;&amp; !online[ump[f][index[f]]]) index[f]++;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3321-计算子数组的x-sumII","url":"/2025/11/05/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983321-%E8%AE%A1%E7%AE%97%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84x-sumII/","content":"题意给定整数数组 nums 与两个整数 k 和 x ，返回大小为 n - k + 1 的整数数组 ans，其中 ans[i] 表示子数组 nums[i : i + k] 仅保留出现频次前 x 大的元素的和。\n思路是的，题目与昨天完全一致，只是数据范围 n 从 50 扩大到了 1e5 ，那显然是不能再暴力了。\n我们需要维护一个区间出现频次前 x 大的元素的出现频次与元素大小的和，同时这个区间还可以右扩左缩。首先我们可以想到使用一个 set 来进行维护区间出现元素与其出现频次，这样已经是排好序状态，仅需求出前 x 大元素的和即可。 可若暴力求出前 x 大元素还是太暴了，考虑如何优化这个和。\n这时我们可以想到，可以使用两个 set 进行维护，一个仅维护前 x 大的元素，另一个维护剩余的元素，当需要加入一个元素时，首先删除旧有元素，将新元素插入小集合，判断小集合最大是否比大集合最小大，再据此进行移动元素并更新和即可。删除元素的逻辑类似，每次仅需进行比较小集合最大与大集合最小即可。\n因为今天比较忙开始的比较晚，赶工之下没想明白，写了一大坨东西还望见谅（\n实现class Solution {using ll = long long;public:    vector&lt;ll&gt; findXSum(vector&lt;int&gt;&amp; nums, int k, int x) {        int n = nums.size();        vector&lt;ll&gt; ans(n - k + 1);        set&lt;array&lt;int, 2&gt;&gt; small;        set&lt;array&lt;int, 2&gt;&gt; big;        unordered_map&lt;int, int&gt; cnt;        ll sum = 0;        for (int l = 0, r = 0, cur = 0; r &lt; n; r++) {            array&lt;int, 2&gt; tr = {cnt[nums[r]], nums[r]};            if (cnt[nums[r]]) {                if (big.count(tr)) {                    big.erase(tr);                    tr[0]++;                    cnt[nums[r]]++;                    sum += tr[1];                    big.insert(tr);                } else {                    small.erase(tr);                    tr[0]++;                    cnt[nums[r]]++;                    if (tr &gt; *big.begin()) {                        small.insert(*big.begin());                        sum -= 1ll * (*big.begin())[0] * (*big.begin())[1];                        big.erase(big.begin());                        sum += 1ll * tr[0] * tr[1];                        big.insert(tr);                    } else {                        small.insert(tr);                    }                }            } else {                tr[0]++;                cnt[nums[r]]++;                if (big.size() &lt; x) {                    big.insert(tr);                    sum += 1ll * tr[0] * tr[1];                } else {                    if (tr &gt; *big.begin()) {                        small.insert(*big.begin());                        sum -= 1ll * (*big.begin())[0] * (*big.begin())[1];                        big.erase(big.begin());                        sum += 1ll * tr[0] * tr[1];                        big.insert(tr);                    } else {                        small.insert(tr);                    }                }            }                        if (r - l + 1 &gt; k) {                array&lt;int, 2&gt; tl = {cnt[nums[l]], nums[l]};                if (big.count(tl)) {                    big.erase(tl);                    sum -= 1ll * tl[0] * tl[1];                    tl[0]--;                    cnt[nums[l]]--;                    if (!small.empty() &amp;&amp; *small.rbegin() &gt; tl) {                        sum += 1ll * (*small.rbegin())[0] * (*small.rbegin())[1];                        big.insert(*small.rbegin());                        small.erase(*small.rbegin());                        small.insert(tl);                    } else {                        sum += 1ll * tl[0] * tl[1];                        big.insert(tl);                    }                } else {                    small.erase(tl);                    tl[0]--;                    cnt[nums[l]]--;                    if (tl[0]) small.insert(tl);                }                l++;            }            if (r - l + 1 == k) {                ans[cur++] = sum;            }            // cout &lt;&lt; \"!!\" &lt;&lt; l &lt;&lt; \" \" &lt;&lt; r &lt;&lt; \"\\n\";            // for (auto [num, p] : small) cout &lt;&lt; \"s \" &lt;&lt; num &lt;&lt; \" \" &lt;&lt; p &lt;&lt; \"\\n\";            // for (auto [num, p] : big) cout &lt;&lt; \"b \" &lt;&lt; num &lt;&lt; \" \" &lt;&lt; p &lt;&lt; \"\\n\";            // cout &lt;&lt; \"\\n\";        }        return ans;    }};\n\n\n\n稍微清醒点后重写版本\nclass Solution {using ll = long long;public:    vector&lt;long long&gt; findXSum(vector&lt;int&gt;&amp; nums, int k, int x) {        int n = nums.size();        vector&lt;ll&gt; ans(n - k + 1);        set&lt;array&lt;int, 2&gt;&gt; small, big;        unordered_map&lt;int, int&gt; cnt;        ll sum = 0;        auto apply = [&amp;]() -&gt; void {            while (!small.empty()) {                if (big.size() &lt; x) {                    auto tmp = *small.rbegin();                    sum += 1ll * tmp[0] * tmp[1];                    small.erase(tmp);                    big.insert(tmp);                } else if (*small.rbegin() &gt; *big.begin()) {                    auto tl = *small.rbegin();                    auto tr = *big.begin();                    sum += 1ll * tl[0] * tl[1] - 1ll * tr[0] * tr[1];                    small.erase(tl); small.insert(tr);                    big.erase(tr); big.insert(tl);                } else {                    break;                }            }        };        auto add = [&amp;](int x) -&gt; void {            array&lt;int, 2&gt; tmp = {cnt[x], x};            if (tmp[0]) {                if (small.count(tmp)) small.erase(tmp);                else {big.erase(tmp); sum -= 1ll * tmp[0] * tmp[1];}            }            tmp[0]++;            cnt[x]++;            small.insert(tmp);            apply();        };        auto del = [&amp;](int x) -&gt; void {            array&lt;int, 2&gt; tmp = {cnt[x], x};            if (small.count(tmp)) small.erase(tmp);            else {big.erase(tmp); sum -= 1ll * tmp[0] * tmp[1];}            tmp[0]--;            cnt[x]--;            if (tmp[0]) small.insert(tmp);            apply();        };        for (int l = 0, r = 0, cur = 0; r &lt; n; r++) {            add(nums[r]);            if (r - l + 1 &gt; k) del(nums[l++]);            if (r - l + 1 == k) ans[cur++] = sum;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3318-计算子数组的x-sumI","url":"/2025/11/04/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983318-%E8%AE%A1%E7%AE%97%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84x-sumI/","content":"题意给定整数数组 nums 与两个整数 k 和 x ，返回大小为 n - k + 1 的整数数组 ans，其中 ans[i] 表示子数组 nums[i : i + k] 仅保留出现频次前 x 大的元素的和。\n思路感觉是一个有点复杂的数据结构题，需要维护子区间出现频次前 x 大的元素并且可以右扩左缩，想想就挺复杂。\n但是注意到这题是简单版本，数据范围很小 1 &lt;= n &lt;= 50 ，那咱们简单问题简单做，遍历每个子区间求出各数出现频次再进行一个排序求和即可。\n实现class Solution {public:    vector&lt;int&gt; findXSum(vector&lt;int&gt;&amp; nums, int k, int x) {        int n = nums.size();        vector&lt;int&gt; ans(n - k + 1);        array&lt;int, 51&gt; cnt;        vector&lt;int&gt; p(51);        ranges::iota(p, 0);        for (int i = 0; i &lt; n - k + 1; i++) {            cnt.fill(0);            for (int j = 0; j &lt; k; j++) cnt[nums[i + j]]++;            ranges::sort(p, [&amp;](const int&amp; x, const int&amp; y) {                if (cnt[x] == cnt[y]) return x &gt; y;                return cnt[x] &gt; cnt[y];            });            for (int j = 0; j &lt; x &amp;&amp; cnt[p[j]]; j++) ans[i] += p[j] * cnt[p[j]];        }        return ans;    }};\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1578-使绳子变成彩色的最短时间","url":"/2025/11/03/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981578-%E4%BD%BF%E7%BB%B3%E5%AD%90%E5%8F%98%E6%88%90%E5%BD%A9%E8%89%B2%E7%9A%84%E6%9C%80%E7%9F%AD%E6%97%B6%E9%97%B4/","content":"题意给定字符串 color 与数组 neededTime 表示 n 个气球的颜色以及移除它们所需时间。希望无相邻气球同色，求最小花费时间。\n思路无相邻同色气球，那么贪心地同色区间仅保留耗时最大的气球即可。\n实现class Solution {public:    int minCost(string colors, vector&lt;int&gt;&amp; neededTime) {        int ans = 0;        int n = colors.size();        for (int i = 0; i &lt; n; ) {            int j = i, mx = 0, sum = 0;            for ( ; j &lt; n &amp;&amp; colors[j] == colors[i]; j++) {                mx = max(mx, neededTime[j]);                sum += neededTime[j];            }            ans += sum - mx;            i = j;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2257-统计网格图中没有被保卫的格子数","url":"/2025/11/02/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982257-%E7%BB%9F%E8%AE%A1%E7%BD%91%E6%A0%BC%E5%9B%BE%E4%B8%AD%E6%B2%A1%E6%9C%89%E8%A2%AB%E4%BF%9D%E5%8D%AB%E7%9A%84%E6%A0%BC%E5%AD%90%E6%95%B0/","content":"题意给定 m * n 的网格图，以及数组 guards 和 walls 表示其中守卫和墙的位置，每个守卫可保卫其上下左右不被其他守卫或墙所遮挡的格子。求有多少格子未被保卫。\n思路数据范围实在不大 1 &lt;= n * m &lt;= 1e5 ，那也就是说 O(n * m) 是完全可以接受的。我们直接就以每个警卫为始，一直往上下左右直到出界或遇到其他警卫/墙停下，去掉被守卫的格子就好。\n实现class Solution {static constexpr array&lt;int, 2&gt; nxt[] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};public:    int countUnguarded(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; guards, vector&lt;vector&lt;int&gt;&gt;&amp; walls) {        int ans = n * m - guards.size() - walls.size();        vector mp(m, vector&lt;int&gt; (n));        for (auto g : guards) {            mp[g[0]][g[1]] = 2;        }        for (auto w : walls) {            mp[w[0]][w[1]] = 2;        }        for (auto g : guards) {            for (auto [tx, ty] : nxt) {                int nx = g[0] + tx;                int ny = g[1] + ty;                for ( ; ; nx += tx, ny += ty) {                    if (nx &lt; 0 || nx &gt;= m || ny &lt; 0 || ny &gt;= n || mp[nx][ny] == 2) break;                    if (mp[nx][ny] == 1) continue;                    mp[nx][ny] = 1;                    ans--;                }            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3217-从链表中移除在数组中存在的节点","url":"/2025/11/01/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983217-%E4%BB%8E%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%A7%BB%E9%99%A4%E5%9C%A8%E6%95%B0%E7%BB%84%E4%B8%AD%E5%AD%98%E5%9C%A8%E7%9A%84%E8%8A%82%E7%82%B9/","content":"题意给定数组 nums 以及一个链表头节点 head，删除链表中在 nums 中出现过的数。\n思路开一个哈希记录那些数存在过，然后进行一个遍历链表删除操作即可。\n实现/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode() : val(0), next(nullptr) {} *     ListNode(int x) : val(x), next(nullptr) {} *     ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */class Solution {public:    ListNode* modifiedList(vector&lt;int&gt;&amp; nums, ListNode* head) {        unordered_set&lt;int&gt; t(nums.begin(), nums.end());        for (auto it = head; it != nullptr &amp;&amp; t.count(it-&gt;val); ) {            head = it-&gt;next;            it = head;        }        if (head == nullptr || head-&gt;next == nullptr) return head;        for (auto it = head, itt = head-&gt;next; itt != nullptr; ) {            if (t.count(itt-&gt;val)) {                it-&gt;next = itt-&gt;next;                itt = it-&gt;next;            } else {                it = itt;                itt = itt-&gt;next;            }        }        return head;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3289-数字小镇中的捣蛋鬼","url":"/2025/10/31/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983289-%E6%95%B0%E5%AD%97%E5%B0%8F%E9%95%87%E4%B8%AD%E7%9A%84%E6%8D%A3%E8%9B%8B%E9%AC%BC/","content":"题意给定数组 nums ，其中包含从 0 到 n - 1 的数，同时除两个数出现了两次外其余数均出现且仅出现一次。求出现两次的这两个数。\n思路数据范围很小很小 1 &lt;= n &lt;= 100 因此虽然有一个异或求解的方法，但还是直接进行一个哈希求解就好。\n实现class Solution {public:    vector&lt;int&gt; getSneakyNumbers(vector&lt;int&gt;&amp; nums) {        array&lt;int, 101&gt; cnt;        cnt.fill(0);        vector&lt;int&gt; ans;        for (auto x : nums) {            if (cnt[x]) ans.push_back(x);            cnt[x]++;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1526-形成目标数组的子数组最少增加次数","url":"/2025/10/30/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981526-%E5%BD%A2%E6%88%90%E7%9B%AE%E6%A0%87%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%9C%80%E5%B0%91%E5%A2%9E%E5%8A%A0%E6%AC%A1%E6%95%B0/","content":"题意给定正整数数组 target 和等长的初始全为 0 的 initial 数组，每次操作可任选 initial 中的子数组使其中元素均加 1 ，问使 initial 与 target 相同的最小操作次数。\n思路贪心地想，每次操作应尽可能选择足够长的子数组，这样一想可以发现在全加几次后数组就会被最小的几个数断成了几个子数组，每个子数组的操作次数应该是其内的最大值。由此可以想到用个单调栈类似物记录某段的最大值，记录上一段的最小值，操作数即为该段最大值减去上段的最小。\n到这一步又想到，这个栈似乎完全没有必要，使用一个双指针直接模拟记录就好。\n然后又可以注意到，这个双指针其实也没太必要的，若该数大于等于前一数，需要多操作的次数即为该数与前一数之差；若该数小于前一数，该数即可不用操作。\n实现cpp 用栈\nclass Solution {public:    int minNumberOperations(vector&lt;int&gt;&amp; target) {        int n = target.size();        int last = 0;        int ans = 0;        vector&lt;int&gt; stk;        for (auto x : target) {            if (stk.empty() || x &lt;= stk.back()) {            } else {                ans += stk.front() - last;                last = stk.back();                stk.clear();            }            stk.push_back(x);        }        if (!stk.empty()) ans += stk.front() - last;        return ans;    }};\n\ncpp 直接遍历\nclass Solution {public:    int minNumberOperations(vector&lt;int&gt;&amp; target) {        int n = target.size();        int ans = target.front();        for (int i = 1; i &lt; n; i++) {            if (target[i] &gt; target[i - 1]) ans += target[i] - target[i - 1];        }        return ans;    }};\n\npython 双指针\nclass Solution:    def minNumberOperations(self, target: List[int]) -&gt; int:        ans = last = 0        l = 0        r = 1        while r &lt; len(target):            if target[r] &gt; target[r - 1]:                ans += target[l] - last                last = target[r - 1]                l = r            r += 1        ans += target[l] - last        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题3370-仅含置位位的最小整数","url":"/2025/10/29/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983370-%E4%BB%85%E5%90%AB%E7%BD%AE%E4%BD%8D%E4%BD%8D%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B4%E6%95%B0/","content":"题意给定正整数 n ，找出二进制下全为 1 且最小的大于等于 n 的数。\n思路二进制下全为 1 可以直接通过将 1 左移一定位数后减一得到，问题就可以转换为最小大于等于 n 的二的次幂，那也就是求 n 的 bit_width ，直接调函数或其他方法均可以。\n实现class Solution {public:    int smallestNumber(int n) {        return (1 &lt;&lt; __lg(n) + 1) - 1;    }};\n\nclass Solution:    def smallestNumber(self, n: int) -&gt; int:        ans = 1        while ans &lt; n:            ans = ans &lt;&lt; 1 | 1        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题3354-使数组元素等于零","url":"/2025/10/28/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983354-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%AD%89%E4%BA%8E%E9%9B%B6/","content":"题意给定非负整数数组 nums，可以任选一个初始值为 0 的点以及一个方向，会从初始点向方向蔓延直到遇到第一个大于 0 的数使其减一后转向，一直蔓延直到越界为止。问有多少种选择可使数组变为全 0 数组。\n思路显然有两种情况可以使得数组变为全零。第一种是 0 左右两侧和相等，可以贡献左右两种答案；第二种是 0 左右侧和差值为 1 ，可以贡献往和较大一侧的一个答案。\n实现class Solution {public:    int countValidSelections(vector&lt;int&gt;&amp; nums) {        int sum = accumulate(nums.begin(), nums.end(), 0);        int ans = 0, cur = 0;        for (auto x : nums) {            cur += x;            if (x == 0 &amp;&amp; cur == sum - cur) ans += 2;            else if (x == 0 &amp;&amp; abs(sum - cur - cur) == 1) ans += 1;            if (cur &gt; sum + 1) break;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2125-银行中的激光束数量","url":"/2025/10/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982125-%E9%93%B6%E8%A1%8C%E4%B8%AD%E7%9A%84%E6%BF%80%E5%85%89%E6%9D%9F%E6%95%B0%E9%87%8F/","content":"题意给定字符串数组 bank 其中 bank[i][j] 表示第 i 行 j 列有一个安全设备。若某两行有安全设备且这两行件的其他行无设备，这两行的设备会两两用激光连接。问共有多少条激光。\n思路两行之间的激光就是两行设备数的乘积，故而仅需记录上一有设备行的设备数，进行一次模拟计算即可。\n实现class Solution {public:    int numberOfBeams(vector&lt;string&gt;&amp; bank) {        int ans = 0;        int pre = 0;        for (const auto&amp; s : bank) {            int cur = count(s.begin(), s.end(), '1');            ans += cur * pre;            if (cur) pre = cur;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2043-简易银行系统","url":"/2025/10/26/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982043-%E7%AE%80%E6%98%93%E9%93%B6%E8%A1%8C%E7%B3%BB%E7%BB%9F/","content":"题意实现一个简单的银行系统，包含使用数组初始化所有账户信息、用户1给用户2转账，用户存取款功能。转账存取款操作返回操作是否成功。\n思路那就是一个非常简单的模拟题，注意先判断账户是否存在，账户余额是否足够即可。\n实现class Bank {using ll = long long;vector&lt;ll&gt; count;int n;public:    Bank(vector&lt;long long&gt;&amp; balance) {        count = move(balance);        n = count.size();    }        bool transfer(int account1, int account2, long long money) {        if (account1 &gt; n || account2 &gt; n || count[account1 - 1] &lt; money) return false;        count[account1 - 1] -= money;        count[account2 - 1] += money;        return true;    }        bool deposit(int account, long long money) {        if (account &gt; n) return false;        count[account - 1] += money;        return true;    }        bool withdraw(int account, long long money) {        if (account &gt; n || count[account - 1] &lt; money) return false;        count[account - 1] -= money;        return true;    }};/** * Your Bank object will be instantiated and called as such: * Bank* obj = new Bank(balance); * bool param_1 = obj-&gt;transfer(account1,account2,money); * bool param_2 = obj-&gt;deposit(account,money); * bool param_3 = obj-&gt;withdraw(account,money); */\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1716-计算力扣银行的钱","url":"/2025/10/25/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981716-%E8%AE%A1%E7%AE%97%E5%8A%9B%E6%89%A3%E9%93%B6%E8%A1%8C%E7%9A%84%E9%92%B1/","content":"题意每周内每天会比前一天多存 1 块，而下周一会比这周一多存 1 块。现在在第一个周一存 1 块连续存 n 天，问最终存了多少。\n思路这题数据范围依旧不大 1 &lt;= n &lt;= 1e3 大可直接进行模拟。比较简单就是算一下等差求和：将存钱分成两个部分，第一部分是可以存完整一周的，第二部分是剩余不足一周的几天。第一周共可存 28 块且此后每周多存  7 块；最后一个周一会存  块，接下来每天多存 1 块。简单计算一下即可。\n实现class Solution {public:    int totalMoney(int n) {        int weeks = n / 7;        int days = n % 7;        return (28 + 21 + weeks * 7) * (weeks) / 2 + (weeks + 1 + weeks + days) * (days) / 2;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2048-下一个更大的数值平衡数","url":"/2025/10/24/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982048-%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%9B%B4%E5%A4%A7%E7%9A%84%E6%95%B0%E5%80%BC%E5%B9%B3%E8%A1%A1%E6%95%B0/","content":"题意如果整数 x 的每个数位 d 恰好在 x 中出现 d 次，则称其为数值平衡数。对于给定的正整数 n ，求出最小严格大于 n 的数值平衡数。\n思路数据范围并不是很大 1 &lt;= n &lt;= 1e6，故而可以直接暴力（见 python 写法）。\n也可以首先通过 dfs 预处理出所有数值平衡数，进行一个排序后每次查询进行二分即可。\n实现vector&lt;int&gt; ans;int init = []() {    string s = \"\";    auto dfs = [&amp;](this auto&amp;&amp; self, int i) -&gt; void {        if (s.size() == 7) {            ans.push_back(stoi(s));            return;        } else if (s.size() &gt; 7) {            return;        }        if (i &gt; 7) return;        if (!s.empty())            do {                ans.push_back(stoi(s));            } while (next_permutation(s.begin(), s.end()));                self(i + 1);        if (s.size() + i &gt; 7) return;        for (int j = 0; j &lt; i; j++) s += char(i + '0');        self(i + 1);        for (int j = 0; j &lt; i; j++) s.pop_back();    };    dfs(1);    ranges::sort(ans);    ans.erase(unique(ans.begin(), ans.end()), ans.end());    return 0;} ();class Solution {public:    int nextBeautifulNumber(int n) {        return *ranges::upper_bound(ans, n);    }};\n\nclass Solution:    def nextBeautifulNumber(self, n: int) -&gt; int:        def check(s):            cnt = Counter(str(s))            if all(int(i) == t for i, t in cnt.items()):                return True            return False        while True:            n += 1            if check(n):                return n\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题3461-判断操作后字符串中的数字是否相等I","url":"/2025/10/23/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983461-%E5%88%A4%E6%96%AD%E6%93%8D%E4%BD%9C%E5%90%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89I/","content":"题意给定一个数字字符串 s。重复操作直到字符串仅剩两字符：令 s[i] 代表的数字与 s[i + 1] 代表的数字相加模 10 替换掉 s[i]。判断最后两字符是否相同。  \n思路如果不考虑模 10 操作的就非常像陈辉三角，那就有非常多的性质可以用了。但是注意到这里数据范围真的很小 3 &lt;= s.size() &lt;= 100 。故而我们就不折磨自己简单问题简单做，进行一个模拟即可。\n实现class Solution {public:    bool hasSameDigits(string s) {        int n = s.size();        for (int i = n - 1; i &gt; 1; i--) {            for (int j = 0; j &lt; i; j++) {                s[j] = (s[j] - '0' + s[j + 1] - '0') % 10 + '0';            }        }        return s[0] == s[1];    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3347-执行操作后元素的最高频率II","url":"/2025/10/22/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983347-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%90%8E%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E9%AB%98%E9%A2%91%E7%8E%87II/","content":"题意给定整数数组 nums 与两个整数 k 和 numOperations。必须对 nums 操作 numOperations 次，每次操作可任选一个未选择过的 nums 中元素使其加上 [-k, k] 的整数。求操作结束后 nums 中出现频率最高元素的出现次数。\n思路是的，和昨天的题目完全一样，只是数据范围进行加强，昨日 nums.size() k nums[i] 均小于等于 1e5， 今日 k 与 nums[i] 增强到了 1e9。但昨天所做其实就可以过了，但可能方便阅读一些，我复制过来了。\n出现次数最高的元素有两种可能：\n\n该元素原本就在 nums 中\n该元素不在 nums 中\n\n第一种情况我们可以进行一个枚举该元素，同时维护左右端点，出现次数即为其窗口大小与该数次数加上最多操作数的最小值。\n第二种情况我们直接滑动窗口维护被操作的左右端点即可，最终注意操作数即答案不能超过操作次数上限。\n实现class Solution {public:    int maxFrequency(vector&lt;int&gt;&amp; nums, int k, int numOperations) {        ranges::sort(nums);        int n = nums.size();                int ans = 0;        for (int i = 0, l = 0, r = 0, j = 0; i &lt; n; i = j) {            for (j = i + 1; j &lt; n &amp;&amp; nums[i] == nums[j]; j++);            for ( ; l &lt; i &amp;&amp; nums[l] + k &lt; nums[i]; l++);            for (r = max(r, j); r &lt; n &amp;&amp; nums[r] - k &lt;= nums[i]; r++);            ans = max(ans, min(r - l, j - i + numOperations));        }        if (ans &gt;= numOperations) return ans;        for (int l = 0, r = 0; r &lt; n; r++) {            for ( ; nums[l] &lt; nums[r] - 2 * k; l++);            ans = max(ans, r - l + 1);        }        return min(ans, numOperations);    }};\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3346-执行操作后元素的最高频率I","url":"/2025/10/21/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983346-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%90%8E%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E9%AB%98%E9%A2%91%E7%8E%87I/","content":"题意给定整数数组 nums 与两个整数 k 和 numOperations。必须对 nums 操作 numOperations 次，每次操作可任选一个未选择过的 nums 中元素使其加上 [-k, k] 的整数。求操作结束后 nums 中出现频率最高元素的出现次数。\n思路出现次数最高的元素有两种可能：\n\n该元素原本就在 nums 中\n该元素不在 nums 中\n\n第一种情况我们可以进行一个枚举该元素，同时维护左右端点，出现次数即为其窗口大小与该数次数加上最多操作数的最小值。\n第二种情况我们直接滑动窗口维护被操作的左右端点即可，最终注意操作数即答案不能超过操作次数上限。\n实现class Solution {public:    int maxFrequency(vector&lt;int&gt;&amp; nums, int k, int numOperations) {        ranges::sort(nums);        int n = nums.size();                int ans = 0;        for (int i = 0, l = 0, r = 0, j = 0; i &lt; n; i = j) {            for (j = i + 1; j &lt; n &amp;&amp; nums[i] == nums[j]; j++);            for ( ; l &lt; i &amp;&amp; nums[l] + k &lt; nums[i]; l++);            for (r = max(r, j); r &lt; n &amp;&amp; nums[r] - k &lt;= nums[i]; r++);            ans = max(ans, min(r - l, j - i + numOperations));        }        if (ans &gt;= numOperations) return ans;        for (int l = 0, r = 0; r &lt; n; r++) {            for ( ; nums[l] &lt; nums[r] - 2 * k; l++);            ans = max(ans, r - l + 1);        }        return min(ans, numOperations);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2011-执行操作后的变量值","url":"/2025/10/20/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982011-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E5%8F%98%E9%87%8F%E5%80%BC/","content":"题意给定初值为 0 的变量 x ，与一堆操作 operations ，其中若操作为 ++x 或 x++ 表示 x 加一，若为 x-- 或 --x 表示 x 减一，求所有操作后的 x 值。\n思路非常简单的模拟题，判断每个操作第一位与最后一位是否为 + 或 - 进行计算即可。\n实现class Solution {public:    int finalValueAfterOperations(vector&lt;string&gt;&amp; operations) {        int ans = 0;        for (const auto&amp; s : operations) {            if (s[0] == '+' || s[2] == '+') ans++;            else ans--;        }        return ans;    }};\n\nclass Solution:    def finalValueAfterOperations(self, operations: List[str]) -&gt; int:        ans = 0        for s in operations:            if s[0] == '+' or s[-1] == '+':                ans += 1            else:                ans -= 1        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题1625-执行操作后字典序最小的字符串","url":"/2025/10/19/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981625-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%90%8E%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"题意给定偶长的数字字符串 s 以及两个正整数 a 和 b ，可以任意顺序执行任意次以下操作：\n\n将 s 中所有奇数位的元素加 a 模 10\n将 s 向右轮转 b 位\n\n求上述操作后可得的字典序最小的字符串。\n思路数据范围实在是不大 2 &lt;= s.size() &lt;= 100\n同时由于操作一为加 a 模 10 ，显然最少加 10 次就重复了，用裴蜀定理也可以得更小，但总之是不大的操作。并且字符串固定偶长，当 b 为偶数时就仅可能给奇数位加数。一通分析发现状态数很少，故而直接写了暴力。\n实现class Solution {public:    string findLexSmallestString(string s, int a, int b) {        string ans = s;        int n = s.size();        int t = gcd(b, n);        for (int x = 0; x &lt; 10; x++) {            string tmp = s;            for (int j = 1; j &lt; n; j += 2) {                tmp[j] = char((tmp[j] - '0' + x * a) % 10 + '0');            }            if (b &amp; 1) {                for (int y = 0; y &lt; 10; y++) {                    string tmp2 = tmp;                    for (int j = 0; j &lt; n; j += 2) {                        tmp2[j] = char((tmp2[j] - '0' + y * a) % 10 + '0');                    }                    for (int i = 0; i &lt; n; i += t) {                        ans = min(ans, tmp2.substr(i) + tmp2.substr(0, i));                    }                }            } else {                for (int i = 0; i &lt; n; i += t) {                    ans = min(ans, tmp.substr(i) + tmp.substr(0, i));                }            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3397-执行操作后不同元素的最大数量","url":"/2025/10/18/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983397-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%90%8E%E4%B8%8D%E5%90%8C%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F/","content":"题意给定正整数数组 nums 和一个正整数 k ，对于 nums 中每个元素均可以使其加一个 [-k, k] 的元素一次。求操作过后 nums 中最多有多少不同元素。 \n思路没什么特别好的想法，故进行一个排序，每个数选择将其变为可达不同的最小数进行贪心。\n实现class Solution {public:    int maxDistinctElements(vector&lt;int&gt;&amp; nums, int k) {        ranges::sort(nums);        int last = -1e9;        int ans = 0;        for (auto x : nums) {            int mn = x - k, mx = x + k;            if (last &gt;= mx) continue;            last = max(last + 1, mn);            ans++;        }        return ans;    }};\n\nclass Solution:    def maxDistinctElements(self, nums: List[int], k: int) -&gt; int:        nums.sort()        last = -1e9        ans = 0        for x in nums:            mn, mx = x - k, x + k            if last &gt;= mx:                continue            ans += 1            last = max(last + 1, mn)        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题3003-执行操作后的最大分割数量","url":"/2025/10/17/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983003-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%86%E5%89%B2%E6%95%B0%E9%87%8F/","content":"题意给定仅有小写字母的字符串 s 以及正整数 k 。\n每次选择 s 的最长且仅含 k 各不同字符的前缀进行删除，直到字符串 s 为空，记删除次数为分割数量。\n可以将 s 中至多一处替换为另一小写字母，求最大分割数量。\n思路数据范围并不是很大 1 &lt;= s.size() &lt;= 1e4 再加上仅含 26 个小写字母，咱们直接进行一个深搜 dfs  即可。\n实现class Solution:    def maxPartitionsAfterOperations(self, s: str, k: int) -&gt; int:        @cache        def dfs(loc, cur, c):            if loc == len(s):                return 1            p = 1 &lt;&lt; (ord(s[loc]) - ord('a'))            if (cur | p).bit_count() &gt; k:                res = dfs(loc + 1, p, c) + 1            else:                res = dfs(loc + 1, cur | p, c)            if c == 0:                return res            for j in range(26):                if (cur | (1 &lt;&lt; j)).bit_count() &gt; k:                    res = max(res, dfs(loc + 1, 1 &lt;&lt; j, 0) + 1)                else:                    res = max(res, dfs(loc + 1, cur | (1 &lt;&lt; j), 0))            return res        return dfs(0, 0, 1)\n\n","categories":["做题笔记"],"tags":["leetcode","python"]},{"title":"力扣每日一题2598-执行操作后的最大MEX","url":"/2025/10/16/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982598-%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7MEX/","content":"题意给定整数数组 nums 以及一个正整数 value 。每次操作可任选 nums 中一数加或减 value 。求任意次操作后 nums 最大的 MEX 值。\n思路每个数均可以加减任意次 value，换而言之每个数均可以转换为任意同余 value 的数。故将 nums 中每个数按与 value 的模数分组，枚举 MEX 即可。\n实现class Solution {public:    int findSmallestInteger(vector&lt;int&gt;&amp; nums, int value) {        vector&lt;int&gt; cnt(value);        for (auto x : nums) {            cnt[(x % value + value) % value]++;        }        int ans = 0;        for ( ; cnt[ans % value]--; ans++);        return ans;    }};\n\nclass Solution:    def findSmallestInteger(self, nums: List[int], value: int) -&gt; int:        cnt = [0] * value        for x in nums:            cnt[x % value] += 1                return value * min(cnt) + cnt.index(min(cnt))\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题3350-检测相邻递增子数组II","url":"/2025/10/15/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983350-%E6%A3%80%E6%B5%8B%E7%9B%B8%E9%82%BB%E9%80%92%E5%A2%9E%E5%AD%90%E6%95%B0%E7%BB%84II/","content":"题意就是昨天题目的升级版，此处给出整数数组 nums ，求最大的 k ，使得数组中存在两个相邻且长度为 k 的严格递增子数组。\n思路有两个思路，第一个比较简单，就是对答案进行二分，然后使用昨天的代码 check\n第二个其实是对昨日思路的扩展，两个相邻且等长的递增子数组有两种情况：\n\n有一个递增的子数组，将其拆分两半\n有两个相邻的递增子数组，将较长的一个截至与较短的等长\n\n根据以上思路在昨日基础上双指针求最大即可。\n实现class Solution {public:    int maxIncreasingSubarrays(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        int ans = 0;        for (int i = 0, j = 0; i &lt; n; ) {            for (j = max(i + 1, j); j &lt; n &amp;&amp; nums[j - 1] &lt; nums[j]; j++);            ans = max(ans, j - i &gt;&gt; 1);            if (j == n) break;            int l = j, r = j + 1;            for ( ; r &lt; n &amp;&amp; nums[r - 1] &lt; nums[r]; r++);            ans = max({ans, r - l &gt;&gt; 1, min(r - l, j - i)});            i = l; j = r;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3349-检测相邻递增子数组I","url":"/2025/10/14/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983349-%E6%A3%80%E6%B5%8B%E7%9B%B8%E9%82%BB%E9%80%92%E5%A2%9E%E5%AD%90%E6%95%B0%E7%BB%84I/","content":"题意给定整数数组 nums 与一正整数 k ，判断数组中是否存在两个相邻且长度为 k 的严格递增子数组。\n思路存在两个相邻且长度为 k 的严格递增子数组有两种情况：\n\n存在一个长度大于等于 2 * k 的严格递增子数组，可以从中任截一段等于 2 * k 的子数组作为答案\n存在两个相邻且长度大于等于 k 的严格递增子数组，从相邻部分开始各取长度为 k 的子数组即可\n\n根据上述两种情况，双指针遍历一遍数组即可。\n实现class Solution {public:    bool hasIncreasingSubarrays(vector&lt;int&gt;&amp; nums, int k) {        int n = nums.size();        for (int i = 0, j = 0; i &lt; n; ) {            for (j = i + 1; j &lt; n &amp;&amp; nums[j - 1] &lt; nums[j]; j++);            if (j - i &gt;= (k &lt;&lt; 1)) return true;            else if (j - i &lt; k) {                i = j;                continue;            }            if (j == n) return false;            int l = j, r = j + 1;            for ( ; r &lt; n &amp;&amp; nums[r - 1] &lt; nums[r]; r++);            if (r - l &gt;= k) return true;            i = r;        }        return false;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2273-移除字母异位词后的结果数组","url":"/2025/10/13/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982273-%E7%A7%BB%E9%99%A4%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%90%8E%E7%9A%84%E7%BB%93%E6%9E%9C%E6%95%B0%E7%BB%84/","content":"题意若两字符串由相同的字母组成，称其为字母异位词。\n给定字符串数组 words ，若 words 中存在相邻的字母异位词则删除较后的那一个字符串。返回最终的 words 。\n思路由相同的字母组成，python可以简单的直接 Counter ，cpp计数也可以，但就实现的复杂性来讲直接排序并比较即可。\n遍历比较当前字符串是否与上一未删字符串相同即可。\n实现class Solution {public:    vector&lt;string&gt; removeAnagrams(vector&lt;string&gt;&amp; words) {        vector&lt;string&gt; ans;        string back = \"\";        for (auto&amp; s : words) {            string t = s;            ranges::sort(t);            if (back == t) continue;            ans.push_back(s);            back = t;        }        return ans;    }};\n\nclass Solution:    def removeAnagrams(self, words: List[str]) -&gt; List[str]:        ans = [words[0]]        for i, j in pairwise(words):            if Counter(i) != Counter(j):                ans.append(j)        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题3539-魔法序列的数组乘积之和","url":"/2025/10/12/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983539-%E9%AD%94%E6%B3%95%E5%BA%8F%E5%88%97%E7%9A%84%E6%95%B0%E7%BB%84%E4%B9%98%E7%A7%AF%E4%B9%8B%E5%92%8C/","content":"","categories":[],"tags":[]},{"title":"力扣每日一题3186-施咒的最大总伤害","url":"/2025/10/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983186-%E6%96%BD%E5%92%92%E7%9A%84%E6%9C%80%E5%A4%A7%E6%80%BB%E4%BC%A4%E5%AE%B3/","content":"题意给定 power 表示一堆咒语的伤害，若使用了伤害为 x 的咒语，则不再可以使用伤害为 x - 1, x - 2, x + 1, x + 2 的咒语。求可造成的最大伤害和。\n思路那也很明显就是一个 dp 题，对各个咒语进行排序并计数去重后显然有：\n\n进行一个双指针维护最大的 dp_j 即可 O(n) 完成\n实现class Solution {using ll = long long;public:    ll maximumTotalDamage(vector&lt;int&gt;&amp; power) {        ranges::sort(power);        vector&lt;array&lt;int, 2&gt;&gt; cnt;        int m = power.size();        for (int i = 0, j = 0; i &lt; m; i = j) {            for ( ; j &lt; m &amp;&amp; power[j] == power[i]; j++);            cnt.push_back({power[i], j - i});        }        int n = cnt.size();        vector&lt;ll&gt; f(n);        ll mx = 0;        int j = 0;        for (int i = 0; i &lt; n; i++) {            for ( ; cnt[i][0] - cnt[j][0] &gt; 2; j++) mx = max(mx, f[j]);            f[i] = mx + 1ll * cnt[i][0] * cnt[i][1];        }        for ( ; j &lt; n; j++) mx = max(mx, f[j]);        return mx;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3147-从魔法师身上吸取的最大能量","url":"/2025/10/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983147-%E4%BB%8E%E9%AD%94%E6%B3%95%E5%B8%88%E8%BA%AB%E4%B8%8A%E5%90%B8%E5%8F%96%E7%9A%84%E6%9C%80%E5%A4%A7%E8%83%BD%E9%87%8F/","content":"题意有 n 个魔法师站成一排，他们能量 energy 有正有负，同时给定正整数 k ，可以任选一个魔法师开始，吸收其能量后跳跃到当前位置 + k 处继续吸收，直到到达魔法师队伍外。求可以获得的最大能量。\n思路那很明显就是一个 dp 题，显然当前位置可得能量大于零才会进行考虑，这里我选择了递推，当当前位置可得能量大于零则将当前格所得能量推给 + k  处。\n实现class Solution {public:    int maximumEnergy(vector&lt;int&gt;&amp; energy, int k) {        int n = energy.size();        vector&lt;int&gt; f = energy;        for (int i = 0; i &lt; n; i++) {            if (f[i] &gt; 0 &amp;&amp; i + k &lt; n) f[i + k] += f[i];        }        int ans = INT_MIN;        for (int i = n - k; i &lt; n; i++) ans = max(ans, f[i]);        return ans;    }};\n\nclass Solution:    def maximumEnergy(self, energy: List[int], k: int) -&gt; int:        n = len(energy)        f = [0] * n        for i in range(n):            f[i] += energy[i]            if f[i] &gt; 0 and i + k &lt; n:                f[i + k] = f[i]        return max(f[n - k : ])\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题3494-酿造药水需要的最少总时间","url":"/2025/10/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983494-%E9%85%BF%E9%80%A0%E8%8D%AF%E6%B0%B4%E9%9C%80%E8%A6%81%E7%9A%84%E6%9C%80%E5%B0%91%E6%80%BB%E6%97%B6%E9%97%B4/","content":"题意给定正整数数组 skill 和 mana，分别表示各巫师的能力与各药水的法力。对于第 i 个巫师处理第 j 个药水所需的时间为 skill[i] * mana[j]。\n必须按顺序酿造药水，且每个药水均需经过每个巫师的处理，同时药水在当前巫师完成工作后必须立即传递给下一巫师开始处理。\n求酿造好所有药水所需的最短时间。 \n思路某药水被某巫师处理完毕后必须立刻由下一巫师开始进行处理，因此各个时间需要同步。\n开一数组记录各个巫师处理完上一药水的时间，然后模拟处理每个药水的流程即可。\n实现class Solution {using ll = long long;public:    ll minTime(vector&lt;int&gt;&amp; skill, vector&lt;int&gt;&amp; mana) {        int n = skill.size(), m = mana.size();        vector&lt;ll&gt; t(n);        for (int i = 0; i &lt; m; i++) {            ll start = 0;            for (int j = 0; j &lt; n; j++) {                start = max(start, t[j]) + 1ll * skill[j] * mana[i];            }            t[n - 1] = start;            for (int j = n - 2; j &gt;= 0; j--) {                t[j] = t[j + 1] - 1ll * skill[j + 1] * mana[i];            }        }        return t.back();    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2300-咒语和药水的成功对数","url":"/2025/10/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982300-%E5%92%92%E8%AF%AD%E5%92%8C%E8%8D%AF%E6%B0%B4%E7%9A%84%E6%88%90%E5%8A%9F%E5%AF%B9%E6%95%B0/","content":"题意给定正整数数组 spells 和 potions 分别表示若干个咒语的强度和若干个药水的强度。同时给定正整数 success ，若咒语和药水的强度乘积大于等于 success 则视其为成功组合。求问每个咒语有多少个成功组合。\n思路对 potions 进行排序，找第一个与对应咒语乘积大于等于 success 的药水，其与其后的药水显然满足成功的条件。\n欲使得某整数与 x 乘积大于等于 success 显然该数应大于等于 ​\n因此进行一个排序后二分即可。\n实现class Solution {using ll = long long;public:    vector&lt;int&gt; successfulPairs(vector&lt;int&gt;&amp; spells, vector&lt;int&gt;&amp; potions, ll success) {        int n = spells.size(), m = potions.size();        vector&lt;int&gt; ans(n);        ranges::sort(potions);        for (int i = 0; i &lt; n; i++) {            ll need = (success + spells[i] - 1) / spells[i];            ans[i] = potions.end() - ranges::lower_bound(potions, need);        }        return ans;    }};\n\nclass Solution:    def successfulPairs(self, spells: List[int], potions: List[int], success: int) -&gt; List[int]:        potions.sort()        m = len(potions)        return [m - bisect_left(potions, (success + x - 1) // x) for x in spells]\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题1488-避免洪水泛滥","url":"/2025/10/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981488-%E9%81%BF%E5%85%8D%E6%B4%AA%E6%B0%B4%E6%B3%9B%E6%BB%A5/","content":"题意有很多初始为空的湖，若该湖雨前为空则雨后满，若该湖雨前已满则雨后发生洪水。给定数组 rains ，若 rains[i] 非 0 表示当天湖 rains[i] 下雨，若 rains[i] 为 0 表示当天无雨可任选一个湖进行抽水。求问是否有抽水策略可使不发生洪水，返回对应方案。 \n思路那只需要记录每个湖上一次下雨的日期，以及还未安排抽水的日期，取第一个大于上次下雨的日期对该湖进行抽水即可。\n实现class Solution {public:    vector&lt;int&gt; avoidFlood(vector&lt;int&gt;&amp; rains) {        unordered_map&lt;int, int&gt; last;        set&lt;int&gt; st;        int n = rains.size();        vector&lt;int&gt; ans(n, -1);        for (int i = 0; i &lt; n; i++) {            if (rains[i] == 0) {                st.insert(i);                continue;            }            if (last.count(rains[i])) {                int l = last[rains[i]];                auto it = st.lower_bound(l);                if (it == st.end()) return {};                ans[*it] = rains[i];                st.erase(it);                last[rains[i]] = i;            } else {                last[rains[i]] = i;            }        }        for (auto i : st) ans[i] = 1;        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题778-水位上升的泳池中游泳","url":"/2025/10/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98778-%E6%B0%B4%E4%BD%8D%E4%B8%8A%E5%8D%87%E7%9A%84%E6%B3%B3%E6%B1%A0%E4%B8%AD%E6%B8%B8%E6%B3%B3/","content":"题意给定 n * n 的数组 grid 表示矩形水池中各个位置的高度。在时刻 t 水池的水位为 t ，可以在相邻的高度小于等于 t 的格子中任意不耗时地移动。初始位于水池的左上角 (0, 0) ，求到达水池右下角 (n - 1, n - 1) 的最短时间。\n思路第一想法是进行一个二分，二分最短时间然后从起点进行一个 bfs/dfs ，仅能经过高度小于等于 x 的格子，查看是否可达终点。\n但是仔细一想这个过程是可以简化的：维护当前时刻，并用优先队列维护可达点，第一次到达终点的时刻即为答案。\n实现class Solution {static constexpr array&lt;int, 2&gt; to[] = {    {1, 0}, {-1, 0}, {0, 1}, {0, -1}};public:    int swimInWater(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {        int cur = 0;        int n = grid.size();        vector vis(n, vector&lt;bool&gt; (n));        priority_queue&lt;array&lt;int, 3&gt;, vector&lt;array&lt;int, 3&gt;&gt;, greater&lt;&gt;&gt; pq;        pq.push({grid[0][0], 0, 0});        while (!pq.empty()) {            auto [c, x, y] = pq.top();            pq.pop();            if (vis[x][y]) continue;            vis[x][y] = true;            cur = max(cur, c);            if (x == n - 1 &amp;&amp; y == n - 1) return cur;            for (auto [tx, ty] : to) {                int nx = x + tx, ny = y + ty;                if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= n || vis[nx][ny]) continue;                pq.push({grid[nx][ny], nx, ny});            }        }        return -1;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题417-太平洋大西洋水流问题","url":"/2025/10/05/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98417-%E5%A4%AA%E5%B9%B3%E6%B4%8B%E5%A4%A7%E8%A5%BF%E6%B4%8B%E6%B0%B4%E6%B5%81%E9%97%AE%E9%A2%98/","content":"题意给定二维数组 heights 表示一个矩形海岛各处的高度。若相邻格子高度小于等于当前格子高度，则当前格子的水可以流向相邻格子。\n记海岛左侧与上侧为太平洋，右侧下侧为大西洋，求岛上有哪些格子的水可以同时流向太平洋与大西洋。\n思路这题的数据范围并不大，海岛的长宽均小于等于 200 ，那其实怎么做基本都可以接受的。\n这里我们以左侧与上侧为起点做一趟bfs，标记所有可达太平洋的格子；再以右侧与下侧为起点做一趟bfs，标记所有可达大西洋的格子；在返回被标记两次的格子即可。\n实现class Solution {static constexpr array&lt;int, 2&gt; to[] = {    {0, 1}, {0, -1}, {1, 0}, {-1, 0}};public:    vector&lt;vector&lt;int&gt;&gt; pacificAtlantic(vector&lt;vector&lt;int&gt;&gt;&amp; heights) {        int n = heights.size(), m = heights.back().size();        vector&lt;vector&lt;int&gt;&gt; ans;        vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt; (m));        vector&lt;vector&lt;bool&gt;&gt; vis(n, vector&lt;bool&gt; (m));        vector&lt;array&lt;int, 2&gt;&gt; q;        for (int i = 0; i &lt; n; i++) q.push_back({i, 0});        for (int i = 1; i &lt; m; i++) q.push_back({0, i});        for (int i = 0; i &lt; q.size(); i++) {            auto [x, y] = q[i];            if (vis[x][y]) continue;            f[x][y] |= 1;            vis[x][y] = true;            for (auto [tx, ty] : to) {                int nx = x + tx, ny = y + ty;                if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || vis[nx][ny]) continue;                if (heights[nx][ny] &gt;= heights[x][y]) q.push_back({nx, ny});            }        }        q.clear();        for (int i = 0; i &lt; n; i++) {q.push_back({i, m - 1}); fill(vis[i].begin(), vis[i].end(), false);}        for (int i = 0; i &lt; m - 1; i++) q.push_back({n - 1, i});        for (int i = 0; i &lt; q.size(); i++) {            auto [x, y] = q[i];            if (vis[x][y]) continue;            f[x][y] |= 2;            vis[x][y] = true;            for (auto [tx, ty] : to) {                int nx = x + tx, ny = y + ty;                if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || vis[nx][ny]) continue;                if (heights[nx][ny] &gt;= heights[x][y]) q.push_back({nx, ny});            }        }        for (int i = 0; i &lt; n; i++)            for (int j = 0; j &lt; m; j++)                if (f[i][j] == 3) ans.push_back({i, j});        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题11-盛最多水的容器","url":"/2025/10/04/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9811-%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","content":"题意给定数组 height 表示 x 轴上按次排序的各条垂线的高度，找出其中两条线使得它们与 x 轴构成的容器可装最多水。\n（具体的 height[i] = h 表示第 i 条线两端点为 (i, 0) 与 i, h）\n思路可装水的体积以两条线之间的距离为底，以两线较短边为高。即若选 i, j 两条边所组成的体积为 (j - i) * min(height[i], height[j])\n当取 height 两端点时有 (j - i) 取到最大值，此时我们考虑如何选择可能让体积变得更大：\n无论移动哪一条边 (j - i) 必然减小，故而必须使 min(height[i], height[j]) 变大才可能使得体积增大。若移动较长边 min(height[i], height[j]) 必然不变或减小，因此我们固定较长边枚举较短边。\n根据以上思路双指针遍历数组取最大作为答案即可。\n实现class Solution {public:    int maxArea(vector&lt;int&gt;&amp; height) {        int ans = 0;        for (int l = 0, r = height.size() - 1; l &lt; r; ) {            ans = max(ans, min(height[l], height[r]) * (r - l));            if (height[l] &lt; height[r]) l++;            else r--;        }        return ans;    }};\n\nclass Solution:    def maxArea(self, height: List[int]) -&gt; int:        ans = 0        l = 0        r = len(height) - 1        while l &lt; r:            ans = max(ans, min(height[l], height[r]) * (r - l))            if height[l] &lt; height[r]:                l += 1            else:                r -= 1        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题407-接雨水II","url":"/2025/10/03/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98407-%E6%8E%A5%E9%9B%A8%E6%B0%B4II/","content":"题意给定二维数组，表示各个单元格的高度，求所给几何体可以装多少水。\n思路大名鼎鼎的接雨水题，不过扩展到了三维情况。\n咱们先手玩一下，不难发现最外围一圈格子一定是无法接水的。而次外围的格子所能装的一定不超过相邻最外围格子的最小值。这样一直往里推，即可求出各个单元格所能装水的高度，为了每次取最小我们使用优先队列模拟即可。\n实现class Solution {static constexpr array&lt;int, 2&gt; to[] = {    {0, 1}, {0, -1}, {1, 0}, {-1, 0}};public:    int trapRainWater(vector&lt;vector&lt;int&gt;&gt;&amp; heightMap) {        int n = heightMap.size(), m = heightMap.back().size();        priority_queue&lt;array&lt;int, 3&gt;, vector&lt;array&lt;int, 3&gt;&gt;, greater&lt;&gt;&gt; pq;        for (int i = 0; i &lt; n; i++) {            pq.push({heightMap[i].front(), i, 0});            pq.push({heightMap[i].back(), i, m - 1});            heightMap[i][0] = heightMap[i][m - 1] = -1;        }        for (int i = 1; i &lt; m - 1; i++) {            pq.push({heightMap[0][i], 0, i});            pq.push({heightMap[n - 1][i], n - 1, i});            heightMap[0][i] = heightMap[n - 1][i] = -1;        }        int ans = 0;        while (!pq.empty()) {            auto [h, x, y] = pq.top();            pq.pop();            for (auto [tx, ty] : to) {                int nx = x + tx, ny = y + ty;                if (nx &lt; 0 || nx &gt;= n || ny &lt; 0 || ny &gt;= m || heightMap[nx][ny] == -1) continue;                ans += max(0, h - heightMap[nx][ny]);                pq.push({max(heightMap[nx][ny], h), nx, ny});                heightMap[nx][ny] = -1;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3100-换水问题II","url":"/2025/10/02/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983100-%E6%8D%A2%E6%B0%B4%E9%97%AE%E9%A2%98II/","content":"题意初始有 numBottles 瓶水，每 numExchange 个空瓶可以换一瓶水，但每交换一瓶水 numExchage 会加 1 ，求最多可以喝多少瓶水。\n思路那和昨天是非常类似的，只是 numExchage 不再是定值。\n推公式变得难推很多，所以咱们就简单问题简单做，进行一个模拟就好。\n实现class Solution {public:    int maxBottlesDrunk(int numBottles, int numExchange) {        int ans = numBottles;        for ( ; numBottles &gt;= numExchange; ) {            ans++;            numBottles -= numExchange - 1;            numExchange++;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1518-换水问题","url":"/2025/10/01/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981518-%E6%8D%A2%E6%B0%B4%E9%97%AE%E9%A2%98/","content":"题意初始有 numBottles 瓶水，每 numExchange 个空瓶可以换一瓶水，问最多可以喝到多少瓶水。\n思路数据范围都是比较小的 1 &lt;= numBottles &lt;= 100, 2 &lt;= numExchange &lt;= 100 故而可以直接模拟（见cpp实现）\n当然也是可以推一下公式的：相当于每次减少 (numExchange - 1) 瓶水可以减少多少次。（见python实现）\n实现class Solution {public:    int numWaterBottles(int numBottles, int numExchange) {        int ans = numBottles;        for ( ; numBottles &gt;= numExchange; ) {            ans += numBottles / numExchange;            numBottles = numBottles / numExchange + numBottles % numExchange;        }        return ans;    }};\n\nclass Solution:    def numWaterBottles(self, numBottles: int, numExchange: int) -&gt; int:        return numBottles + (numBottles - 1) // (numExchange - 1)\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题2221-数组的三角和","url":"/2025/09/30/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982221-%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E8%A7%92%E5%92%8C/","content":"题意给定非负个位数数组 nums ，每次操作将 nums[i] = (nums[i] + nums[i + 1]) % 10 并将最后一个元素删除，直到数组只剩最后一个元素。求最后元素是什么。\n思路这题的数据范围并不大 1 &lt;= nums.size() &lt;= 1000 \n所以虽然确实有更加高级的做法，但有点太耗费脑子与时间了，咱们简单问题简单做，直接进行一个模拟就好。\n实现class Solution {public:    int triangularSum(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        for (int i = n - 1; i &gt;= 0; i--) {            for (int j = 0; j &lt; i; j++) {                nums[j] = nums[j] + nums[j + 1];                if (nums[j] &gt;= 10) nums[j] -= 10;            }        }        return nums[0];    }};\n\nclass Solution:    def triangularSum(self, nums: List[int]) -&gt; int:        for i in range(len(nums) - 1, -1, -1):            for j in range(i):                nums[j] = nums[j] + nums[j + 1]                if nums[j] &gt;= 10:                    nums[j] -= 10        return nums[0]\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题1039-多边形三角剖分的最低得分","url":"/2025/09/29/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981039-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86%E7%9A%84%E6%9C%80%E4%BD%8E%E5%BE%97%E5%88%86/","content":"题意给定长度为 n 的正整数数组 values ，表示一个凸多边形顺时针下各顶点的值。欲将其分割为 n - 2 个三角形，分割值为各三角形顶点值的积之和，求分隔值的最小。\n思路分割出一个三角形可以看作是三个顶点的合并，这样就可以将问题转换为了经典的区间dp。\n实现class Solution {public:    int minScoreTriangulation(vector&lt;int&gt;&amp; values) {        const int n = values.size();        vector f(n, vector&lt;int&gt; (n));        for (int len = 2; len &lt; n; len++) {            for (int i = 0, j = len; j &lt; n; i++, j++) {                f[i][j] = 1e9;                for (int k = i + 1; k &lt; j; k++) {                    f[i][j] = min(f[i][j], f[i][k] + f[k][j] + values[i] * values[j] * values[k]);                }            }        }        return f[0][n - 1];    }};\n\nclass Solution:    def minScoreTriangulation(self, values: List[int]) -&gt; int:        @cache        def dfs(i, j):            if i == j or i + 1 == j:                return 0            return min(dfs(i, k) + dfs(k, j) + values[i] * values[j] * values[k] for k in range(i + 1, j))        return dfs(0, len(values) - 1)\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题976-三角形的最大周长","url":"/2025/09/28/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98976-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%91%A8%E9%95%BF/","content":"题意给定正整数数组 nums ，返回其可以组成的最长周长的三角形的周长。\n思路根据三角形最短两边和大于第三边，显然排序过后最长周长的三条边是连续的，由此排序后枚举找到第一个满足构成三角形条件的三条连续边即可。\n实现class Solution {public:    int largestPerimeter(vector&lt;int&gt;&amp; nums) {        int n = nums.size();        ranges::sort(nums, greater());        for (int i = 2; i &lt; n; i++) {            if (nums[i] + nums[i - 1] &gt; nums[i - 2]) return nums[i] + nums[i - 1] + nums[i - 2];        }        return 0;    }};\n\nclass Solution:    def largestPerimeter(self, nums: List[int]) -&gt; int:        nums.sort(reverse=True)        for i in range(2, len(nums)):            if nums[i] + nums[i - 1] &gt; nums[i - 2]:                return sum(nums[i - 2 : i + 1])        return 0\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题812-最大三角形面积","url":"/2025/09/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98812-%E6%9C%80%E5%A4%A7%E4%B8%89%E8%A7%92%E5%BD%A2%E9%9D%A2%E7%A7%AF/","content":"题意给定二维平面点集 points 返回其中可组成面积最大的三角形的面积。\n思路点集的大小不大 3 &lt;= points.size() &lt;= 50 故而之间枚举三个点即可。\n实现class Solution {public:    double largestTriangleArea(vector&lt;vector&lt;int&gt;&gt;&amp; points) {        auto cal = [](vector&lt;int&gt;&amp; x, vector&lt;int&gt;&amp; y, vector&lt;int&gt;&amp; z) -&gt; double {            return 0.5 * abs(x[0] * y[1] + y[0] * z[1] + z[0] * x[1] - x[0] * z[1] - y[0] * x[1] - z[0] * y[1]);        };        int n = points.size();        double ans = 0;        for (int i = 0; i &lt; n - 2; i++)            for (int j = i + 1; j &lt; n - 1;j ++)                for (int k = j + 1; k &lt; n; k++)                    ans = max(ans, cal(points[i], points[j], points[k]));        return ans;    }};\n\nclass Solution:    def largestTriangleArea(self, points: List[List[int]]) -&gt; float:        def cal(x, y, z):            return abs(x[0] * y[1] + y[0] * z[1] + z[0] * x[1] - x[0] * z[1] - y[0] * x[1] - z[0] * y[1]) / 2        return max(cal(x, y, z) for x, y, z in combinations(points, 3))\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题611-有效三角形的个数","url":"/2025/09/26/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98611-%E6%9C%89%E6%95%88%E4%B8%89%E8%A7%92%E5%BD%A2%E7%9A%84%E4%B8%AA%E6%95%B0/","content":"题意给定一个非负整数数组 nums ， 返回其中可以组成三角形的三条边的三元组个数。\n思路数据范围 1 &lt;= nums.size() &lt;= 1000\n可以考虑将边排序后，固定最短边，枚举次短边，最长边用一个指针维护，因为最短边固定 次短边按递增枚举 则其可以满足的最长边一定是递增的（三角形最短两边和大于最长边）\n注意这里给定数是非负整数，即含有0即可。\n实现class Solution {public:    int triangleNumber(vector&lt;int&gt;&amp; nums) {        ranges::sort(nums);        int ans = 0;        int n = nums.size();        for (int x = 0; x &lt; n - 2; x++) {            if (nums[x] == 0) continue;            for (int y = x + 1, z = x + 2; y &lt; n - 1; y++) {                for ( ; z &lt; n &amp;&amp; nums[x] + nums[y] &gt; nums[z]; z++);                ans += z - y - 1;            }        }        return ans;    }};\n\nclass Solution:    def triangleNumber(self, nums: List[int]) -&gt; int:        nums.sort()        ans = 0        n = len(nums)        for x in range(n - 2):            if nums[x] == 0:                continue            z = x + 2            for y in range(x + 1, n - 1):                while z &lt; n and nums[x] + nums[y] &gt; nums[z]:                    z += 1                ans += z - y - 1        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题120-三角形最小路径和","url":"/2025/09/25/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98120-%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","content":"题意给定一个数字三角形，初始位于最上层顶点，每一步可以向正下或右下走一格，求到达最底层的最小路径和。\n思路那这是一道非常经典的dp问题了，每一个格子仅可能从其上或其左上的格子得来，因此其最小代价为其值加上可达其的格子的最小代价。注意边界的处理即可。\n实现class Solution {public:    int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) {        const int n = triangle.size();        for (int i = 1; i &lt; n; i++) {            for (int j = 1; j &lt; i; j++) {                triangle[i][j] += min(triangle[i - 1][j - 1], triangle[i - 1][j]);            }            triangle[i][0] += triangle[i - 1][0];            triangle[i][i] += triangle[i - 1][i - 1];        }        return ranges::min(triangle.back());    }};\n\nclass Solution:    def minimumTotal(self, triangle: List[List[int]]) -&gt; int:        for i in range(1, len(triangle)):            for j in range(1, i):                triangle[i][j] += min(triangle[i - 1][j - 1], triangle[i - 1][j])            triangle[i][0] += triangle[i - 1][0]            triangle[i][i] += triangle[i - 1][i - 1]        return min(triangle[-1])\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题166-分数到小数","url":"/2025/09/24/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98166-%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0/","content":"题意给定分子分母，返回其表示的小数，若其有循环则将其循环节用 \"()\" 括起。\n思路模拟手算除法的操作即可，循环节的寻找可以通过使用哈希记录该余数是否出现过。\n实现class Solution {using ll = long long;public:    string fractionToDecimal(int numerator, int denominator) {        ll x = abs(1ll * numerator), y = abs(1ll * denominator);        string ans;        if (1ll * numerator * denominator &lt; 0) ans += '-';        ans += to_string(x / y);        if (x % y == 0) return ans;        ans += '.';        unordered_map&lt;ll, int&gt; rem;        ll r = x % y;        rem[r] = ans.size();        while (r) {            r *= 10;            ans += to_string(r / y);            r %= y;            if (rem.count(r)) {                int p = rem[r];                return ans.substr(0, p) + '(' + ans.substr(p) + ')';            }            rem[r] = ans.size();        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题165-比较版本号","url":"/2025/09/23/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98165-%E6%AF%94%E8%BE%83%E7%89%88%E6%9C%AC%E5%8F%B7/","content":"题意给定两个由 '.' 分割开的数字版本号，比较两个版本号的大小。\n思路将两个版本号每一部分转换为数字进行比较就好，只是这里需要注意题目给定的每个数字范围是 所有修订号都可以存储在 32 位整数 中 如果用cpp的话需要开 unsigned 或者 long long。\n实现class Solution {public:    int compareVersion(string version1, string version2) {        vector&lt;unsigned&gt; x, y;        unsigned t = 0;        for (const auto&amp; ch : version1) {            if (ch == '.') {                x.push_back(t);                t = 0;            }            else {                t += 10 * t + (ch - '0');            }        }        x.push_back(t);        t = 0;        for (const auto&amp; ch : version2) {            if (ch == '.') {                y.push_back(t);                t = 0;            }            else {                t += 10 * t + ch - '0';            }        }        y.push_back(t);        while (x.size() &lt; y.size()) x.push_back(0);        while (y.size() &lt; x.size()) y.push_back(0);        if (x &gt; y) return 1;        else if (x &lt; y) return -1;        return 0;    }};\n\nclass Solution:    def compareVersion(self, version1: str, version2: str) -&gt; int:        for i, j in zip_longest(version1.split('.'), version2.split('.'), fillvalue=0):            x = int(i)            y = int(j)            if (x &gt; y):                return 1            elif (x &lt; y):                return -1        return 0\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题3005-最大频率元素计数","url":"/2025/09/22/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983005-%E6%9C%80%E5%A4%A7%E9%A2%91%E7%8E%87%E5%85%83%E7%B4%A0%E8%AE%A1%E6%95%B0/","content":"题意给定数组 nums ，返回数组中具有最大频率的元素的总频率和。\n思路使用哈希记录每个数的出现频次，再找出最大频次及其和即可。\n实现class Solution {public:    int maxFrequencyElements(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; cnt(101);        for (auto x : nums) cnt[x]++;        int mx = 0, ans = 0;        for (int i = 0; i &lt;= 100; i++) {            if (cnt[i] &gt; mx) {                mx = cnt[i];                ans = cnt[i];            } else if (cnt[i] == mx) ans += cnt[i];        }        return ans;    }};\n\nclass Solution:    def maxFrequencyElements(self, nums: List[int]) -&gt; int:        cnt = [0] * 101        ans = mx = 0        for x in nums:            cnt[x] += 1            if cnt[x] &gt; mx:                mx = cnt[x]                ans = cnt[x]            elif cnt[x] == mx:                ans += cnt[x]        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题1912-设计电影租借系统","url":"/2025/09/21/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981912-%E8%AE%BE%E8%AE%A1%E7%94%B5%E5%BD%B1%E7%A7%9F%E5%80%9F%E7%B3%BB%E7%BB%9F/","content":"题意所有电影用数组 entries 表示，其中 entries[i] = [shop, movie, price] 分别表示对应商店 shop 有一份价格为 price 的电影 movie \n实现含如下功能的 MovieRentingSystem 类\n\nMovieRentingSystem(int n, vector&lt;vector&lt;int&gt;&gt;&amp; entries) 构造函数\nvector&lt;int&gt; search(int movie) 返回指定电影的未借出且最便宜的 5 个商店，不足 5 则全返回。按价格升序，若价格相同按商店编号升序排序。\nvoid rent(int shop, int movie) 将指定商店的指定电影借出\nvoid drop(int shop, int movie) 将指定电影归还到指定商店\nvector&lt;vector&lt;int&gt;&gt; report() 返回已借出的最便宜的 5 部电影，按 [shop, movie] 返回该借出电影的信息。不足 5 则全返回。按价格升序，若价格相同按商店编号升序，若商店编号相同按电影编号升序排序。\n\n保证所有输入合法，所有商店同一电影最多有一份。\n思路进行一个稍复杂的模拟即可。\n实现class MovieRentingSystem {using ll = long long;unordered_map&lt;ll, int&gt; price;unordered_map&lt;int, set&lt;array&lt;int, 2&gt;&gt;&gt; umovies;set&lt;array&lt;int, 3&gt;&gt; movies;public:    MovieRentingSystem(int n, vector&lt;vector&lt;int&gt;&gt;&amp; entries) {        for (const auto&amp; e : entries) {            int shop = e[0], m = e[1], p = e[2];            price[(1ll * shop) &lt;&lt; 32 | m] = p;            umovies[m].insert({p, shop});        }    }        vector&lt;int&gt; search(int movie) {        vector&lt;int&gt; ans;        for (const auto&amp; arr : umovies[movie]) {            ans.push_back(arr[1]);            if (ans.size() &gt;= 5) break;        }        return ans;    }        void rent(int shop, int movie) {        int p = price[(1ll * shop) &lt;&lt; 32 | movie];        umovies[movie].erase({p, shop});        movies.insert({p, shop, movie});    }        void drop(int shop, int movie) {        int p = price[(1ll * shop) &lt;&lt; 32 | movie];        movies.erase({p, shop, movie});        umovies[movie].insert({p, shop});    }        vector&lt;vector&lt;int&gt;&gt; report() {        vector&lt;vector&lt;int&gt;&gt; ans;        for (const auto&amp; [p, s, m] : movies) {            ans.push_back({s, m});            if (ans.size() &gt;= 5) break;        }        return ans;    }};/** * Your MovieRentingSystem object will be instantiated and called as such: * MovieRentingSystem* obj = new MovieRentingSystem(n, entries); * vector&lt;int&gt; param_1 = obj-&gt;search(movie); * obj-&gt;rent(shop,movie); * obj-&gt;drop(shop,movie); * vector&lt;vector&lt;int&gt;&gt; param_4 = obj-&gt;report(); */\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3508-设计路由器","url":"/2025/09/20/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983508-%E8%AE%BE%E8%AE%A1%E8%B7%AF%E7%94%B1%E5%99%A8/","content":"题意每个数据包包含以下内容 [source, destination, timestamp]\n实现 Router 类有如下功能：\n\nRouter(int memoryLimit) : 初始化，并设置固定内存限制，若未转发包数大于 memoryLimit 则不断丢弃最久的数据包\nbool addPacket(int source, int destination, int timestamp) 添加对应数据包，若已存在完全相同的数据包则添加失败，返回添加结果\nvector&lt;int&gt; forwardPacket() 按先入先出规则返回下一个未被丢弃的数据包\nint getCount(int destination, int startTime, int endTime) 返回尚未转发目的地为 destination 且 startTime &lt;= timeStamp &lt;= endTime 的数据包数量\n\n思路也同样没什么特别的，进行一个模拟就好。\n实现struct Ahash {    size_t operator()(const array&lt;int, 3&gt;&amp; arr) const noexcept {        size_t h1 = hash&lt;int&gt;{}(arr[0]);        size_t h2 = hash&lt;int&gt;{}(arr[1]);        size_t h3 = hash&lt;int&gt;{}(arr[2]);        size_t seed = h1;        seed ^= h2 + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);        seed ^= h3 + 0x9e3779b9 + (seed &lt;&lt; 6) + (seed &gt;&gt; 2);        return seed;    }};struct Aequal {    bool operator()(const array&lt;int, 3&gt;&amp; x, const array&lt;int, 3&gt;&amp; y) const noexcept {        return x == y;    }};class Router {private:    int limit;    unordered_set&lt;array&lt;int, 3&gt;, Ahash, Aequal&gt; ust;    unordered_map&lt;int, vector&lt;int&gt;&gt; dst2time;    unordered_map&lt;int, int&gt; dst2sz;    queue&lt;array&lt;int, 3&gt;&gt; q;public:    Router(int memoryLimit) {        limit = memoryLimit;        ust.clear();        dst2time.clear();        dst2sz.clear();    }        bool addPacket(int source, int destination, int timestamp) {        auto [it, ok] = ust.insert({source, destination, timestamp});        if (!ok) return ok;        dst2time[destination].push_back(timestamp);        q.push({source, destination, timestamp});        for ( ; q.size() &gt; limit; q.pop()) {            auto [source, destination, timestamp] = q.front();            ust.erase({source, destination, timestamp});            dst2sz[destination]++;        }        return ok;    }        vector&lt;int&gt; forwardPacket() {        if (q.empty()) return {};        auto [source, destination, timestamp] = q.front();        q.pop();        ust.erase({source, destination, timestamp});        dst2sz[destination]++;        return {source, destination, timestamp};    }        int getCount(int destination, int startTime, int endTime) {        if (!dst2time.count(destination)) return 0;        const auto&amp; vec = dst2time[destination];        int t = dst2sz[destination];        auto l = ranges::lower_bound(vec.begin() + t, vec.end(), startTime);        auto r = ranges::upper_bound(vec.begin() + t, vec.end(), endTime);        return r - l;    }};/** * Your Router object will be instantiated and called as such: * Router* obj = new Router(memoryLimit); * bool param_1 = obj-&gt;addPacket(source,destination,timestamp); * vector&lt;int&gt; param_2 = obj-&gt;forwardPacket(); * int param_3 = obj-&gt;getCount(destination,startTime,endTime); */\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3484-设计电子表格","url":"/2025/09/19/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983484-%E8%AE%BE%E8%AE%A1%E7%94%B5%E5%AD%90%E8%A1%A8%E6%A0%BC/","content":"题意实现一个电子表格，包含以下功能：\n\nSpereadsheet(int rows) 初始化一个有 26 列和 rows 行的表格，其中列编号为 A-Z 行编号为 1-rows\nsetCell(string cell, int value) 将格 cell 的值置为 value\nresetCell(string cell) 将格 cell 的值置为 0\ngetValue(string formula) 给定格式形如 =X+Y 的公式，若 X 为单元格则取对应单元格的值，若为数字则取对应数字值，返回 X + Y 的结果\n\n思路同样是没有什么特别的，进行一个模拟即可。\n实现class Spreadsheet {private:    unordered_map&lt;string, int&gt; data;public:    Spreadsheet(int rows) {        data.clear();    }        void setCell(string cell, int value) {        data[cell] = value;    }        void resetCell(string cell) {        data[cell] = 0;    }        int getValue(string formula) {        int plusloc = formula.find('+');        string x = formula.substr(1, plusloc - 1);        string y = formula.substr(plusloc + 1);        int a = isupper(x.front()) ? data[x] : stoi(x);        int b = isupper(y.front()) ? data[y] : stoi(y);        return a + b;    }};/** * Your Spreadsheet object will be instantiated and called as such: * Spreadsheet* obj = new Spreadsheet(rows); * obj-&gt;setCell(cell,value); * obj-&gt;resetCell(cell); * int param_3 = obj-&gt;getValue(formula); */\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3408-设计任务管理器","url":"/2025/09/18/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983408-%E8%AE%BE%E8%AE%A1%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8/","content":"题意实现一个任务管理器系统，有如下功能：\n\n初始化，给定三维数组 tasks 其内 [userId, taskId, priority] 分别表示该任务的用户id 任务id 优先级\n添加一个 userId, taskId, priority 的任务\n将任务id为 taskId 的任务优先级修改为 newPriority\n删除任务id为 taskId 的任务\n返回优先级最高，若有多任务优先级等高则返回任务id最高的任务的用户id\n\n思路那没什么特别的，就是按照题意模拟即可。\n实现class TaskManager {private:    unordered_map&lt;int, int&gt; id2prio;    unordered_map&lt;int, int&gt; id2uid;    priority_queue&lt;array&lt;int, 3&gt;&gt; pq;public:    TaskManager(vector&lt;vector&lt;int&gt;&gt;&amp; tasks) {        for (const auto&amp; t : tasks) {            int uid = t[0], tid = t[1], pri = t[2];            pq.push({pri, tid, uid});            id2prio[tid] = pri;            id2uid[tid] = uid;        }    }        void add(int userId, int taskId, int priority) {        pq.push({priority, taskId, userId});        id2prio[taskId] = priority;        id2uid[taskId] = userId;    }        void edit(int taskId, int newPriority) {        id2prio[taskId] = newPriority;        pq.push({newPriority, taskId, id2uid[taskId]});    }        void rmv(int taskId) {        id2prio[taskId] = id2uid[taskId] = -1;    }        int execTop() {        for ( ; !pq.empty(); pq.pop()) {            auto [pri, tid, uid] = pq.top();            if (pri == id2prio[tid]) {                pq.pop();                id2prio[tid] = -1;                return uid;            }        }        return -1;    }};/** * Your TaskManager object will be instantiated and called as such: * TaskManager* obj = new TaskManager(tasks); * obj-&gt;add(userId,taskId,priority); * obj-&gt;edit(taskId,newPriority); * obj-&gt;rmv(taskId); * int param_4 = obj-&gt;execTop(); */\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2349-设计数字容器系统","url":"/2025/09/17/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982349-%E8%AE%BE%E8%AE%A1%E6%95%B0%E5%AD%97%E5%AE%B9%E5%99%A8%E7%B3%BB%E7%BB%9F/","content":"题意实现一个数字容器系统，包含以功能\n\n在定下标处插入或替换一个数字\n返回给定数字的最小下标\n\n思路下标范围很大有 1 &lt;= index &lt;= 1e9 故而是不能直接数组模拟的，但是题目也明确了各个功能的调用总次数不超过 1e5 因此也无需太在意空间，直接使用哈希进行模拟即可。\n实现class NumberContainers {private:    unordered_map&lt;int, int&gt; loc;    unordered_map&lt;int, set&lt;int&gt;&gt; ump;public:    NumberContainers() {        loc.clear();        ump.clear();    }        void change(int index, int number) {        if (!loc.count(index)) {            loc[index] = number;            ump[number].insert(index);        } else {            ump[loc[index]].erase(index);            if (ump[loc[index]].empty()) ump.erase(loc[index]);            ump[number].insert(index);            loc[index] = number;        }    }        int find(int number) {        if (!ump.count(number)) return -1;        return *ump[number].begin();    }};/** * Your NumberContainers object will be instantiated and called as such: * NumberContainers* obj = new NumberContainers(); * obj-&gt;change(index,number); * int param_2 = obj-&gt;find(number); */\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2197-替换数组中的非互质数","url":"/2025/09/16/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982197-%E6%9B%BF%E6%8D%A2%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%9D%9E%E4%BA%92%E8%B4%A8%E6%95%B0/","content":"题意给定数组 nums ，当 nums 中存在任意两相邻数不互质时将这两数替换为这两数的 lcm， 返回不会再发生合并后的结果。\n思路显然合并的顺序是不会影响最终结果的：x, y 不互质意味着 gcd(x, y) &gt; 1 而两数的 lcm 实际上为两数的质因数分解后取各质因子的最高次幂，也就是说任意一个数 z 若可与 x 或 y 不互质，则其一定与 lcm(x, y) 不互质即 gcd(z, lcm(x, y)) &gt; 1。\n所以仅需一个栈进行维护即可。\n实现class Solution {public:    vector&lt;int&gt; replaceNonCoprimes(vector&lt;int&gt;&amp; nums) {        vector&lt;int&gt; ans;        for (auto x : nums) {            while (!ans.empty() &amp;&amp; gcd(ans.back(), x) != 1) {                x = lcm(ans.back(), x);                ans.pop_back();            }            ans.push_back(x);        }        return ans;    }};\n\nclass Solution:    def replaceNonCoprimes(self, nums: List[int]) -&gt; List[int]:        ans = []        for x in nums:            while len(ans) &gt; 0 and gcd(x, ans[-1]) &gt; 1:                x = lcm(x, ans[-1])                ans.pop()            ans.append(x)        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题1935-可以输入的最大单词数","url":"/2025/09/15/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981935-%E5%8F%AF%E4%BB%A5%E8%BE%93%E5%85%A5%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E6%95%B0/","content":"题意给定字符串 brokenLetters 表示键盘破损的键位，以及多个由空格分隔的单词组成的字符串 text ，返回 text 中可以完整打出的单词数量。\n思路简单问题简单做，使用哈希记录破损键盘或直接遍历 brokenLetters 都是可以的，然后遍历每个单词判断其是否含破损键位即可。\n实现class Solution {public:    int canBeTypedWords(string text, string brokenLetters) {        array&lt;int, 26&gt; a;        a.fill(0);        for (const auto&amp; ch : brokenLetters) a[ch - 'a'] = 1;        int ans = 0, ok = 1;        const int n = text.size();        for (int i = 0; i &lt; n; i++) {            if (text[i] == ' ') {                ans += ok;                ok = 1;            }            else if (a[text[i] - 'a']) ok = 0;        }        return ans + ok;    }};\n\nclass Solution:    def canBeTypedWords(self, text: str, brokenLetters: str) -&gt; int:        ans = 0        for word in text.split():            if all(ch not in brokenLetters for ch in word):                ans += 1        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题966-元音拼写检查器","url":"/2025/09/14/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98966-%E5%85%83%E9%9F%B3%E6%8B%BC%E5%86%99%E6%A3%80%E6%9F%A5%E5%99%A8/","content":"题意给定单词表 wordlist 以及询问若干个 queries ，对于每个询问给出一个字符串 query\n\n若字符串 query 可以再 wordlist 中找到，则返回对应单词表中单词\n若字符串 query 忽视大小写差异后可在 wordlist 中找到，则返回单词表中第一个符合的单词w\n若字符串 query 忽视大小写且各元音字母可以任意替换为其他元音字母后可在 wordlist 中找到，则返回单词表中第一个符合的单词。\n\n思路维护三个哈希表即可：\n\n原单词表的哈希表\n将所有单词转为小写字母的对应单词表\n将所有单词转为小写且元音字母均替换为 '*' 后的对应单词表\n\n然后对询问做同样的处理并进行查询是否存在即可。\n实现class Solution {public:    vector&lt;string&gt; spellchecker(vector&lt;string&gt;&amp; wordlist, vector&lt;string&gt;&amp; queries) {        unordered_set&lt;string&gt; ori(wordlist.begin(), wordlist.end());        unordered_map&lt;string, vector&lt;string&gt;&gt; bigSmall;        unordered_map&lt;string, vector&lt;string&gt;&gt; vowel;        for (const auto&amp; s : wordlist) {            auto t = s;            for (auto&amp; ch : t) {                if (isupper(ch)) ch = char(ch - 'A' + 'a');            }            bigSmall[t].push_back(s);            for (auto&amp; ch : t) {                if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') ch = '*';            }            vowel[t].push_back(s);        }        vector&lt;string&gt; ans;        for (auto&amp; s : queries) {            if (ori.count(s)) {                ans.push_back(s);                continue;            }            for (auto&amp; ch : s) if (isupper(ch)) ch = char(ch - 'A' + 'a');            if (bigSmall.count(s)) {                ans.push_back(bigSmall[s].front());                continue;            }            for (auto&amp; ch : s) if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') ch = '*';            if (vowel.count(s)) {                ans.push_back(vowel[s].front());                continue;            }            ans.push_back(\"\");        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3541-找到频率最高的元音和辅音","url":"/2025/09/13/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983541-%E6%89%BE%E5%88%B0%E9%A2%91%E7%8E%87%E6%9C%80%E9%AB%98%E7%9A%84%E5%85%83%E9%9F%B3%E5%92%8C%E8%BE%85%E9%9F%B3/","content":"题意给定小写英文字符串，返回其中出现频次最高的元音字母和辅音字母的频次和。\n思路没什么特别的，只需记录每个字母的出现次数，然后找出现次数最多的元音辅音即可。\n实现class Solution:    def maxFreqSum(self, s: str) -&gt; int:        cnt = Counter(s)        u = v = 0        for i in range(26):            ch = chr(ord('a') + i)            if ch in \"aeiou\":                u = max(u, cnt[ch])            else:                v = max(v, cnt[ch])        return u + v\n\nclass Solution {public:    int maxFreqSum(string s) {        array&lt;int, 26&gt; cnt;        cnt.fill(0);        for (const auto&amp; ch : s) cnt[ch - 'a']++;        int u = 0, v = 0;        for (int i = 0; i &lt; 26; i++) {            char ch = i + 'a';            if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') {                u = max(u, cnt[i]);            } else {                v = max(v, cnt[i]);            }        }        return u + v;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题3227-字符串元音游戏","url":"/2025/09/12/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983227-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%85%83%E9%9F%B3%E6%B8%B8%E6%88%8F/","content":"题意给定已字符串 s ，小明小红轮流进行游戏，小红先手：\n\n小红每次可以删除 s 中任意包含奇数个元音字符的子字符串\n小明每次可以删除 s 中任意包含偶数个元音字符的子字符串\n\n谁先无法行动则失败。\n判断小红是否必胜。\n思路简单手玩一下：\n若开局无元音字母，显然小明必胜。\n若开局有奇数个元音字母，小红可以直接删除整个字符串，小红胜。\n若开局有偶数个元音字母，小红可以将字符串删至仅含单元音字母，若此时无其他辅音字母则小红胜；若含其他字母小明仅可删除辅音字母，再到小红时小红可将剩余字符全删除，仍是小红胜。\n故而若字符串含元音字母则小红必胜。\n实现class Solution:    def doesAliceWin(self, s: str) -&gt; bool:        for ch in s:            if ch == 'a' or ch == 'e' or ch == 'i' or ch == 'o' or ch == 'u':                return True        return False\n\nclass Solution {unordered_set&lt;char&gt; ust = {'a', 'e', 'i', 'o', 'u'};public:    bool doesAliceWin(string s) {        int n = 0;        for (const auto&amp; ch : s) {            if (ust.count(ch)) n++;        }        return n != 0;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题2785-将字符串中的元音字母排序","url":"/2025/09/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982785-%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%85%83%E9%9F%B3%E5%AD%97%E6%AF%8D%E6%8E%92%E5%BA%8F/","content":"题意给定英文字符串，将其中辅音字母保持不动，元音字母按ASCII序进行排序。\n思路将其中元音字母及对应位置记录下来，排序后填回即可。\n实现class Solution {unordered_set&lt;char&gt; ust{'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};public:    string sortVowels(string s) {        const int n = s.size();        vector&lt;int&gt; p;        vector&lt;char&gt; ch;        for (int i = 0; i &lt; n; i++) {            if (ust.count(s[i])) {                ch.push_back(s[i]);                p.push_back(i);            }        }        ranges::sort(ch);        for (int i = 0; i &lt; p.size(); i++) {            s[p[i]] = ch[i];        }        return s;    }};\n\nclass Solution:    def sortVowels(self, s: str) -&gt; str:        t = list(s)        vowels = \"aeiouAEIOU\"        p = []        ch = []        for i, c in enumerate(s):            if c in vowels:                p.append(i)                ch.append(c)        ch.sort()        for i, c in enumerate(ch):            t[p[i]] = c        return ''.join(t)\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题1733-需要教语言的最少人数","url":"/2025/09/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981733-%E9%9C%80%E8%A6%81%E6%95%99%E8%AF%AD%E8%A8%80%E7%9A%84%E6%9C%80%E5%B0%91%E4%BA%BA%E6%95%B0/","content":"题意有 n 种语言， m 个人，其中已知所有人已会的语言，同时知道某些人之间存在朋友关系。两两之间需要会任意同种语言才可交流。现欲教某些人同一种语言，使得所有朋友之间可以互相交流，求最少教几人。\n思路n 和 m 的范围都不是很大，均在 500 以内，那其实可以随便乱搞的。\n这里我是先找到所有存在无法交流朋友的人，枚举所教的语言，所需教的人即为 存在无法交流朋友的人 - 存在无法交流朋友且会该语言的人\n实现class Solution:    def minimumTeachings(self, n: int, languages: List[List[int]], friendships: List[List[int]]) -&gt; int:        know = list(map(set, languages))                p = set()        for u, v in friendships:            if know[u - 1].isdisjoint(know[v - 1]):                p.add(u - 1)                p.add(v - 1)        ans = len(languages)        for i in range(1, n + 1):            ans = min(ans, len(p) - sum(i in know[x] for x in p))        return ans\n\nclass Solution {public:    int minimumTeachings(int n, vector&lt;vector&lt;int&gt;&gt;&amp; languages, vector&lt;vector&lt;int&gt;&gt;&amp; friendships) {        const int m = languages.size();        vector know(m, vector&lt;bool&gt; (n));        for (int i = 0; i &lt; m; i++) {            for (const auto&amp; x : languages[i]) {                know[i][x - 1] = true;            }        }        unordered_set&lt;int&gt; p;        for (const auto&amp; f : friendships) {            int u = f[0], v = f[1];            u--; v--;            bool need = true;            for (const auto&amp; x : languages[u]) {                if (know[v][x - 1]) {                    need = false;                    break;                }            }            if (need) {                p.insert(u);                p.insert(v);            }        }        int ans = m;        for (int i = 0; i &lt; n; i++) {            int t = 0;            for (const auto&amp; x : p) {                if (know[x][i]) t++;            }            ans = min(ans, int(p.size()) - t);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题2327-知道秘密的人数","url":"/2025/09/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982327-%E7%9F%A5%E9%81%93%E7%A7%98%E5%AF%86%E7%9A%84%E4%BA%BA%E6%95%B0/","content":"题意第 1 天有 1 个人知道了一个秘密，一个人在知道秘密的 forget 天后会遗忘这个秘密，同时一个人在知道秘密的 delay 天后未遗忘前会每天告诉一个新人这个秘密。求第 n 天后有多少人知道这个秘密。\n思路数据范围并不大 1 &lt;= n &lt;= 1000 那显然不是什么数学题不用推什么公式的。\n维护当前知道的人数、当前会每天告诉新人秘密的人数，以及每天新知道秘密的人数进行模拟即可。当前知道的人数 与 每天新知道秘密的人数 可以用 当前会每天告诉新人秘密的人数 更新，而 当前会每天告诉新人秘密的人数 可以通过 forget 天前与 delay 天前 新知道的人数更新。进行一个模拟即可。\n实现mod = 1000000007class Solution:    def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -&gt; int:        f = [1] + [0] * (n - 1)        ans = 1        p = 0        for i in range(n):            if i &gt;= delay:                p += f[i - delay]            if i &gt;= forget:                p -= f[i - forget]                ans -= f[i - forget]            f[i] += p            ans += p        return (ans + mod) % mod\n\nclass Solution {static constexpr int mod = 1e9 + 7;public:    int peopleAwareOfSecret(int n, int delay, int forget) {        vector&lt;int&gt; f(n);        int ans = 1, p = 0;        f[0] = 1;        for (int i = 0; i &lt; n; i++) {            if (i &gt;= delay) {                p += f[i - delay];                if (p &gt;= mod) p -= mod;            }            if (i &gt;= forget) {                p -= f[i - forget];                p += mod;                if (p &gt;= mod) p -= mod;                ans -= f[i - forget];                ans += mod;                if (ans &gt;= mod) ans -= mod;            }            f[i] += p;            ans += p;            if (ans &gt;= mod) ans -= mod;        }        return (ans + mod) % mod;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题1317-将整数转换为两个无零整数的和","url":"/2025/09/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981317-%E5%B0%86%E6%95%B4%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%B8%A4%E4%B8%AA%E6%97%A0%E9%9B%B6%E6%95%B4%E6%95%B0%E7%9A%84%E5%92%8C/","content":"题意给定一个正整数 n 将其拆分为两个十进制下不含 0 的数的和。\n思路注意到数据范围并不大， 2 &lt;= n &lt;= 1e4 ，那咱们简单问题简单做进行一个枚举即可。\n实现class Solution {public:    vector&lt;int&gt; getNoZeroIntegers(int n) {        auto check = [](int x) -&gt; bool {            string s = to_string(x);            for (char ch : s) {                if (ch == '0') return false;            }            return true;        };        for (int i = 1; i &lt; n; i++) {            if (check(i) &amp;&amp; check(n - i)) return {i, n - i};        }        return {-1};    }};\n\nclass Solution:    def getNoZeroIntegers(self, n: int) -&gt; List[int]:        def check(x):            for ch in str(x):                if ch == '0':                    return False            return True        for i in range(1, n):            if check(i) and check(n - i):                return [i, n - i]        return -1\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题1304-和为零的 N 个不同整数","url":"/2025/09/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981304-%E5%92%8C%E4%B8%BA%E9%9B%B6%E7%9A%84-N-%E4%B8%AA%E4%B8%8D%E5%90%8C%E6%95%B4%E6%95%B0/","content":"题意给定整数 n 返回任意大小为 n 由不同整数组成且和为 0 的数组。\n思路比较简单的构造题，随便写写满足题意就可以了。\n实现class Solution {public:    vector&lt;int&gt; sumZero(int n) {        vector&lt;int&gt; ans(n);        for (int i = 0, t = 1; i &lt; n; i++) {            if (i &amp; 1) {                ans[i] = -(t++);            } else {                ans[i] = t;            }        }        if (n &amp; 1) ans[n - 1] = 0;        return ans;    }};\n\nclass Solution:    def sumZero(self, n: int) -&gt; List[int]:        ans = [0] * n        t = 1        for i in range(n):            if i &amp; 1:                ans[i] = -t                t += 1            else:                ans[i] = t        if n &amp; 1:            ans[-1] = 0        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题3495-使数组元素都变为零的最少操作次数","url":"/2025/09/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983495-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E9%83%BD%E5%8F%98%E4%B8%BA%E9%9B%B6%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","content":"题意给定一组询问 queries 每个询问给定两数 l, r 表示给出连续的整数数组 [l, r]，对于每个询问的每次操作，可以任选同一数组中的两个数 a, b 令 a = floor(a / 4), b = floor(b / 4) 。求将所有询问的数组中都变为 0 的最小操作次数之和。\n思路a = floor(a / 4) 等价于 a &gt;&gt;= 2 那么将 a 变为 0 的操作次数就是其二进制表示下的长度比二向上取整即 (a.bit_length() + 1) // 2 == a.bit_length() + 1 &gt;&gt; 1。\n但 [l, r] 的范围可能较大，不太好枚举，进行一个式子的推即可。\n实现def cal(x):    t = x.bit_length()    res = (t + 1 &gt;&gt; 1) * (x + 1 - (1 &lt;&lt; t &gt;&gt; 1))    res += sum((i + 1 &gt;&gt; 1) * (1 &lt;&lt; i &gt;&gt; 1) for i in range(1, t))    return resclass Solution:    def minOperations(self, queries: List[List[int]]) -&gt; int:       return sum(cal(r) - cal(l - 1) + 1 &gt;&gt; 1 for l, r in queries) \n\nclass Solution {using ll = long long;public:    long long minOperations(vector&lt;vector&lt;int&gt;&gt;&amp; queries) {        auto cal = [&amp;](int x) -&gt; ll {            int t = bit_width(unsigned(x));            ll res = 1ll * ((t + 1) &gt;&gt; 1) * (x + 1 - (1 &lt;&lt; t &gt;&gt; 1));            for (int i = 1; i &lt; t; i++) {                res += 1ll * ((i + 1) &gt;&gt; 1) * (1 &lt;&lt; i &gt;&gt; 1);            }            return res;        };        ll ans = 0;        for (const auto&amp; q : queries) {            ans += (cal(q[1]) - cal(q[0] - 1) + 1) &gt;&gt; 1;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题2749-得到整数零需要执行的最少操作数","url":"/2025/09/05/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982749-%E5%BE%97%E5%88%B0%E6%95%B4%E6%95%B0%E9%9B%B6%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%95%B0/","content":"题意给定两个整数 num1 与 num2 ，每一次操作可任选  令  。判断是否可以将 num1 减为 0 并求出最少操作次数。\n思路注意到 1 &lt;= num1 &lt;= 1e9 -1e9 &lt;= num2 &lt;= 1e9，显然最多的操作次数不会超过 40 次。对操作次数进行枚举即可。\n显然在操作 k 次后，剩余数转为二进制的 1 数量必须小于 k 且 剩余的数大于等于 k \n实现class Solution {using ll = long long;using ull = unsigned long long;public:    int makeTheIntegerZero(int num1, int num2) {        for (int k = 1; k &lt;= 40; k++) {            ll t = num1 - 1ll * num2 * k;            if (t &lt;= 0) break;            if (popcount(ull(t)) &lt;= k &amp;&amp; t &gt;= k) return k;        }        return -1;    }};\n\nclass Solution:    def makeTheIntegerZero(self, num1: int, num2: int) -&gt; int:        for k in range(1, 40):            t = num1 - k * num2            if t &lt;= 0:                break            if t.bit_count() &lt;= k and t &gt;= k:                return k        return -1\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题3516-找到最近的人","url":"/2025/09/04/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983516-%E6%89%BE%E5%88%B0%E6%9C%80%E8%BF%91%E7%9A%84%E4%BA%BA/","content":"题意给定三个整数表示三个人的位置，第一第二人均向第三人以相同速度走去而第三人不动，求谁先碰上第三人。\n思路没什么特别的，两人相遇时间显然可以用距离表示，比较第一第二人与第三人的距离即可。\n实现class Solution {public:    int findClosest(int x, int y, int z) {        int t = abs(x - z) - abs(y - z);        if (t &lt; 0) return 1;        else if (t == 0) return 0;        return 2;    }};\n\nclass Solution:    def findClosest(self, x: int, y: int, z: int) -&gt; int:        t = abs(x - z) - abs(y - z)        if t &lt; 0:            return 1        elif t == 0:            return 0        return 2\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题3027-人员站位的方案数II","url":"/2025/09/03/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983027-%E4%BA%BA%E5%91%98%E7%AB%99%E4%BD%8D%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0II/","content":"题意给定 n 个点，求有多少点对 (A, B) 满足 A 在 B 的左上角且以 AB 为对角线的矩形内无其他点。\n思路那和昨天的题是完全一样的，只是数据范围进行了增强 1 &lt;= n &lt;= 1000 ，那就没办法继续暴力了，使用昨日的cpp实现方法：按坐标进行排序即可。\n实现class Solution:    def numberOfPairs(self, points: List[List[int]]) -&gt; int:        points.sort(key=lambda p: (p[0], -p[1]))        ans = 0        for i, (x0, y0) in enumerate(points):            my = -inf            for (x1, y1) in points[i + 1 : ]:                if y1 &lt;= y0 and y1 &gt; my:                    my = y1                    ans += 1                if my &gt;= y0:                    break        return ans\n\nclass Solution {public:    int numberOfPairs(vector&lt;vector&lt;int&gt;&gt;&amp; points) {        ranges::sort(points, [&amp;](const auto&amp; x, const auto&amp; y) {            if (x[0] == y[0]) return x[1] &gt; y[1];            return x[0] &lt; y[0];        });        int ans = 0;        const int n = points.size();        for (int i = 0; i &lt; n; i++) {            int my = INT_MIN;            for (int j = i + 1; j &lt; n &amp;&amp; my &lt; points[i][1]; j++) {                if (points[j][1] &lt;= points[i][1] &amp;&amp; points[j][1] &gt; my) {                    my = points[j][1];                    ans++;                }            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题3025-人员站位的方案数I","url":"/2025/09/02/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983025-%E4%BA%BA%E5%91%98%E7%AB%99%E4%BD%8D%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0I/","content":"题意给定 n 个点，求有多少点对 (A, B) 满足 A 在 B 的左上角且以 AB 为对角线的矩形内无其他点。\n思路注意到数据范围很小 1 &lt;= n &lt;= 50 所以可以直接暴力判断（见python）实现。\n也可以对点的坐标进行排序判断（见cpp实现）。\n实现class Solution:    def numberOfPairs(self, points: List[List[int]]) -&gt; int:        ans = 0        for x0, y0 in points:            for x1, y1 in points:                if (x1 == x0 and y1 == y0) or (x1 &lt; x0 or y1 &gt; y0):                    continue                ans += 1                for x2, y2 in points:                    if (x0 == x2 and y0 == y2) or (x1 == x2 and y1 == y2):                        continue                    if x0 &lt;= x2 &lt;= x1 and y1 &lt;= y2 &lt;= y0:                        ans -= 1                        break        return ans\n\nclass Solution {public:    int numberOfPairs(vector&lt;vector&lt;int&gt;&gt;&amp; points) {        ranges::sort(points, [&amp;](const auto&amp; x, const auto&amp; y) {            if (x[0] == y[0]) return x[1] &gt; y[1];            return x[0] &lt; y[0];        });        int ans = 0;        const int n = points.size();        for (int i = 0; i &lt; n; i++) {            int my = INT_MIN;            for (int j = i + 1; j &lt; n &amp;&amp; my &lt; points[i][1]; j++) {                if (points[j][1] &lt;= points[i][1] &amp;&amp; points[j][1] &gt; my) {                    my = points[j][1];                    ans++;                }            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题1792-最大平均通过率","url":"/2025/09/01/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981792-%E6%9C%80%E5%A4%A7%E5%B9%B3%E5%9D%87%E9%80%9A%E8%BF%87%E7%8E%87/","content":"题意给定每个班级的总人数以及通过考试的人数，同时给定 extraStudents 个保证可以通过考试的人数，需将这 extraStudents 个学生分配到各个班级，使得各班级的平均通过率最大。求最大班级平均通过率。\n思路可以发现给不同的班级分配必过学生对通过率的影响是不同的，那直接根据这个影响进行排序开贪即可。由于有多个额外学生，使用优先队列进行维护就好。\n实现class Solution {public:    double maxAverageRatio(vector&lt;vector&lt;int&gt;&gt;&amp; classes, int extraStudents) {        auto cmp = [&amp;](const auto&amp; x, const auto&amp; y) {            return 1ll * (x[1] - x[0]) * (y[1] + 1) * y[1] &lt; 1ll * (y[1] - y[0]) * (x[1] + 1) * x[1];        };        priority_queue&lt;array&lt;int, 2&gt;, vector&lt;array&lt;int, 2&gt;&gt;, decltype(cmp)&gt; pq(cmp);        for (const auto&amp; vec : classes) {            pq.push({vec[0], vec[1]});        }        while (extraStudents--) {            auto [x, y] = pq.top();            pq.pop();            pq.push({x + 1, y + 1});        }        double s = 0;        int n = classes.size();        while (!pq.empty()) {            auto [x, y] = pq.top();            pq.pop();            s += 1.0 * x / y;        }        return s / n;    }};\n\nclass Solution:    def maxAverageRatio(self, classes: List[List[int]], extraStudents: int) -&gt; float:        pq = [(-((a + 1) / (b + 1) - a / b), a, b) for a, b in classes]        heapify(pq)        for _ in range(extraStudents):            _, a, b = pq[0]            a += 1            b += 1            heapreplace(pq, (-((a + 1) / (b + 1) - a / b), a, b))        return sum(a / b for _, a, b in pq) / len(pq)\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题37-解数独","url":"/2025/08/31/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9837-%E8%A7%A3%E6%95%B0%E7%8B%AC/","content":"题意给定保证仅有单个解的数独，找到其的解。\n思路这确实没什么好的做法，直接 dfs 开搜即可。\n实现class Solution {static constexpr int N = 9;public:    void solveSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {        bool row[N][N]= {};        bool col[N][N]= {};        bool t[3][3][N]= {};        vector&lt;array&lt;int, 2&gt;&gt; spaces;        for (int i = 0; i &lt; N; i++) {            for (int j = 0; j &lt; N; j++) {                if (board[i][j] == '.') spaces.push_back({i, j});                else {                    int x = board[i][j] - '1';                    row[i][x] = col[j][x] = t[i / 3][j / 3][x] = true;                }            }        }        const int n = spaces.size();        auto dfs = [&amp;](this auto&amp;&amp; self, int loc) -&gt; bool {            if (loc == n) return true;            auto [i, j] = spaces[loc];            for (int x = 0; x &lt; N; x++) {                if (row[i][x] || col[j][x] || t[i / 3][j / 3][x]) continue;                row[i][x] = col[j][x] = t[i / 3][j / 3][x] = true;                board[i][j] = char('0' + x + 1);                if (self(loc + 1)) return true;                row[i][x] = col[j][x] = t[i / 3][j / 3][x] = false;            }            return false;        };        dfs(0);    }};\n\nclass Solution:    def solveSudoku(self, board: List[List[str]]) -&gt; None:        N = 9        row = [0] * (N * N)        col = [0] * (N * N)        t = [0] * (3 * 3 * N)        spaces = []        for i, tmp in enumerate(board):            for j, x in enumerate(tmp):                if x == '.':                    spaces.append((i, j))                else:                    tmp = int(x) - 1                    row[i * N + tmp] = 1                    col[j * N + tmp] = 1                    t[i // 3 * 3 * N + j // 3 * N + tmp] = 1        n = len(spaces)        def dfs(loc):            if loc == n:                return True            i, j = spaces[loc]            for x in range(N):                if row[i * N + x] or col[j * N + x] or t[i // 3 * N * 3 + j // 3 * N + x]:                    continue                row[i * N + x] = col[j * N + x] = t[i // 3 * N * 3 + j // 3 * N + x] = 1                board[i][j] = str(x + 1)                if dfs(loc + 1):                    return True                row[i * N + x] = col[j * N + x] = t[i // 3 * N * 3 + j // 3 * N + x] = 0            return False        dfs(0)\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题36-有效的数独","url":"/2025/08/30/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9836-%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/","content":"题意给定一个已经填了部分的数独，判断所填部分是否合法。\n思路就是简单模拟一下判断是否每行每列每九宫格无重即可。\n实现class Solution {static constexpr int N = 9;public:    bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) {        array&lt;int, 10&gt; vis;        for (int i = 0; i &lt; N; i++) {            vis.fill(0);            for (int j = 0; j &lt; N; j++) {                if (board[i][j] == '.') continue;                int&amp; t = vis[board[i][j] - '0'];                if (t) return false;                t++;            }            vis.fill(0);            for (int j = 0; j &lt; N; j++) {                if (board[j][i] == '.') continue;                int&amp; t = vis[board[j][i] - '0'];                if (t) return false;                t++;            }        }        for (int i = 0; i &lt; N; i += 3) {            for (int j = 0; j &lt; N; j += 3) {                vis.fill(0);                for (int x = 0; x &lt; 3; x++)                for (int y = 0; y &lt; 3; y++)                if (isdigit(board[i + x][j + y])) {                    int&amp; t = vis[board[i + x][j + y] - '0'];                    if (t) return false;                    t++;                }            }        }        return true;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3021-Alice和Bob玩鲜花游戏","url":"/2025/08/29/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983021-Alice%E5%92%8CBob%E7%8E%A9%E9%B2%9C%E8%8A%B1%E6%B8%B8%E6%88%8F/","content":"题意Alice 和 Bob 站在环形花环上回合游戏。Alice 和 Bob 之间顺时针有 x 朵花 逆时针有 y 朵花，每回合可任选一侧摘下一朵花，若某次行动后两者间一侧无花则该行动者胜利，Alice 先手。对于给定的数 n 和 m 有 1 &lt;= x &lt;= n 与 1 &lt;= y &lt;= m ，求有多少对 (x, y) 满足 Alice 必胜\n思路转换一下就是两堆牌轮流取一张，谁先取到某堆最后一张则胜利。那就是很经典的博弈问题了，我们先手玩一下：\n\n任意一堆为 0 ，那显然是该回合玩家失败（上一回合的玩家将某堆摸为0）\n两堆均为偶数，不论先手摸哪一堆，只要后手同样摸同一堆，局面就仍可保持为两堆偶直到某一堆为0，故而有先手必败\n一堆奇数一堆偶数，先手玩家只要选择偶数堆进行取牌，局面就会变为两堆偶即上一种情况也即为下一个玩家必败，故先手必胜\n两堆奇数，不论先手摸哪一堆，后手只要摸另一堆就会造成双偶数局面，故而有先手必败\n\n综上，合法开局 (x, y) 中有且仅有 x 与 y 一奇一偶时满足 Alice 必胜，进行计算对应数量即可。\n实现class Solution {using ll = long long;public:    long long flowerGame(int n, int m) {        return 1ll * (n + 1 &gt;&gt; 1) * (m &gt;&gt; 1) + 1ll * (n &gt;&gt; 1) * (m + 1 &gt;&gt; 1);    }};\n\nclass Solution:    def flowerGame(self, n: int, m: int) -&gt; int:        return (n + 1) // 2 * (m // 2) + n // 2 * ((m + 1) // 2)\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题3446-按对角线进行矩阵排序","url":"/2025/08/28/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983446-%E6%8C%89%E5%AF%B9%E8%A7%92%E7%BA%BF%E8%BF%9B%E8%A1%8C%E7%9F%A9%E9%98%B5%E6%8E%92%E5%BA%8F/","content":"题意给定方形矩阵，将其左下部分的对角线按非增排序（含中线），将其右上部分的对角线按非减排序。\n思路好像也没什么特别的做法与性质，就是列出每条对角线的数字按照对应规则排序后再放回即可。\n实现class Solution {public:    vector&lt;vector&lt;int&gt;&gt; sortMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {        const int n = grid.size();        for (int i = 0; i &lt; n; i++) {            vector&lt;int&gt; tmp;            for (int j = 0; i + j &lt; n; j++) tmp.push_back(grid[i + j][j]);            ranges::sort(tmp, greater());            for (int j = 0; i + j &lt; n; j++) grid[i + j][j] = tmp[j];        }        for (int i = 1; i &lt; n; i++) {            vector&lt;int&gt; tmp;            for (int j = 0; i + j &lt; n; j++) tmp.push_back(grid[j][i + j]);            ranges::sort(tmp);            for (int j = 0; i + j &lt; n; j++) grid[j][i + j] = tmp[j];        }        return grid;    }};\n\nclass Solution:    def sortMatrix(self, grid: List[List[int]]) -&gt; List[List[int]]:        n = len(grid)        for i in range(n):            tmp = [grid[i + j][j] for j in range(n - i)]            tmp.sort(reverse=True)            for j in range(n - i):                grid[i + j][j] = tmp[j]        for i in range(1, n):            tmp = [grid[j][i + j] for j in range(n - i)]            tmp.sort()            for j in range(n - i):                grid[j][i + j] = tmp[j]        return grid\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题3459-最长V形对角线段的长度","url":"/2025/08/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983459-%E6%9C%80%E9%95%BFV%E5%BD%A2%E5%AF%B9%E8%A7%92%E7%BA%BF%E6%AE%B5%E7%9A%84%E9%95%BF%E5%BA%A6/","content":"题意给定二维矩阵，对 V形对角线段 定义如下：\n\n线段必须从 1 开始，线段上数形如 1, 2, 0, 2, 0 ...\n沿某一对角线方向扩展，最多允许顺时针 90° 转变一次方向\n\n求矩阵内最长 V行对角线段 长度。\n思路那没有什么特别的性质，数据范围也比较合适 1 &lt;= n, m &lt;= 500 ，那就直接 dfs 搜索即可。\n实现class Solution {static constexpr array&lt;int, 2&gt; nxt[] = {    {1, 1}, {1, -1}, {-1, -1}, {-1, 1}};public:    int lenOfVDiagonal(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {        const int n = grid.size(), m = grid.front().size();        int ans = 0;        vector mem(2, vector (4, vector (n, vector&lt;int&gt; (m))));        auto dfs = [&amp;](this auto&amp;&amp; self, int x, int y, int to, int k, bool turn) -&gt; int {            auto [tx, ty] = nxt[to];            x += tx; y += ty;            if (x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m || grid[x][y] != k) return 0;            int&amp; tmp = mem[turn][to][x][y];            if (tmp) return tmp;            tmp = self(x, y, to, k ^ 2, turn) + 1;            if (turn) {                tmp = max(tmp, self(x, y, (to + 1) % 4, k ^ 2, false) + 1);            }            return tmp;        };                for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; m; j++) {                if (grid[i][j] == 1) {                    for (int k = 0; k &lt; 4; k++) {                        ans = max(ans, dfs(i, j, k, 2, true) + 1);                    }                }            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3000-对角线最长的矩形的面积","url":"/2025/08/26/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983000-%E5%AF%B9%E8%A7%92%E7%BA%BF%E6%9C%80%E9%95%BF%E7%9A%84%E7%9F%A9%E5%BD%A2%E7%9A%84%E9%9D%A2%E7%A7%AF/","content":"题意给定一些矩形的长宽，求对角线最长的矩形的面积，若存在多个矩形对角线同长，返回对角线最长且面积最大的矩形面积。\n思路直接遍历矩阵进行计算比较即可，避免开方的耗时与精度问题直接使用对角线的平方进行比较就好。\n实现class Solution {public:    int areaOfMaxDiagonal(vector&lt;vector&lt;int&gt;&gt;&amp; dimensions) {        int mx = 0, mxspace = 0;        for (const auto&amp; vec : dimensions) {            int x = vec[0], y = vec[1];            int t = x * x + y * y;            if (t &gt; mx) {                mx = t;                mxspace = x * y;            } else if (t == mx) {                mxspace = max(mxspace, x * y);            }        }        return mxspace;    }};\n\nclass Solution:    def areaOfMaxDiagonal(self, dimensions: List[List[int]]) -&gt; int:        return max((x * x + y * y, x * y) for x, y in dimensions)[1]\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题498-对角线遍历","url":"/2025/08/25/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98498-%E5%AF%B9%E8%A7%92%E7%BA%BF%E9%81%8D%E5%8E%86/","content":"题意给定矩阵，返回将矩阵按对角线遍历展开的结果。\n思路就是简单的模拟题，注意处理好边界即可。\n实现class Solution:    def findDiagonalOrder(self, mat: List[List[int]]) -&gt; List[int]:        n = len(mat)        m = len(mat[0])        ans = [0] * (m * n)        tot = 0        for i in range(0, n + m - 1):            mn = max(i - m + 1, 0)            mx = min(i, n - 1)            if i &amp; 1:                for j in range(mn, mx + 1):                    ans[tot] = mat[j][i - j]                    tot += 1            else:                for j in range(mx, mn - 1, -1):                    ans[tot] = mat[j][i - j]                    tot += 1        return ans\n\nclass Solution {public:    vector&lt;int&gt; findDiagonalOrder(vector&lt;vector&lt;int&gt;&gt;&amp; mat) {        const int n = mat.size(), m = mat.front().size();        vector&lt;int&gt; ans(n * m);        for (int i = 0, tot = 0; i &lt; n + m - 1; i++) {            int mn = max(i - m + 1, 0);            int mx = min(i, n - 1);            if (i &amp; 1) {                for (int j = mn; j &lt;= mx; j++) ans[tot++] = mat[j][i - j];            } else {                for (int j = mx; j &gt;= mn; j--) ans[tot++] = mat[j][i - j];            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题1493-删掉一个元素以后全为1的最长子数组","url":"/2025/08/24/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981493-%E5%88%A0%E6%8E%89%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BB%A5%E5%90%8E%E5%85%A8%E4%B8%BA1%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84/","content":"题意给定 0/1 数组，需从中删除任意一个元素，求剩余元素中最长仅含 1 的子数组长度。\n思路可以考虑枚举删哪一个数，使用前后缀处理该数前后连续的 1 的个数即可（见cpp实现）。\n也可以考虑使用滑动窗口，我们必须删除一个数，那显然窗口内最多同时可以有一个 0 ，维护一下窗口的左右范围以及区间内 0 的个数即可（见 python实现）。\n实现class Solution:    def longestSubarray(self, nums: List[int]) -&gt; int:        l = cnt = ans = 0        for r, x in enumerate(nums):            if x == 0:                cnt += 1            while cnt &gt; 1:                if nums[l] == 0:                    cnt -= 1                l += 1            ans = max(r - l, ans)        return ans\n\nclass Solution {public:    int longestSubarray(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        vector&lt;int&gt; pre(n + 1);        for (int i = 0; i &lt; n; i++) {            if (nums[i]) pre[i + 1] = pre[i] + 1;        }        int ans = 0;        for (int i = n - 1, suf = 0; i &gt;= 0; i--) {            ans = max(ans, pre[i] + suf);            if (nums[i]) {                suf++;            } else {                suf = 0;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题3197-包含所有1的最小矩形面积II","url":"/2025/08/23/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983197-%E5%8C%85%E5%90%AB%E6%89%80%E6%9C%891%E7%9A%84%E6%9C%80%E5%B0%8F%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AFII/","content":"题意给定 0/1 矩阵，需找到 3 个不重叠且面积非零的矩形，将矩阵中所有 1 都包含在这三矩形中。求最小三矩形面积和。\n思路这里的数据范围是不大的 1 &lt;= n, m &lt;= 30 那直接进行枚举三个矩阵的边界然后使用昨天的贪心计算方法即可。这里可以注意到共有 6 种划分方法，但是其中 3 种可以通过旋转矩阵等价得来，因此可以稍稍偷懒一些。\n实现class Solution {public:    int minimumSum(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {        auto cal = [&amp;](int a, int b, int c, int d) -&gt; int {            int le = 100, lo = 100;            int hi = 0, ri = 0;            for (int i = a; i &lt; b; i++)                for (int j = c; j &lt; d; j++)                    if (grid[i][j]) {                        le = min(le, j);                        lo = min(lo, i);                        hi = max(hi, i);                        ri = max(ri, j);                    }                                return (hi - lo + 1) * (ri - le + 1);        };        auto rotate = [&amp;]() -&gt; void {            const int n = grid.size(), m = grid.front().size();            vector tmp(m, vector&lt;int&gt; (n));            for (int i = 0; i &lt; n; i++) {                for (int j = 0; j &lt; m; j++) {                    tmp[j][n - i - 1] = grid[i][j];                }            }            swap(tmp, grid);        };        int ans = 1e9;        auto work = [&amp;]() -&gt; void {            const int n = grid.size(), m = grid.front().size();            if (n &gt;= 3) {                for (int i = 1; i &lt; n; i++)                    for (int j = i + 1; j &lt; n; j++) {                        int tmp = cal(0, i, 0, m);                        tmp += cal(i, j, 0, m);                        tmp += cal(j, n, 0, m);                        ans = min(ans, tmp);                    }            }            if (n &gt;= 2 &amp;&amp; m &gt;= 2) {                for (int i = 1; i &lt; n; i++)                    for (int j = 1; j &lt; m; j++) {                        int tmp = cal(0, i, 0, m);                        tmp += cal(i, n, 0, j);                        tmp += cal(i, n, j, m);                        ans = min(ans, tmp);                        tmp = cal(i, n, 0, m);                        tmp += cal(0, i, 0, j);                        tmp += cal(0, i, j, m);                        ans = min(ans, tmp);                    }            }        };        work();        rotate();        work();        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3195-包含所有1的最小矩形面积I","url":"/2025/08/22/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983195-%E5%8C%85%E5%90%AB%E6%89%80%E6%9C%891%E7%9A%84%E6%9C%80%E5%B0%8F%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AFI/","content":"题意给定 0/1 矩阵，求包含所有 1 的最小矩阵面积。\n思路需要包含所有的 1 那找到最上、最下、最左最右的 1 的位置并以其为答案的边即可。\n实现class Solution {public:    int minimumArea(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {        const int n = grid.size(), m = grid.front().size();        int hi, lo = -1, le = m, ri = -1;        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; m; j++) {                if (grid[i][j]) {                    hi = i;                    if (lo == -1) lo = i;                    le = min(le, j);                    ri = max(ri, j);                }            }        }        return (hi - lo + 1) * (ri - le + 1);    }};\n\nclass Solution:    def minimumArea(self, grid: List[List[int]]) -&gt; int:        lo = inf        hi = -1        le = inf        ri = -1        for i, row in enumerate(grid):            for j, x in enumerate(row):                if x:                    lo = min(lo, i)                    le = min(le, j)                    hi = max(hi, i)                    ri = max(ri, j)        return (hi - lo + 1) * (ri - le + 1)\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题1504-统计全1子矩形","url":"/2025/08/21/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981504-%E7%BB%9F%E8%AE%A1%E5%85%A81%E5%AD%90%E7%9F%A9%E5%BD%A2/","content":"题意给定 m * n 的 0/1 矩阵，求其中全为 1 的子矩阵个数。\n思路好像很不好做啊，但是我们观察数据范围 1 &lt;= m, n &lt;= 150 那可以随便乱搞了。\n仔细一想，是不是可以转换为我们曾经做过的题：有 n 个任意高度宽为 1 的柱子并排，求矩阵面积和。这里我们可以枚举柱子的底部，高度则为纵向上连续的 1 的个数，那就很好做了。\n实现class Solution {public:    int numSubmat(vector&lt;vector&lt;int&gt;&gt;&amp; mat) {        const int n = mat.size(), m = mat.front().size();        vector&lt;int&gt; h(m);        int ans = 0;        for (int i = 0; i &lt; n; i++) {            vector&lt;array&lt;int, 3&gt;&gt; stk;            for (int j = 0, left = -1; j &lt; m; j++) {                if (mat[i][j]) {                    h[j]++;                    while (!stk.empty() &amp;&amp; stk.back()[0] &gt;= h[j]) stk.pop_back();                    if (stk.empty()) {                        int t = (j - left) * h[j];                        ans += t;                        stk.push_back({h[j], j, t});                    } else {                        auto [high, l, t] = stk.back();                        t += (j - l) * h[j];                        ans += t;                        stk.push_back({h[j], j, t});                    }                } else {                    h[j] = 0;                    stk.clear();                    left = j;                }            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1277-统计全为1的正方形子矩阵","url":"/2025/08/20/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981277-%E7%BB%9F%E8%AE%A1%E5%85%A8%E4%B8%BA1%E7%9A%84%E6%AD%A3%E6%96%B9%E5%BD%A2%E5%AD%90%E7%9F%A9%E9%98%B5/","content":"题意给定 m * n 的 0/1 数组，返回其中由全 1 构成的正方形个数。\n思路那与昨天的思路其实是非常类似的，只是昨天是求全 0 的子数组个数，今天是求全 1 的正方形个数，也就是从 1 维变 2 维了而已。使用同样的思想：往已有全 1 正方形的右/下/右下再添加一个 1 可以贡献多少个新正方形呢，由于这里需要考虑三个方向的情况，故而不再简单的使用一个变量维护，而是新开一个二维数组做递推，或者直接在 matrix 上做。\n实现class Solution {public:    int countSquares(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {        const int n = matrix.size(), m = matrix.front().size();        int ans = 0;        for (int i = 0; i &lt; n; i++) {            for (int j = 0; j &lt; m; j++) {                if (i &amp;&amp; j &amp;&amp; matrix[i][j]) {                    matrix[i][j] += min({matrix[i - 1][j - 1], matrix[i - 1][j], matrix[i][j - 1]});                }                ans += matrix[i][j];            }        }        return ans;    }};\n\nclass Solution:    def countSquares(self, matrix: List[List[int]]) -&gt; int:        n = len(matrix)        m = len(matrix[0])        ans = 0        for i in range(n):            for j in range(m):                if i and j and matrix[i][j]:                    matrix[i][j] += min(matrix[i - 1][j - 1], matrix[i - 1][j], matrix[i][j - 1])                ans += matrix[i][j]        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题2348-全 0 子数组的数目","url":"/2025/08/19/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982348-%E5%85%A8-0-%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定数组 nums ，返回全部为 0 的子数组数目。\n思路比较简单的思路就是找到每个全为零的块，然后单个全零块可以分割为多少个子数组呢，若长度为 n 显然是有 n 个长度为 1 的子数组， n - 1 个长度为 2 的子数组.... 那显然应该是一个等差数列求和  个。\n虽然都是 O(n) 的，但乘除的常数是比较大，这里还有一个比较经典的思路：对于一个全零的数组，在其末尾再添加一个 0 ，新添加的零可以贡献多少全零子数组呢，显然是原数组长度加一，根据此思路进行计算即可。\n实现cpp 与 等差\nclass Solution {using ll = long long;public:    long long zeroFilledSubarray(vector&lt;int&gt;&amp; nums) {        ll ans = 0;        const int n = nums.size();        for (int i = 0; i &lt; n; i++) {            if (nums[i]) continue;            int j;            for (j = i + 1; j &lt; n &amp;&amp; nums[j] == 0; j++);            ans += 1ll * (j - i + 1) * (j - i) / 2;            i = j - 1;        }        return ans;    }};\n\ncpp\nclass Solution {using ll = long long;public:    long long zeroFilledSubarray(vector&lt;int&gt;&amp; nums) {        ll ans = 0;        int cur = 0;        for (const auto&amp; x : nums) {            if (x) cur = 0;            else ans += ++cur;        }        return ans;    }};\n\npython\nclass Solution:    def zeroFilledSubarray(self, nums: List[int]) -&gt; int:        ans = 0        cur = 0        for x in nums:            if x == 0:                cur += 1                ans += cur            else:                cur = 0        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题679-24 点游戏","url":"/2025/08/18/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98679-24-%E7%82%B9%E6%B8%B8%E6%88%8F/","content":"题意给定长度为 4 的数组 cards, 可以将其上数字按任意顺序排列并在任意合法位置加上符号 + - * / ( ) ，判断是否可以通过得到的式子算出结果 24\n思路注意到数据量并不大，直接进行枚举模拟即可。\n实在有点麻烦，这里我就不用python再写一遍了。\n实现class Solution {static constexpr long double eps = 1e-9;using ld = long double;public:    bool judgePoint24(vector&lt;int&gt;&amp; cards) {        auto dfs = [&amp;](this auto&amp;&amp; self, vector&lt;ld&gt;&amp; nums) -&gt; bool {            if (nums.size() == 1) return fabsl(nums[0] - 24.0) &lt;= eps;            for (int i = 0; i &lt; nums.size(); i++) {                for (int j = 0; j &lt; nums.size(); j++) {                    if (i == j) continue;                    vector&lt;ld&gt; nxt;                    for (int k = 0; k &lt; nums.size(); k++) if (k != i &amp;&amp; k != j) nxt.push_back(nums[k]);                    for (char op : {'+', '-', '*', '/'}) {                        if ((op == '+' || op == '*') &amp;&amp; i &gt; j) continue;                        if (op == '+') nxt.push_back(nums[i] + nums[j]);                        if (op == '-') nxt.push_back(nums[i] - nums[j]);                        if (op == '*') nxt.push_back(nums[i] * nums[j]);                        if (op == '/' &amp;&amp; fabsl(nums[j]) &gt; eps) nxt.push_back(nums[i] / nums[j]);                        if (nxt.size() == nums.size() - 1 &amp;&amp; self(nxt)) return true;                        if (!nxt.empty()) nxt.pop_back();                    }                }            }            return false;        };        vector&lt;ld&gt; a(cards.begin(), cards.end());        return dfs(a);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题837-新21点","url":"/2025/08/17/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98837-%E6%96%B021%E7%82%B9/","content":"题意给定正整数 n k maxPts。当爱丽丝分数小于 k 时就会不停抽卡，每次抽卡等概率得分 [1, maxPts] ，求爱丽丝最总分数不超过 n 的概率。\n思路求不超过 n 的概率，又分数小于 k 时会不停抽卡，那也就是求得分为 [k, n] 的概率。那就是一个比较经典的概率dp了，进行一个递推求概率即可。\n实现class Solution {public:    double new21Game(int n, int k, int maxPts) {        if (maxPts &lt;= n - k + 1 || k == 0) return 1.0;        vector&lt;double&gt; f(n + 1);        f[0] = 1.0;        double pre = 1.0;        for (int i = 1; i &lt;= n; i++) {            if (i &gt; maxPts) pre -= f[i - maxPts - 1];            f[i] = pre / maxPts;            if (i &lt; k) pre += f[i];        }        return accumulate(f.begin() + k, f.end(), 0.0);    }};\n\nclass Solution:    def new21Game(self, n: int, k: int, maxPts: int) -&gt; float:        if n - k + 1 &gt;= maxPts or k == 0:            return 1                f = [1] + [0] * n        pre = 1        for i in range(1, n + 1):            if i &gt; maxPts:                pre -= f[i - maxPts - 1]            f[i] = pre / maxPts            if (i &lt; k):                pre += f[i]        return sum(f[k :])\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题1323-6 和 9 组成的最大数字","url":"/2025/08/16/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981323-6-%E5%92%8C-9-%E7%BB%84%E6%88%90%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AD%97/","content":"题意给定仅由 6 和 9 组成的正整数 num。可以将 num 中一个 6 变成 9 ，或将一个 9 变成 6 或不进行操作。求可以得到的最大数字。\n思路由于题目给定了是正整数，那可以直接贪心地找到第一个 6 将其变为 9 即可，若无 6 直接不操作。\n实现class Solution {public:    int maximum69Number (int num) {        string n = to_string(num);        for (int i = 0; i &lt; n.size(); i++) {            if (n[i] == '6') {                n[i] = '9';                break;            }        }        return stoi(n);    }};\n\nclass Solution:    def maximum69Number (self, num: int) -&gt; int:        s = str(num)        for i in range(len(s)):            if s[i] == '6':                return int(s[ : i] + '9' + s[i + 1 : ])        return num\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题342-4的幂","url":"/2025/08/15/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98342-4%E7%9A%84%E5%B9%82/","content":"题意给定整数 n 判断其是否为 4 的幂次\n思路简单问题简单做就好。\n当然也有更加快的，首先 4 的幂次，肯定也是 2 的幂次  嘛；那前几天我们就有做过判断是否为 2 的幂次的题。\n但显然还是不够判断的，我们转成二进制视角，还可以发现 4 的幂次是在第 0 2 4 6... 等位上有 1 的（4 == 1 &lt;&lt; 2），将其提取出来使用位掩码 0x55555555 即可。\n实现class Solution {public:    bool isPowerOfFour(int n) {        return n &gt; 0 &amp;&amp; (n &amp; -n) == n &amp;&amp; (n &amp; 0x55555555);    }};\n\nclass Solution:    def isPowerOfFour(self, n: int) -&gt; bool:        return n &gt; 0 and (n &amp; -n) == n and (n &amp; 0x55555555) &gt; 0\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题1780-判断一个数字是否可以表示成三的幂的和","url":"/2025/08/14/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981780-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E8%A1%A8%E7%A4%BA%E6%88%90%E4%B8%89%E7%9A%84%E5%B9%82%E7%9A%84%E5%92%8C/","content":"题意给定正整数 n ，判断 n 是否可以表示成若干不同的三的幂次和。\n思路三的幂次和，那和二的幂次和没什么本质区别的，表示方式都是唯一的，可以从数据范围内最大的三次幂开始，若 n 大于等于该数则减去该数，判断 n 最终是否为 0 即可.\n也可以将 n 转换为 3 进制，判断每一位是否均为 0 或 1\n实现class Solution {public:    bool checkPowersOfThree(int n) {        for (int i = 4782969; i; i /= 3) {            if (n &gt;= i) n -= i;        }        return n == 0;    }};\n\nclass Solution:    def checkPowersOfThree(self, n: int) -&gt; bool:        while n &gt; 1:          if n % 3 == 2:            return False          n //= 3        return True\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题326-3的幂","url":"/2025/08/13/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98326-3%E7%9A%84%E5%B9%82/","content":"题意给定整数 n 判断其是否为 3 的幂次。\n思路简单问题简单做，这题数据范围是 int 那最多不会超过 20 次运算，直接暴力就好。\n当然也有更加快的方法，首先可以预处理然后判断一下是否在集合中。\n最快的做法则是使用数据范围内最大的 3 的幂次，若 n 可以整除该数则 n 为 3 的幂次。\n实现class Solution {public:    bool isPowerOfThree(int n) {        if (n &lt; 1) return false;        while (n &gt; 1) {            if (n % 3) return false;            n /= 3;        }        return true;    }};\n\nclass Solution:    def isPowerOfThree(self, n: int) -&gt; bool:        if n &lt; 1:            return False        while n &gt; 1:            if n % 3 != 0:                return False            n /= 3        return True\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题2787-将一个数字表示成幂的和的方案数","url":"/2025/08/12/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982787-%E5%B0%86%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E8%A1%A8%E7%A4%BA%E6%88%90%E5%B9%82%E7%9A%84%E5%92%8C%E7%9A%84%E6%96%B9%E6%A1%88%E6%95%B0/","content":"题意给定正整数 n 和 x， 返回将 n 表示成一些互不相同的的正整数的 x 次幂之和的方案数，对 1e9 + 7 取模。\n思路那就是一个比较经典的 0-1背包问题，显然只需枚举 x 次幂小于等于 n 的数即可，必然是不会有特别多的数的，然后进行背包就好。\n实现using ll = long long;constexpr int mod = 1e9 + 7;int pow_(int a, int b) {    int res = 1;    for ( ; b; b &gt;&gt;= 1, a *= a) {        if (b &amp; 1) res *= a;    }    return res;}class Solution {public:    int numberOfWays(int n, int x) {        vector&lt;int&gt; f;        for (int i = 1; true; i++) {            int p = pow_(i, x);            if (p &gt; n) break;            f.push_back(p);        }        vector&lt;int&gt; dp(n + 1);        dp[0] = 1;        for (const auto&amp; num : f) {            for (int i = n - num; i &gt;= 0; i--) {                dp[i + num] += dp[i];                if (dp[i + num] &gt;= mod) dp[i + num] -= mod;            }        }        return dp.back();    }};\n\nmod = 1_000_000_007class Solution:    def numberOfWays(self, n: int, x: int) -&gt; int:        f = [0] * (n + 1)        f[0] = 1        for i in range(1, n + 1):            p = pow(i, x)            if p &gt; n:                break            for j in range(n - p, -1, -1):                f[j + p] += f[j]                if f[j + p] &gt;= mod:                    f[j + p] -= mod        return f[-1]\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题2438-二的幂数组中查询范围内的乘积","url":"/2025/08/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982438-%E4%BA%8C%E7%9A%84%E5%B9%82%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E8%AF%A2%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E4%B9%98%E7%A7%AF/","content":"题意给定数 n 找到对应的 powers 数组：\n\npowers 非递减\npowers 仅含 2 的幂次\npowers 含数最少\n\n给定一组询问 queries_i = [l_i, r_i] ，求 powers 中区间 [l_i, r_i] 的区间积，对 1e9 + 7 取模\n思路显然 powers 是唯一的，就是将 n 转为二进制的 1 的位\n然后区间积第一反应我是求前缀积，这里由于模数是质数，除法等价于乘逆元即可。\n但写python做法时看了下灵神写法，转为幂次的前缀和然后预处理就好，复杂度会更低。\n实现cpp 与 前缀积\nusing ll = long long;static constexpr int mod = 1e9 + 7;ll powMod(ll a, ll b) {    ll res = 1;    while (b) {        if (b &amp; 1) {            res = res * a % mod;        }        a = a * a % mod;        b &gt;&gt;= 1;    }    return res;}class Solution {public:    vector&lt;int&gt; productQueries(int n, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {        vector&lt;int&gt; f;        for (int i = 0; i &lt; 31; i++) {            if (n &gt;&gt; i &amp; 1) f.push_back(1 &lt;&lt; i);        }        const int len = f.size();        vector&lt;int&gt; pre(len + 1, 1);        for (int i = 0; i &lt; len; i++) {            pre[i + 1] = 1ll * pre[i] * f[i] % mod;        }        vector&lt;int&gt; ans;        for (const auto&amp; q : queries) {            int l = q[0], r = q[1] + 1;            ans.push_back(1ll * pre[r] * powMod(pre[l], mod - 2) % mod);        }        return ans;    }};\n\npython 与 前缀和\nmod = 1000000007def powMod(a, b):    res = 1    while b &gt; 0:        if (b &amp; 1):            res = res * a % mod        a = a * a % mod        b &gt;&gt;= 1    return resclass Solution:    def productQueries(self, n: int, queries: List[List[int]]) -&gt; List[int]:        pre = [0]        for i in range(0, 31):            if n &gt;&gt; i &amp; 1:                pre.append(pre[-1] + i)        return [powMod(2, pre[r + 1] - pre[l]) for l, r in queries]\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题869-重新排序得到 2 的幂","url":"/2025/08/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98869-%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B0-2-%E7%9A%84%E5%B9%82/","content":"题意给定正整数 n , 判断是否可以将其重排为无前导零的二的幂次数。\n思路注意到给定的数据范围是 n &lt;= 1e9 也就是最多有九位数，转为字符串进行全排列枚举排列方案再按昨日每日一题的方法判断是否为二的幂次数即可，计算量大概是 9! 完全是可以接受的。\n但确实不太优雅，1e9 内的二的幂次数显然是不超过 31 个的，我们完全可以预处理枚举这些数，将其中各个二次幂数的各数位出现的次数记录下来，然后与询问进行比对即可。只要各数位出现次数相同显然是可以重排的。\n比较简单的做法就是灵神的将二的幂次数转为字符串然后排序加入到uset/ump/set/map 中，也可以开个大小为10的数组记录然后哈希。\n但是我们可以注意到 1e9 意味着最多有九个数位，且相同数位出现次数不超过 9 ，我们完全可以转换为一个 long long 的数进行哈希，当然使用 python 的话就不用管这里的数据范围了。这样做常数会相对小些，但说实话这种题好像不用那么在意这个的，简单题简单做就好。\n实现cpp 与 枚举\nclass Solution {public:    bool reorderedPowerOf2(int n) {        auto check = [](int x) -&gt; bool {            return (x &amp; -x) == x;        };        string s = to_string(n);        string t = s;        const int len = s.size();        do {            int x = stoi(s);            if (to_string(x).size() == len &amp;&amp; check(x)) return true;            next_permutation(s.begin(), s.end());        } while (s != t);        return false;    }};\n\ncpp 与 哈希\nusing ll = long long;static constexpr int inf = 1e9;static constexpr int N = 10;static ll a[N];unordered_set&lt;ll&gt; f;auto init = []() -&gt; int {    a[0] = 1;    for (int i = 1; i &lt; N; i++) a[i] = a[i - 1] * 10;    int x = 1;    while (x &lt;= inf) {        ll cur = 0;        for (int t = x; t; t /= 10) {            cur += a[t % 10];        }        f.insert(cur);        x &lt;&lt;= 1;    }    return 0;} ();class Solution {public:    bool reorderedPowerOf2(int n) {        ll x = 0;        for ( ; n; n /= 10) x += a[n % 10];        return f.count(x);    }};\n\npython 与 哈希\nmx = 10**9a = [1] * 10for i in range(1, 10):    a[i] = a[i - 1] * 10f = set()for i in range(0, 31):    x = 1 &lt;&lt; i    cur = 0    while x:        cur += a[x % 10]        x //= 10    f.add(cur)class Solution:    def reorderedPowerOf2(self, n: int) -&gt; bool:        cur = 0        while n:            cur += a[n % 10]            n //= 10        return cur in f\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题231-2 的幂","url":"/2025/08/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98231-2-%E7%9A%84%E5%B9%82/","content":"题意给定数 n ，判断 n 是否为 2 的幂次。\n思路那有很多种写法的，最简单也最快的我认为就是利用位运算求 lowbit 也就是 n 二进制下的最低位，显然当 lowbit(n) == n 时 n 为 2 的幂次，不过要注意二的幂次应该是正整数的，题目给的范围为 int 范围。\nlowbit(x) == x &amp; -x\n实现class Solution {public:    bool isPowerOfTwo(int n) {        return n &gt; 0 &amp;&amp; (n &amp; -n) == n;    }};\n\nclass Solution:    def isPowerOfTwo(self, n: int) -&gt; bool:        return n &gt; 0 and (n &amp; -n) == n\n\n","categories":["做题笔记"],"tags":["cpp","python"]},{"title":"力扣每日一题808-分汤","url":"/2025/08/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98808-%E5%88%86%E6%B1%A4/","content":"题意给定初始有 n 毫升的汤A和汤B，每轮操作等概率地发生以下四种事件：\n\nA减少 100 毫升，B减少 0 毫升\nA减少 75 毫升，B减少 25 毫升\nA减少 50 毫升，B减少 50 毫升\nA减少 25 毫升，B减少 75 毫升\n\n求(A在B之前取完的概率)加上(AB同时取完概率的一半)\n思路先看数据范围，n &lt;= 1e9 非常的大，当 n 很大时什么做法都不可能实现的，那么肯定是个思维数学题。\n仔细观察每次操作的影响，A减少的期望量显然是大于B的，那么当 n 很大时一定是A先取完的。\n再考虑以下小范围时应该怎么做。求概率，比较自然可以想到使用概率dp，同时注意到每次操作的减少量的最大公因数为 25 ，故可以将毫升数统统除以 25 表示操作次数与操作减少量。\n再用获得的dp算法大概跑一下范围，可以发现操作次数超过 200 后概率在可接受误差内可认为 1\n实现class Solution {using ld = long double;static constexpr ld eps = 1e-5;static constexpr int N = 25;static constexpr ld p = 0.25;public:    double soupServings(int n) {        const int t = (n + N - 1) / N;        if (t &gt;= 200) return 1.0;        auto cal = [](const int&amp; x) -&gt; int {            return max(x, 0);        };        vector f(t + 1, vector&lt;ld&gt; (t + 1));        fill(f[0].begin(), f[0].end(), 1.0);        f[0][0] = 0.5;        for (int i = 1; i &lt;= t; i++) {            for (int j = 1; j &lt;= t; j++) {                f[i][j] = (f[cal(i - 4)][j] + f[cal(i - 3)][cal(j - 1)] + f[cal(i - 2)][cal(j - 2)] + f[cal(i - 1)][cal(j - 3)]) * p;            }        }        return f[t][t];    }};\n\nclass Solution:    def soupServings(self, n: int) -&gt; float:        t = (n + 24) // 25        if t &gt;= 200:            return 1.0                p = 0.25        @cache        def dfs(x, y) -&gt; float:            if x &lt;= 0 and y &lt;= 0:                return 0.5            elif x &lt;= 0:                return 1.0            elif y &lt;= 0:                return 0.0            res = 0.0            for i in range(1, 5):                res += dfs(x - i, y - 4 + i) * p            return res                return dfs(t, t)\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题3363-最多可收集的水果数目","url":"/2025/08/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983363-%E6%9C%80%E5%A4%9A%E5%8F%AF%E6%94%B6%E9%9B%86%E7%9A%84%E6%B0%B4%E6%9E%9C%E6%95%B0%E7%9B%AE/","content":"题意给定 n * n 大小的网格，以及二维数组 fruits 表示每个格子内的水果数。有三个小朋友分别位于 (0, 0), (0, n - 1), (n - 1, 0) 其中\n\n(0, 0) 的人每次可以往右、下、右下移动一格\n(0, n - 1) 的人每次可以往左下、下、右下移动一格\n(n - 1, 0) 的人每次可以往右上、右、右下移动一格\n\n每个小朋友只能移动 n - 1 步且终点必须为 (n - 1, n - 1) ，求三个小朋友总共可收集的最大水果数。\n思路咋一看是挺难的，但是每个小朋友都只能移动 n - 1 步且必须到达 (n - 1, n - 1) 那也就是说左上的小朋友有且仅有沿对角线一种走法，右上和左下的小朋友的可行动区域也仅是一个小三角形，且三个小朋友的行动路径不可能相交。\n那么问题就转变成了两个简单的dp（求右上和左下的小朋友行动最优方案）。\n实现class Solution {public:    int maxCollectedFruits(vector&lt;vector&lt;int&gt;&gt;&amp; fruits) {        const int n = fruits.size();        int ans = 0;        vector f(n + 1, vector&lt;int&gt; (n + 1));        f[0][n - 1] = fruits[0][n - 1];        for (int i = 1; i &lt; n; i++) {            for (int j = max(i + 1, n - 1 - i); j &lt; n; j++) {                f[i][j] = max({f[i - 1][j + 1], f[i - 1][j], f[i - 1][j - 1]}) + fruits[i][j];            }        }        ans += f[n - 2][n - 1];        f[n - 1][0] = fruits[n - 1][0];        for (int j = 1; j &lt; n; j++) {            for (int i = max(j + 1, n - 1 - j); i &lt; n; i++) {                f[i][j] = max({f[i + 1][j - 1], f[i][j - 1], f[i - 1][j - 1]}) + fruits[i][j];            }        }        ans += f[n - 1][n - 2];        for (int i = 0; i &lt; n; i++) ans += fruits[i][i];        return ans;    }};\n\nclass Solution:    def maxCollectedFruits(self, fruits: List[List[int]]) -&gt; int:        n = len(fruits)        f = [0] * ((n + 1) * (n + 1))        def cal(x, y):            return x * (n + 1) + y                ans = 0        f[cal(0, n - 1)] = fruits[0][n - 1]        for i in range(1, n):            for j in range(max(i + 1, n - 1 - i), n):                f[cal(i, j)] = max(f[cal(i - 1, j - 1)], f[cal(i - 1, j)], f[cal(i - 1, j + 1)]) + fruits[i][j]        ans += f[cal(n - 2, n - 1)]        f[cal(n - 1, 0)] = fruits[n - 1][0]        for j in range(1, n):            for i in range(max(j + 1, n - 1 - j), n):                f[cal(i, j)] = max(f[cal(i + 1, j - 1)], f[cal(i, j - 1)], f[cal(i - 1, j - 1)]) + fruits[i][j]        ans += f[cal(n - 1, n - 2)]        ans += sum(x[i] for i, x in enumerate(fruits))        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题3479-水果成篮 III","url":"/2025/08/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983479-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE-III/","content":"题意给定数组 fruits 与 baskets，分别表示不同种类水果的数量以及每个篮子的容量。需要按顺序将水果放进最左可以放进所有该种水果的篮子，不同水果不可混放。求会有多少种水果无法放进篮子。\n思路是和做题完全一样的题，只是数据范围增强到了1e5那就为无法直接暴力，可以使用线段树二分，不过由于昨天我已经是这么写的了，就不过多赘述。\n实现template&lt;class Info&gt;struct SegmentTree {    int n;    std::vector&lt;Info&gt; info;    SegmentTree() : n(0) {}    SegmentTree(int n_, Info v_ = Info()) {        init(n_, v_);    }    template&lt;class T&gt;    SegmentTree(std::vector&lt;T&gt; init_) {        init(init_);    }    void init(int n_, Info v_ = Info()) {        init(std::vector(n_, v_));    }    template&lt;class T&gt;    void init(std::vector&lt;T&gt; init_) {        n = init_.size();        info.assign(4 &lt;&lt; std::__lg(n), Info());        std::function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) {            if (r - l == 1) {                info[p] = init_[l];                return;            }            int m = (l + r) / 2;            build(2 * p, l, m);            build(2 * p + 1, m, r);            pull(p);        };        build(1, 0, n);    }    void pull(int p) {        info[p] = info[2 * p] + info[2 * p + 1];    }    void modify(int p, int l, int r, int x, const Info &amp;v) {        if (r - l == 1) {            info[p] = v;            return;        }        int m = (l + r) / 2;        if (x &lt; m) {            modify(2 * p, l, m, x, v);        } else {            modify(2 * p + 1, m, r, x, v);        }        pull(p);    }    void modify(int p, const Info &amp;v) {        modify(1, 0, n, p, v);    }    Info rangeQuery(int p, int l, int r, int x, int y) {        if (l &gt;= y || r &lt;= x) {            return Info();        }        if (l &gt;= x &amp;&amp; r &lt;= y) {            return info[p];        }        int m = (l + r) / 2;        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);    }    Info rangeQuery(int l, int r) {        return rangeQuery(1, 0, n, l, r);    }    template&lt;class F&gt;    int findFirst(int p, int l, int r, int x, int y, F pred) {        if (l &gt;= y || r &lt;= x || !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        int res = findFirst(2 * p, l, m, x, y, pred);        if (res == -1) {            res = findFirst(2 * p + 1, m, r, x, y, pred);        }        return res;    }    template&lt;class F&gt;    int findFirst(int l, int r, F pred) {        return findFirst(1, 0, n, l, r, pred);    }    template&lt;class F&gt;    int findLast(int p, int l, int r, int x, int y, F pred) {        if (l &gt;= y || r &lt;= x || !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        int res = findLast(2 * p + 1, m, r, x, y, pred);        if (res == -1) {            res = findLast(2 * p, l, m, x, y, pred);        }        return res;    }    template&lt;class F&gt;    int findLast(int l, int r, F pred) {        return findLast(1, 0, n, l, r, pred);    }};struct Info {    int mx;};Info operator+(Info a, Info b) {    return {max(a.mx, b.mx)};}class Solution {public:    int numOfUnplacedFruits(vector&lt;int&gt;&amp; fruits, vector&lt;int&gt;&amp; baskets) {        const int n = fruits.size();        SegmentTree&lt;Info&gt; SgT(n);        for (int i = 0; i &lt; n; i++) {            SgT.modify(i, {baskets[i]});        }        int ans = n;        for (const auto&amp; x : fruits) {            int loc = SgT.findFirst(0, n, [&amp;](const auto&amp; p) {                return p.mx &gt;= x;            });            if (loc == -1) continue;            SgT.modify(loc, {0});            ans--;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3477-水果成篮 II","url":"/2025/08/05/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983477-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE-II/","content":"题意给定数组 fruits 与 baskets，分别表示不同种类水果的数量以及每个篮子的容量。需要按顺序将水果放进最左可以放进所有该种水果的篮子，不同水果不可混放。求会有多少种水果无法放进篮子。\n思路注意到本题的数据范围是不大的，n == len(fruits) == len(baskets) &lt;= 100   ，那么其实直接暴力模拟即可。\n但是数据范围稍大些呢，问题其实是可以转换为多个求最左含大于某数的位置的问题，同时带修改，那么可以想到使用线段树维护区间最大值，然后使用线段树上二分即可。\n这里我只有cpp线段树二分的板子，所有只用cpp实现了线段树上二分的代码，python就偷懒暴力了。\n实现cpp 与 线段树二分\ntemplate&lt;class Info&gt;struct SegmentTree {    int n;    std::vector&lt;Info&gt; info;    SegmentTree() : n(0) {}    SegmentTree(int n_, Info v_ = Info()) {        init(n_, v_);    }    template&lt;class T&gt;    SegmentTree(std::vector&lt;T&gt; init_) {        init(init_);    }    void init(int n_, Info v_ = Info()) {        init(std::vector(n_, v_));    }    template&lt;class T&gt;    void init(std::vector&lt;T&gt; init_) {        n = init_.size();        info.assign(4 &lt;&lt; std::__lg(n), Info());        std::function&lt;void(int, int, int)&gt; build = [&amp;](int p, int l, int r) {            if (r - l == 1) {                info[p] = init_[l];                return;            }            int m = (l + r) / 2;            build(2 * p, l, m);            build(2 * p + 1, m, r);            pull(p);        };        build(1, 0, n);    }    void pull(int p) {        info[p] = info[2 * p] + info[2 * p + 1];    }    void modify(int p, int l, int r, int x, const Info &amp;v) {        if (r - l == 1) {            info[p] = v;            return;        }        int m = (l + r) / 2;        if (x &lt; m) {            modify(2 * p, l, m, x, v);        } else {            modify(2 * p + 1, m, r, x, v);        }        pull(p);    }    void modify(int p, const Info &amp;v) {        modify(1, 0, n, p, v);    }    Info rangeQuery(int p, int l, int r, int x, int y) {        if (l &gt;= y || r &lt;= x) {            return Info();        }        if (l &gt;= x &amp;&amp; r &lt;= y) {            return info[p];        }        int m = (l + r) / 2;        return rangeQuery(2 * p, l, m, x, y) + rangeQuery(2 * p + 1, m, r, x, y);    }    Info rangeQuery(int l, int r) {        return rangeQuery(1, 0, n, l, r);    }    template&lt;class F&gt;    int findFirst(int p, int l, int r, int x, int y, F pred) {        if (l &gt;= y || r &lt;= x || !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        int res = findFirst(2 * p, l, m, x, y, pred);        if (res == -1) {            res = findFirst(2 * p + 1, m, r, x, y, pred);        }        return res;    }    template&lt;class F&gt;    int findFirst(int l, int r, F pred) {        return findFirst(1, 0, n, l, r, pred);    }    template&lt;class F&gt;    int findLast(int p, int l, int r, int x, int y, F pred) {        if (l &gt;= y || r &lt;= x || !pred(info[p])) {            return -1;        }        if (r - l == 1) {            return l;        }        int m = (l + r) / 2;        int res = findLast(2 * p + 1, m, r, x, y, pred);        if (res == -1) {            res = findLast(2 * p, l, m, x, y, pred);        }        return res;    }    template&lt;class F&gt;    int findLast(int l, int r, F pred) {        return findLast(1, 0, n, l, r, pred);    }};struct Info {    int mx;};Info operator+(Info a, Info b) {    return {max(a.mx, b.mx)};}class Solution {public:    int numOfUnplacedFruits(vector&lt;int&gt;&amp; fruits, vector&lt;int&gt;&amp; baskets) {        const int n = fruits.size();        SegmentTree&lt;Info&gt; SgT(n);        for (int i = 0; i &lt; n; i++) {            SgT.modify(i, {baskets[i]});        }        int ans = n;        for (const auto&amp; x : fruits) {            int loc = SgT.findFirst(0, n, [&amp;](const auto&amp; p) {                return p.mx &gt;= x;            });            if (loc == -1) continue;            SgT.modify(loc, {0});            ans--;        }        return ans;    }};\n\npython 与 暴力\nclass Solution:    def numOfUnplacedFruits(self, fruits: List[int], baskets: List[int]) -&gt; int:        ans = n = len(fruits)        for x in fruits:            for i in range(n):                if baskets[i] &gt;= x:                    ans -= 1                    baskets[i] = 0                    break        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题904-水果成篮","url":"/2025/08/04/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98904-%E6%B0%B4%E6%9E%9C%E6%88%90%E7%AF%AE/","content":"题意给定数组fruits表示一排果树的种类。有且仅有两个篮子，每个篮子仅可装一种水果但没有数量上限。可以任选一个位置开始向右摘水果，必须恰好摘一个所经过的水果，若无法装下则停止。求最多可以摘多少水果。\n思路简单来说就是仅包含小于等于两种数的最长子数组。直接使用滑动窗口即可，由于种类上限较少，可以仅开4个变量进行维护（两个篮子所装种类及数量）。若种类上限较多可以考虑使用哈希维护。\n实现class Solution {public:    int totalFruit(vector&lt;int&gt;&amp; fruits) {        array&lt;int, 2&gt; a {-1, 0}, b {-1, 0};        int ans = 0;        const int n = fruits.size();        for (int l = 0, r = -1; r + 1 &lt; n; ) {            if (a[0] == fruits[r + 1]) {                a[1]++;                r++;            } else if (b[0] == fruits[r + 1]) {                b[1]++;                r++;            } else if (b[0] == -1) {                b = {fruits[++r], 1};            } else if (a[0] == -1) {                a = {fruits[++r], 1};            } else if (r + 1 &lt; n) {                for ( ; b[1] &amp;&amp; a[1]; l++) {                    if (fruits[l] == a[0]) a[1]--;                    else b[1]--;                }                if (b[1] == 0) b[0] = -1;                else a[0] = -1;            }            ans = max(ans, a[1] + b[1]);        }        return ans;    }};\n\nclass Solution:    def totalFruit(self, fruits: List[int]) -&gt; int:        a = [-1, 0]        b = [-1, 0]        n = len(fruits)        ans = l = 0        r = -1        while r + 1 &lt; n:            if a[0] == fruits[r + 1]:                a[1] += 1                r += 1            elif b[0] == fruits[r + 1]:                b[1] += 1                r += 1            elif b[0] == -1:                b = [fruits[r + 1], 1]                r += 1            elif a[0] == -1:                a = [fruits[r + 1], 1]                r += 1            else:                while a[1] &gt; 0 and b[1] &gt; 0:                    if fruits[l] == a[0]:                        a[1] -= 1                    else:                        b[1] -= 1                    l += 1                if b[1] == 0:                    b[0] = -1                else:                    a[0] = -1            ans = max(ans, a[1] + b[1])        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题2106-摘水果","url":"/2025/08/03/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982106-%E6%91%98%E6%B0%B4%E6%9E%9C/","content":"题意位于无限长的横坐标轴上。给定数组fruits表示每堆水果所在的位置以及数量，初始位于位置startPos，最多可以移动k步。求可以获得的最大水果数。\n思路手玩一下可以发现来回走是会浪费步数的，所以只可能先向左再向右或反过来先向右再向左可能得到最大值。\n那么使用滑动窗口维护可达位置内的水果数量，取最大值即为答案。\n实现class Solution {public:    int maxTotalFruits(vector&lt;vector&lt;int&gt;&gt;&amp; fruits, int startPos, int k) {        const int n = fruits.size();        int lt = ranges::lower_bound(fruits, startPos - k, {}, [&amp;](const auto&amp; x) {            return x[0];        }) - fruits.begin();        int rt = lt;        int ans = 0;        for ( ; rt &lt; n &amp;&amp; fruits[rt][0] &lt;= startPos; rt++) ans += fruits[rt][1];        int cur = ans;        for ( ; rt &lt; n &amp;&amp; fruits[rt][0] &lt;= startPos + k; rt++) {            cur += fruits[rt][1];            for ( ; startPos - 2 * fruits[lt][0] + fruits[rt][0] &gt; k &amp;&amp; 2 * fruits[rt][0] - startPos - fruits[lt][0] &gt; k; lt++) {                cur -= fruits[lt][1];            }            ans = max(ans, cur);        }        return ans;    }};\n\nclass Solution:    def maxTotalFruits(self, fruits: List[List[int]], startPos: int, k: int) -&gt; int:        n = len(fruits)        lt = bisect_left(fruits, [startPos - k])        rt = lt        ans = 0        while rt &lt; n and fruits[rt][0] &lt;= startPos:            ans += fruits[rt][1]            rt += 1                cur = ans        while rt &lt; n and fruits[rt][0] &lt;= startPos + k:            cur += fruits[rt][1]            while startPos + fruits[rt][0] - fruits[lt][0] * 2 &gt; k and fruits[rt][0] * 2 - fruits[lt][0] - startPos &gt; k:                cur -= fruits[lt][1]                lt += 1            rt += 1            ans = max(ans, cur)        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题2561-重排水果","url":"/2025/08/02/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982561-%E9%87%8D%E6%8E%92%E6%B0%B4%E6%9E%9C/","content":"题意给定两个等长数组basket1和basket2。可以进行任意次以下操作：\n\n交换basket1[i]与basket2[j]，操作的代价为min(basket1[i], basket2[j])\n\n求欲使两数组内容相同的最小代价。\n思路手玩一下不难发现其实是很符合贪心性质的。\n首先是不能使两数组相同的情况，必然是有某个数有奇数个。\n再考虑可以使得两数组相同的情况，每个数均有偶数个，又两数组等长，若basket1中缺某数一定会多出另一个数，basket2也是同理。每次交换可以处理两个数。可以想到将两数中多的数列出来，每次操作交换一侧最大另一侧的最小。又可选择某侧最小值换过去再换回来，取代价最小即可。\n呃，好像讲得是有点乱，还请看代码吧。\n实现class Solution:    def minCost(self, basket1: List[int], basket2: List[int]) -&gt; int:        cnt = defaultdict(int)        for x in basket1:            cnt[x] += 1        for x in basket2:            cnt[x] -= 1                a, b = [], []        for num, t in cnt.items():            if t &amp; 1:                return -1            if t &gt; 0:                a.extend([num] * (t // 2))            elif t &lt; 0:                b.extend([num] * (-t // 2))                a.sort()        b.sort(reverse=True)        mn = min(min(basket1), min(basket2))        ans = 0        for i in range(len(a)):            ans += min(a[i], b[i], mn * 2)        return ans\n\nclass Solution {using ll = long long;public:    long long minCost(vector&lt;int&gt;&amp; basket1, vector&lt;int&gt;&amp; basket2) {        int mn = 1e9;        unordered_map&lt;int, array&lt;int, 2&gt;&gt; cnt;        for (const auto&amp; x : basket1) {            cnt[x][0]++;            mn = min(mn, x);        }        for (const auto&amp; x : basket2) {            cnt[x][1]++;            mn = min(mn, x);        }        vector&lt;int&gt; a, b;        for (const auto&amp; [num, arr] : cnt) {            const auto&amp; [x, y] = arr;            if ((x + y) &amp; 1) return -1;            if (x &gt; y) a.insert(a.end(), (x - y) &gt;&gt; 1, num);            else if (x &lt; y) b.insert(b.end(), (y - x) &gt;&gt; 1, num);        }        ranges::sort(a);        ranges::sort(b, greater());        ll ans = 0;        for (int i = 0; i &lt; a.size(); i++) {            ans += min({a[i], b[i], mn &lt;&lt; 1});        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题118-杨辉三角","url":"/2025/08/01/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98118-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92/","content":"题意给定非负整数numRows，生成杨辉三角的前numRows行。\n思路这道题是hot100的原题，本身难度也没有很大，只要知道杨辉三角的定义我想就是不难写的。\n简单的双层循环模拟杨辉三角的计算过程即可。\n实现class Solution:    def generate(self, numRows: int) -&gt; List[List[int]]:        ans = [[1] * (i + 1) for i in range(numRows)]        for i in range(2, numRows):            for j in range(1, i):                ans[i][j] = ans[i - 1][j] + ans[i - 1][j - 1]        return ans\n\nclass Solution {public:    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {        vector&lt;vector&lt;int&gt;&gt; ans;        ans.push_back({1});        for (int i = 1; i &lt; numRows; i++) {            vector&lt;int&gt; tmp(ans.back().size() + 1);            for (int j = 0; j &lt;= i; j++) {                if (j == 0 || j == i) tmp[j] = 1;                else {                    tmp[j] = (ans.back()[j - 1] + ans.back()[j]);                }            }            ans.push_back(tmp);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题2683-相邻值的按位异或","url":"/2025/07/31/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982683-%E7%9B%B8%E9%82%BB%E5%80%BC%E7%9A%84%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96/","content":"题意数组derived是由同样长度的数组original相邻值异或得到的，即derived[i] = original[i] ^ original[i + 1]。对于给定的0/1数组derived，判断其是否存在有效的original数组。\n思路什么情况下derived[i] == 1呢，显然是derived[i] != derived[i + 1]时；而当derived[i] == derived[i + 1]时，derived[i] == 0。由此可以推出每一个数与其他数是否相等。\n那么什么时候不存在对应的original数组呢，显然是当出现矛盾时。不难想到遍历数组得到异或和，即可判断是否存在矛盾，是否存在对应数组。\n实现class Solution:    def doesValidArrayExist(self, derived: List[int]) -&gt; bool:        same = True        for i in derived:            if i == 1:                same = not same        return same                \n\nclass Solution {public:    bool doesValidArrayExist(vector&lt;int&gt;&amp; derived) {        bool same = true;        for (const auto&amp; x : derived) {            same ^= x;        }        return same;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题2419-按位与最大的最长子数组","url":"/2025/07/30/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982419-%E6%8C%89%E4%BD%8D%E4%B8%8E%E6%9C%80%E5%A4%A7%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84/","content":"题意给定正整数数组nums。求nums中按位与可以得到最大值的最长非空子数组的长度。\n思路与前几天的按位或略有不同，或是子数组越长越有可能出最大值，而与则是越长值越小，即 Misplaced &x &amp; y \\leq x \n所以不难想到按位与可以得到的最大值为nums中的最大值，而答案就是连续出现的最大值个数。\n实现class Solution:    def longestSubarray(self, nums: List[int]) -&gt; int:        i = ans = mx = 0        n = len(nums)        while i &lt; n:            j = i + 1            while j &lt; n and nums[i] == nums[j]:                j += 1            if nums[i] &gt; mx:                mx = nums[i]                ans = j - i            elif nums[i] == mx:                ans = max(ans, j - i)            i = j        return ans\n\nclass Solution:    def longestSubarray(self, nums: List[int]) -&gt; int:        i = ans = mx = 0        n = len(nums)        while i &lt; n:            j = i + 1            while j &lt; n and nums[i] == nums[j]:                j += 1            if nums[i] &gt; mx:                mx = nums[i]                ans = j - i            elif nums[i] == mx:                ans = max(ans, j - i)            i = j        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题2411-按位或最大的最小子数组长度","url":"/2025/07/29/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982411-%E6%8C%89%E4%BD%8D%E6%88%96%E6%9C%80%E5%A4%A7%E7%9A%84%E6%9C%80%E5%B0%8F%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/","content":"题意给定非负整数数组nums。对于nums中的每一个数，求出以其为起点可以得到按位或最大值的最小非空子数组的长度。\n思路首先考虑按位或可以得到的最大值怎么求，显然是子数组越长越可能得到最大值，那么一路或到尾显然是可以得到最大值的。那么怎么求最早出现也就是最短的呢。显然一个数与另一个数无论或几次结果都是不变的，那很自然可以想到ST表上二分。\n但这有点火箭毛毛虫了，因为或运算有个很好的性质，在正int的范围内，最多是可以变换31次的，那直接从前往后遍历，从后往前更新即可。\n实现st表加二分实现\ntemplate&lt;class T&gt; struct ST {\tint n, logn;\tvector&lt;int&gt; LOG;\tvector&lt;vector&lt;T&gt;&gt;st;\tST (int x) {\t\tn = x;\t\tlogn = __lg(n);\t\tLOG.resize(n + 1);\t\tst.resize(n, vector&lt;T&gt; (logn + 1));\t\tfor (int i = 2; i &lt;= n; i++) {\t\t\tLOG[i] = LOG[i / 2] + 1;\t\t}\t}\tvoid set(int i, T x) {\t\tst[i][0] = x;\t}\tvoid build() {\t\tfor (int i = 1; i &lt;= logn; i++) {\t\t\tfor (int j = 0; j + (1 &lt;&lt; i) - 1 &lt; n; j++) {\t\t\t\tst[j][i] = st[j][i - 1] | st[j + (1 &lt;&lt; (i - 1))][i - 1];\t\t\t}\t\t}\t}\tT query(int l, int r) {\t\tint len = LOG[r - l + 1];\t\treturn st[l][len] | st[r - (1 &lt;&lt; len) + 1][len];\t}};class Solution {public:    vector&lt;int&gt; smallestSubarrays(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        ST&lt;int&gt; st(n);        for (int i = 0; i &lt; n; i++) {            st.set(i, nums[i]);        }        st.build();        vector&lt;int&gt; ans(n);        for (int i = 0; i &lt; n; i++) {            int x = st.query(i, n - 1);            int lo = i, hi = n - 1;            while (lo &lt; hi) {                int mid = lo + hi &gt;&gt; 1;                if (st.query(i, mid) == x) hi = mid;                else lo = mid + 1;            }            ans[i] = lo - i + 1;        }        return ans;    }};\n\nclass Solution {public:    vector&lt;int&gt; smallestSubarrays(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        vector&lt;int&gt; ans(n, 1);        for (int i = 0; i &lt; n; i++) {            for (int j = i - 1; j &gt;= 0 &amp;&amp; (nums[j] | nums[i]) != nums[j]; j--) {                nums[j] |= nums[i];                ans[j] = i - j + 1;            }        }        return ans;    }};\n\nclass Solution:    def smallestSubarrays(self, nums: List[int]) -&gt; List[int]:        n = len(nums)        ans = [1] * n        for i in range(0, n):            for j in range(i - 1, -1, -1):                if (nums[j] | nums[i]) == nums[j]:                    break                nums[j] |= nums[i]                ans[j] = i - j + 1        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题2044-统计按位或能得到最大值的子集数目","url":"/2025/07/28/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982044-%E7%BB%9F%E8%AE%A1%E6%8C%89%E4%BD%8D%E6%88%96%E8%83%BD%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%A7%E5%80%BC%E7%9A%84%E5%AD%90%E9%9B%86%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums，找出nums中子集按位或的最大值，并返回能得出最大值的不同非空子集数量。\nlen(nums) &lt;= 16\n思路数据范围并不大，直接dfs枚举子集即可。\n实现class Solution {public:    int countMaxOrSubsets(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        int mx = 0;        int cnt = 0;        auto dfs = [&amp;](this auto&amp;&amp; self, int cur, int loc) -&gt; void {            if (loc == n) {                if (cur &gt; mx) {                    mx = cur;                    cnt = 1;                } else if (cur == mx) cnt++;                return;            }            self(cur | nums[loc], loc + 1);            self(cur, loc + 1);        };        dfs(0, 0);        return cnt;    }};\n\nclass Solution:    def countMaxOrSubsets(self, nums: List[int]) -&gt; int:        n = len(nums)        cnt = mx = 0        def dfs(cur: int, loc: int) -&gt; None:            nonlocal cnt, mx            if loc == n:                if cur &gt; mx:                    mx = cur                    cnt = 1                elif cur == mx:                    cnt += 1                return            dfs(cur | nums[loc], loc + 1)            dfs(cur, loc + 1)        dfs(0, 0)        return cnt\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题2210-统计数组中峰和谷的数量","url":"/2025/07/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982210-%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%BB%84%E4%B8%AD%E5%B3%B0%E5%92%8C%E8%B0%B7%E7%9A%84%E6%95%B0%E9%87%8F/","content":"题意给定数组nums。如果某数两侧第一个与其不等的数均大于或小于该数，则称其为峰或谷。求nums内峰和谷的数量。\n思路遍历一趟模拟着求就好，两侧均大于或小于等价于两侧与该数的差值同号。\n实现class Solution {public:    int countHillValley(vector&lt;int&gt;&amp; nums) {        int ans = 0;        int pre = nums[0];        const int n = nums.size();        for (int i = 1; i &lt; n - 1; i++) {            int cur = nums[i];            int nxt = nums[i + 1];            if (cur == nxt) continue;            if ((pre - cur) * (nxt - cur) &gt; 0) ans++;            pre = cur;        }        return ans;    }};\n\nclass Solution:    def countHillValley(self, nums: List[int]) -&gt; int:        ans = 0        pre = nums[0]        n = len(nums)        for i in range(1, n - 1):            cur = nums[i]            nxt = nums[i + 1]            if cur == nxt:                continue            if (pre - cur) * (nxt - cur) &gt; 0:                ans += 1            pre = cur        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题3480-删除一个冲突对后最大子数组数目","url":"/2025/07/26/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983480-%E5%88%A0%E9%99%A4%E4%B8%80%E4%B8%AA%E5%86%B2%E7%AA%81%E5%AF%B9%E5%90%8E%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/","content":"题意给定整数n 表示有 [1, n] 的顺序排列 nums。同时给定数组 conflictingPairs 表示一些冲突对 conflictingPairs[i] = [a, b] 表示 a 与 b 不能出现同一子数组中。\n现在可以任意删除一对冲突对，求删除后不冲突的 nums 子数组最大个数。\n思路枚举左端点，手玩一下可以发现性质。\n实现class Solution:\n    def maxSubarrays(self, n: int, conflictingPairs: List[List[int]]) -&gt; int:\n        f = [n + 1] * (n + 1)\n        g = [n + 1] * (n + 1)\n        for l, r in conflictingPairs:\n            if l &gt; r:\n                l, r = r, l\n            if r &lt; f[l]:\n                g[l] = f[l]\n                f[l] = r\n            elif r &lt; g[l]:\n                g[l] = r\n        \n        ans = e = mx = 0\n        b0 = b1 = n + 1\n        for i in range(n, 0, -1):\n            pre = b0\n            if f[i] &lt; b0:\n                b1 = b0\n                b0 = f[i]\n            elif f[i] &lt; b1:\n                b1 = f[i]\n            if g[i] &lt; b0:\n                b1 = b0\n                b0 = g[i]\n            elif g[i] &lt; b1:\n                b1 = g[i]\n            ans += b0 - i\n            if b0 != pre:\n                e = 0\n            e += b1 - b0\n            mx = max(mx, e)\n        return ans + mx\n\n","categories":["做题笔记"],"tags":["leetcode","python"]},{"title":"力扣每日一题3487-删除后的最大子数组元素和","url":"/2025/07/25/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983487-%E5%88%A0%E9%99%A4%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E5%92%8C/","content":"题意给定数组nums，可以删除其中任意元素但不能使其为空。求删除后可以得到的数组内元素各不相同且和最大的子数组和。\n思路相当于将所有负数删除并去重后得到的数组和，但需要注意若数组所有元素均为负数答案为最大的负数。\n实现class Solution:    def maxSum(self, nums: List[int]) -&gt; int:        ans = 0        cnt = 0        vis = [0] * 101        for i in nums:            if i &gt;= 0 and vis[i] == 0:                vis[i] = 1                ans += i                cnt += 1        if cnt == 0:            return max(nums)        return ans\n\nclass Solution {public:    int maxSum(vector&lt;int&gt;&amp; nums) {        array&lt;int, 101&gt; vis;        int ans = 0, cnt = 0, mx = -100;        for (const auto&amp; x : nums) {            if (x &gt;= 0 &amp;&amp; vis[x] == 0) {                vis[x]++;                cnt++;                ans += x;            } else mx = max(mx, x);        }        if (cnt == 0) return mx;        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题2322-从树中删除边的最小分数","url":"/2025/07/24/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982322-%E4%BB%8E%E6%A0%91%E4%B8%AD%E5%88%A0%E9%99%A4%E8%BE%B9%E7%9A%84%E6%9C%80%E5%B0%8F%E5%88%86%E6%95%B0/","content":"题意给定一棵树以及树上各点权值nums。任意删除树的两条边，获取所得三个连通块中的所有节点异或值，求这三异或值最大值与最小值的最小差值\n思路注意到点数的数据范围其实是不大的 3 &lt;= n &lt;= 1e3\n那直接枚举所删除的两条边即可。快速求删边所得的连通块异或和可以使用dfs求得各点的子树异或和。各点的父子关系可以dfs时顺带处理深度以及dfs序即可判断。\n实现class Solution:    def minimumScore(self, nums: List[int], edges: List[List[int]]) -&gt; int:        n = len(nums)        adj = [[] for _ in range(n)]        for u, v in edges:            adj[u].append(v)            adj[v].append(u)        f = [0] * n        d = [0] * n        sz = [1] * n        p = [0] * n        tot = 0        def dfs(u: int, fa: int):            nonlocal tot            f[u] = nums[u]            p[u] = tot            tot += 1            for v in adj[u]:                if v == fa:                    continue                d[v] = d[u] + 1                dfs(v, u)                f[u] ^= f[v]                sz[u] += sz[v]                dfs(0, -1)        ans = 1e9        for i in range(n - 1):            for j in range(i + 1, n - 1):                u, v = edges[i]                x, y = edges[j]                if d[u] &gt; d[v]:                    u, v = v, u                if d[x] &gt; d[y]:                    x, y = y, x                if p[v] &lt;= p[y] &lt;= p[v] + sz[v] - 1:                    p0 = f[0] ^ f[v]                    p1 = f[v] ^ f[y]                    p2 = f[y]                elif p[y] &lt;= p[v] &lt;= p[y] + sz[y] - 1:                    p0 = f[0] ^ f[y]                    p1 = f[y] ^ f[v]                    p2 = f[v]                else:                    p0 = f[0] ^ f[v] ^ f[y]                    p1 = f[v]                    p2 = f[y]                ans = min(ans, max(p0, p1, p2) - min(p0, p1, p2))        return ans\n\nclass Solution {public:    int minimumScore(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {        const int n = nums.size();        vector&lt;vector&lt;int&gt;&gt; adj(n);        for (const auto&amp; e : edges) {            int u = e[0], v = e[1];            adj[u].push_back(v);            adj[v].push_back(u);        }                vector&lt;int&gt; f(n), d(n), sz(n, 1), p(n);        int tot = 0;        auto dfs = [&amp;](this auto&amp;&amp; self, int u, int fa) -&gt; void {            f[u] = nums[u];            p[u] = tot++;            for (const auto&amp; v : adj[u]) {                if (v == fa) continue;                d[v] = d[u] + 1;                self(v, u);                f[u] ^= f[v];                sz[u] += sz[v];            }        };        dfs(0, -1);        int ans = 1e9;        for (int i = 0; i &lt; n - 1; i++) {            for (int j = i + 1; j &lt; n - 1; j++) {                int u = edges[i][0], v = edges[i][1];                int x = edges[j][0], y = edges[j][1];                if (d[u] &gt; d[v]) swap(u, v);                if (d[x] &gt; d[y]) swap(x, y);                int p0, p1, p2;                if (p[v] &lt;= p[y] &amp;&amp; p[v] + sz[v] - 1 &gt;= p[y]) {                    p0 = f[0] ^ f[v];                    p1 = f[v] ^ f[y];                    p2 = f[y];                } else if (p[y] &lt;= p[u] &amp;&amp; p[y] + sz[y] - 1 &gt;= p[v]) {                    p0 = f[0] ^ f[y];                    p1 = f[y] ^ f[v];                    p2 = f[v];                } else {                    p0 = f[0] ^ f[v] ^ f[y];                    p1 = f[v];                    p2 = f[y];                }                ans = min(ans, max({p0, p1, p2}) - min({p0, p1, p2}));            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题1717-删除子字符串的最大得分","url":"/2025/07/23/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981717-%E5%88%A0%E9%99%A4%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/","content":"题意给定字符串s，可以进行任意次以下两种操作：\n\n删除s中的子串ab，得到分数x\n删除s中的子串ba，得到分数y\n\n求可以得到的最大分数\n思路手玩一下可以发现，仅需要关注s中仅含ab的子串即可，其他字符可以视作分隔符将问题分割为多个小问题。\n每个仅含ab的子串显然删除次数其实与删除方式是无关的，显然应该进行贪心首先尽可能多地用得分高的方式，再用得分较低的方式删除。\n实现class Solution {public:    int maximumGain(string s, int x, int y) {        const int n = s.size();        char a = 'a', b = 'b';        if (x &lt; y) {            swap(x, y);            swap(a, b);        }        int ans = 0;        for (int i = 0; i &lt; n; i++) {            if (s[i] != a &amp;&amp; s[i] != b) continue;            int ca = 0, cb = 0;            for ( ; i &lt; n &amp;&amp; (s[i] == a || s[i] == b); i++) {                if (s[i] == a) {                    ca++;                } else {                    if (ca) {                        ca--;                        ans += x;                    } else {                        cb++;                    }                }            }            ans += min(ca, cb) * y;        }        return ans;    }};\n\nclass Solution:    def maximumGain(self, s: str, x: int, y: int) -&gt; int:        n = len(s)        a, b = 'a', 'b'        if x &lt; y:            x, y = y, x            a, b = b, a        ans = i = 0        while i &lt; n:            if s[i] != a and s[i] != b:                i += 1                continue            ca = cb = 0            while i &lt; n and (s[i] == a or s[i] == b):                if s[i] == a:                    ca += 1                else:                    if ca &gt; 0:                        ans += x                        ca -= 1                    else:                        cb += 1                i += 1            ans += min(ca, cb) * y        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题1695-删除子数组的最大得分","url":"/2025/07/22/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981695-%E5%88%A0%E9%99%A4%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BE%97%E5%88%86/","content":"题意给定正整数数组nums，从中删除一个不含相同元素的子数组，求所删子数组的最大和。\n思路应该是比较经典的题目了，印象中只是在面试里我就被问过两次类似的题目。\n给定的数组均为整数，那么子数组显然是越长越可能出答案，那么怎么获得最长的不含重复元素的子数组呢。可以想到使用哈希记录该元素是否出现过以及最后出现的位置，求这段的和就可以考虑使用滑动窗口或前缀和求解。\n实现class Solution {public:    int maximumUniqueSubarray(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        unordered_map&lt;int, int&gt; last;        vector&lt;int&gt; pre(n + 1);        int ans = 0;        for (int i = 0, l = 0; i &lt; n; i++) {            pre[i + 1] = pre[i] + nums[i];            if (last.count(nums[i]) &amp;&amp; last[nums[i]] &gt;= l) {                l = last[nums[i]] + 1;            }            last[nums[i]] = i;            ans = max(ans, pre[i + 1] - pre[l]);        }        return ans;    }};\n\nclass Solution:    def maximumUniqueSubarray(self, nums: List[int]) -&gt; int:        n = len(nums)        pre = [0] * (n + 1)        last = defaultdict(int)        l = 0        ans = 0        for i, num in enumerate(nums):            pre[i + 1] = pre[i] + num            if num in last and last[num] &gt;= l:                l = last[num] + 1            last[num] = i            ans = max(ans, pre[i + 1] - pre[l])        return ans\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题1957-删除字符使字符串变好","url":"/2025/07/21/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981957-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%BD%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E5%A5%BD/","content":"题意给定字符串s，删除其中最少字符使得其内无连续三个及以上的相同字符。\n思路简单扫一遍删除多余符号即可。\n实现class Solution {public:    string makeFancyString(string s) {        const int n = s.size();        string ans;        for (int i = 0, cnt = 0; i &lt; n; i++) {            if (++cnt &lt; 3) ans += s[i];            if (i &lt; n - 1 &amp;&amp; s[i] != s[i + 1]) cnt = 0;        }        return ans;    }};\n\nclass Solution:    def makeFancyString(self, s: str) -&gt; str:        ans = []        cnt = 0        for i, ch in enumerate(s):            cnt += 1            if cnt &lt; 3:                ans.append(ch)            if i &lt; len(s) - 1 and s[i] != s[i + 1]:                cnt = 0;        return ''.join(ans)\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","python"]},{"title":"力扣每日一题1948-删除系统中的重复文件夹","url":"/2025/07/20/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981948-%E5%88%A0%E9%99%A4%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E6%96%87%E4%BB%B6%E5%A4%B9/","content":"题意给定二维字符串数组paths其中paths[i]表示第i个文件的绝对路径目录。若两个文件夹非空且其子文件完全相同且子文件结构完全相同，则将两文件夹删除。返回不需删除的剩余文件目录。\n思路怎么快速地判断两个文件夹及其子结构是否相同，可以相等哈希是最快的比较方式，但是这个哈希值怎么计算呢。可以想到将其子目录结构转换为字符串，将所有子串排序以保证子树结构遍历顺序相同，再用()表示目录之间父子的关系。\n","categories":["做题笔记"],"tags":["leetcode"]},{"title":"力扣每日一题1233-删除子文件夹","url":"/2025/07/19/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981233-%E5%88%A0%E9%99%A4%E5%AD%90%E6%96%87%E4%BB%B6%E5%A4%B9/","content":"题意给定一份文件列表folder，若某一文件为另一文件的子目录则将其删除。\n思路进行简单模拟即可，为了提高效率可以考虑将其排序，显然子目录的字典序一定比父目录小。\n实现class Solution:    def removeSubfolders(self, folder: List[str]) -&gt; List[str]:        folder.sort()        ans = [folder[0]]        for s in folder[1:]:            if not (len(s) &gt; len(ans[-1]) and ans[-1] == s[:len(ans[-1])] and s[len(ans[-1])] == '/'):                ans.append(s);        return ans;\n\nclass Solution {public:    vector&lt;string&gt; removeSubfolders(vector&lt;string&gt;&amp; folder) {        ranges::sort(folder);        const int n = folder.size();        vector&lt;string&gt; ans{folder.front()};        for (int i = 1; i &lt; n; i++) {            if (ans.back().size() &lt; folder[i].size() &amp;&amp; ans.back() == folder[i].substr(0, ans.back().size()) &amp;&amp; folder[i][ans.back().size()] == '/') {            } else {                ans.push_back(folder[i]);            }        }        return ans;    }};\n\n其他决心成为传说中的 屁眼通红 高手，所以之后会仅可能地用 python 来写题\n","categories":["做题笔记"],"tags":["cpp","python"]},{"title":"力扣每日一题2163-删除元素后和的最小差值","url":"/2025/07/18/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982163-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%E5%90%8E%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%B7%AE%E5%80%BC/","content":"题意给定长度为3 * n的数组nums，将其中任意n个元素删除，记此时前n个数的和为sum_first后n个数的和为sum_second，求sum_first - sum_second的最小值\n思路转换一下思路，题目的意思可以转变为：选出前n个最小数，再取出这之后的n个最大数，将两部分做差求最值。注意前后必须有且仅有n个数即可，使用优先队列计算一下就好。\n实现class Solution {using ll = long long;static constexpr ll inf = 1ll &lt;&lt; 52;public:    long long minimumDifference(vector&lt;int&gt;&amp; nums) {        ll ans = inf;        const int n = nums.size() / 3, m = nums.size();        priority_queue&lt;int&gt; pq;        ll sum = 0;        vector&lt;ll&gt; pre(m);        for (int i = 0; i &lt; m; i++) {            sum += nums[i];            pq.push(nums[i]);            if (pq.size() &gt; n) {                sum -= pq.top();                pq.pop();            }            pre[i] = sum;        }        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;&gt;&gt; pqt;        sum = 0;        for (int i = m - 1; i &gt;= n - 1; i--) {            if (i &lt; m - n) ans = min(ans, pre[i] - sum);            sum += nums[i];            pqt.push(nums[i]);            if (pqt.size() &gt; n) {                sum -= pqt.top();                pqt.pop();            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3202-找出有效子序列的最大长度 II","url":"/2025/07/17/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983202-%E6%89%BE%E5%87%BA%E6%9C%89%E6%95%88%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6-II/","content":"题意给定数组nums与整数k，求满足以下条件的最长子序列的长度：子序列任意两个相邻数的和模k均相等。\n思路题目中k的数据范围并不大，可以考虑直接枚举两数之和的模大小，由此递推最大答案即可。\n实现class Solution {public:    int maximumLength(vector&lt;int&gt;&amp; nums, int k) {        vector&lt;int&gt; cnt(k);        int ans = 0;        for (int i = 0; i &lt; k; i++) {            fill(cnt.begin(), cnt.end(), 0);            for (auto x : nums) {                x %= k;                cnt[x] = cnt[(i - x + k) % k] + 1;                ans = max(ans, cnt[x]);            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3201-找出有效子序列的最大长度 I","url":"/2025/07/16/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983201-%E6%89%BE%E5%87%BA%E6%9C%89%E6%95%88%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E9%95%BF%E5%BA%A6-I/","content":"题意给定数组nums，求满足以下条件的最长子序列的长度：任意相邻两个元素的和的奇偶性均相等。\n思路观察可以发现答案子序列应该为 全为偶数 或 全为奇数 或 奇数偶数相间 的形式。那么开变量记录一下遍历一趟返回最大值即可。\n实现class Solution {public:    int maximumLength(vector&lt;int&gt;&amp; nums) {        int ao = 0, ae = 0, o = 0, e = 0;        for (const auto&amp; x : nums) {            if (x &amp; 1) {                ao++;                o = max(o, e + 1);            } else {                ae++;                e = max(e, o + 1);            }        }        return max({ao, ae, o, e});    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3136-有效单词","url":"/2025/07/15/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983136-%E6%9C%89%E6%95%88%E5%8D%95%E8%AF%8D/","content":"题意给定字符串word判断其是否长度至少为3且仅由大小写字母与数字组成且至少含一个元音字母且至少含一个辅音字母。\n思路遍历判断条件即可。\n实现class Solution {public:    bool isValid(string word) {        if (word.size() &lt; 3) return false;        bool ok1 = false, ok2 = false;        for (auto&amp; ch : word) {            if (isalpha(ch)) {                ch = tolower(ch);                if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u') ok1 = true;                else ok2 = true;            } else if (!isdigit(ch)) return false;        }        return ok1 &amp;&amp; ok2;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1290-二进制链表转整数","url":"/2025/07/14/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981290-%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%95%B4%E6%95%B0/","content":"题意给定结点值均为0/1的链表，求其表示的二进制数字的十进制值。\n思路进行一个遍历链表得到二进制数再将其转换即可。\n实现class Solution {public:    int getDecimalValue(ListNode* head) {        string s;        for ( ; head != nullptr; head = head-&gt;next) {            s += char('0' + head-&gt;val);        }        int ans = 0;        for (int i = int(s.size()) - 1, base = 0; i &gt;= 0; i--, base++) {            ans |= (s[i] == '1') &lt;&lt; base;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2410-运动员和训练师的最大匹配数","url":"/2025/07/13/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982410-%E8%BF%90%E5%8A%A8%E5%91%98%E5%92%8C%E8%AE%AD%E7%BB%83%E5%B8%88%E7%9A%84%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D%E6%95%B0/","content":"题意给定数组player与trainers表示运动员与训练员的能力。若运动员的能力小于等于训练员则可互相匹配。运动员与训练员均尽可匹配一个。求最大匹配数。\n思路排序后使用双指针即可。\n实现class Solution {public:    int matchPlayersAndTrainers(vector&lt;int&gt;&amp; players, vector&lt;int&gt;&amp; trainers) {        ranges::sort(players);        ranges::sort(trainers);        int ans = 0;        const int n = players.size(), m = trainers.size();        for (int i = 0, j = 0; i &lt; n &amp;&amp; j &lt; m; ) {            if (players[i] &lt;= trainers[j]) {                ans++;                i++; j++;            } else {                j++;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1900-最佳运动员的比拼回合","url":"/2025/07/12/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981900-%E6%9C%80%E4%BD%B3%E8%BF%90%E5%8A%A8%E5%91%98%E7%9A%84%E6%AF%94%E6%8B%BC%E5%9B%9E%E5%90%88/","content":"题意给定整数n与firstPlayer与secondPlayer，表示n名运动员编号为1~n按升序排序。\n每一回合令从前往后数的第i位选手与从后往前数的第i位选手对战，除firstPlayer与secondPlayer必胜外各位选手均可能胜或负。败者淘汰，胜者仍按升序进行排序。\n求firstPlayer与secondPlayer最早与最晚的相遇回合数。\n思路可以进行一个推导发现规律。\n实现class Solution {public:    vector&lt;int&gt; earliestAndLatest(int n, int firstPlayer, int secondPlayer) {        if (firstPlayer + secondPlayer == n + 1) return {1, 1};        if (firstPlayer + secondPlayer &gt; n + 1) {            int t = firstPlayer;            firstPlayer = n + 1 - secondPlayer;            secondPlayer = n + 1 - t;        }        auto cal = [&amp;](int n) -&gt; int {            int res = 1;            if (firstPlayer + secondPlayer &lt;= (n + 1) / 2) {                while (firstPlayer + secondPlayer &lt;= (n + 1) / 2) {                    res++;                    n = (n + 1) / 2;                }                if (secondPlayer - firstPlayer &gt; 1) return res + 1;            }            if (secondPlayer - firstPlayer == 1) {                res++;                n = (n + 1) / 2;                while (n &amp; 1) {                    res++;                    n = (n + 1) / 2;                }                return res;            }            if (secondPlayer &lt;= (n + 1) / 2) return res + 1;            if (secondPlayer - firstPlayer == 2) {                res++;                n = (n + 1) / 2;                while(n &amp; 1) {                    res++;                    n = (n + 1) / 2;                }                return res;            }            if (firstPlayer % 2 == 0 &amp;&amp; firstPlayer + secondPlayer == n) {                res++;            }            return res + 1;        };        return {cal(n), min(bit_width(n - 1u), n + 1 -secondPlayer)};    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3169-无需开会的工作日","url":"/2025/07/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983169-%E6%97%A0%E9%9C%80%E5%BC%80%E4%BC%9A%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%97%A5/","content":"题意给定整数days表示总天数，以及数组meetings其内记录每个会议的开始与结束时间（包含首尾）。\n求没有会议的天数。\n思路比较自然可以想到使用差分，但发现数据范围有点太大并不好做。进一步观察可以想到将会议按开始时间排序，模拟合并求出有会议的天数，再反过来求无会议天数即可。\n实现class Solution {public:    int countDays(int days, vector&lt;vector&lt;int&gt;&gt;&amp; meetings) {        ranges::sort(meetings);        int l = 1, r = 0;        for (const auto&amp; vec : meetings) {            if (vec[0] &gt; r) {                days -= r - l + 1;                l = vec[0];            }            r = max(r, vec[1]);        }        return days - (r - l + 1);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3440-重新安排会议得到最多空余时间 II","url":"/2025/07/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983440-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%9A%E7%A9%BA%E4%BD%99%E6%97%B6%E9%97%B4-II/","content":"题意给定整数eventTime表示总时长，活动开始于t = 0结束于t = eventTime\n同时给定两个数组startTime与endTime表示n个时间没有重叠的会议的开始与结束时间。\n最多可以平移1个会议，使其保持原会议时长但改变其开始结束时间，可以改变会议的相对顺序。求可以得到的会议间最长连续空闲时间。\n思路和昨天的题非常的像，只是条件变成了只能移动一个会议但可以改变会议的顺序。\n可以想到，有两种方式可以得到最优，首先是不改变会议的相对顺序即按照昨天的做法不过k变为了1，另一种则是将每一个会议尝试放入其他会议之间，原位置前后的空闲时间。简单模拟两种操作取最优即可。\n同样是好早之前写的（\n实现class Solution {public:    int maxFreeTime(int eventTime, vector&lt;int&gt;&amp; startTime, vector&lt;int&gt;&amp; endTime) {        vector&lt;array&lt;int, 3&gt;&gt; len;        const int n = startTime.size();        for (int i = 0; i &lt; n; i++) {            if (i == 0) {                len.push_back({startTime[i], 0, 0});            } else {                len.push_back({startTime[i] - endTime[i - 1], i, i - 1});            }        }        len.push_back({eventTime - endTime.back(), n - 1, n - 1});        sort(len.begin(), len.end());        int ans = len.back()[0];        for (int i = 0; i &lt; n; i++) {            if (i == 0) {                ans = max(ans, startTime[i + 1] - endTime[i] + startTime[i]);            } else if (i == n - 1) {                ans = max(ans, eventTime - endTime[i - 1] - endTime[i] + startTime[i]);            } else {                ans = max(ans, startTime[i] - endTime[i - 1] + startTime[i + 1] - endTime[i]);            }        }        for (int i = 0; i &lt; n; i++) {            int l = endTime[i] - startTime[i];            array&lt;int, 3&gt; tmp = {l, 0, 0};            auto it = lower_bound(len.begin(), len.end(), tmp);            while (it != len.end() &amp;&amp; ((*it)[1] == i || (*it)[2] == i)) {                it++;            }            if (it == len.end()) continue;            if (i == 0) {                ans = max(ans, startTime[i + 1]);            } else if (i == n - 1) {                ans = max(ans, eventTime - endTime[i - 1]);            } else {                ans = max(ans, startTime[i + 1] - endTime[i - 1]);            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3439-重新安排会议得到最多空余时间 I","url":"/2025/07/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983439-%E9%87%8D%E6%96%B0%E5%AE%89%E6%8E%92%E4%BC%9A%E8%AE%AE%E5%BE%97%E5%88%B0%E6%9C%80%E5%A4%9A%E7%A9%BA%E4%BD%99%E6%97%B6%E9%97%B4-I/","content":"题意给定整数eventTime表示总时长，活动开始于t = 0结束于t = eventTime\n同时给定两个数组startTime与endTime表示n个时间没有重叠的会议的开始与结束时间。\n最多可以平移k个会议，使其保持原会议时长但改变其开始结束时间，同时保持所有会议相对顺序不变且无重叠。求可以得到的会议间最长连续空闲时间。\n思路发现这题之前赛时写过，但实在有点久远同时又是比赛过程，所以可能可能有些丑陋。但最近上班好累哦，实在懒得重写（\n大概就是直接模拟将多个会议拼在一起往前平移或往后平移所能得到的最大空闲块即可。\n实现class Solution {public:    int maxFreeTime(int eventTime, int k, vector&lt;int&gt;&amp; startTime, vector&lt;int&gt;&amp; endTime) {        vector&lt;int&gt; len(startTime.size());        for (int i = 0; i &lt; startTime.size(); i++) {            len[i] = endTime[i] - startTime[i];        }        int start = 0, sum = 0, cnt = 0, lo = 0, l = 0;        int ans = 0;        for (int i = 0; i &lt; startTime.size(); i++) {            sum += len[i];            cnt++;            if (cnt &lt; k) continue;            if (cnt &gt; k) {                cnt--;                sum -= len[lo];                start = endTime[lo];                l = endTime[lo];                lo++;            }            ans = max({ans, (i &lt; startTime.size() - 1 ? startTime[i + 1] - sum - l : eventTime - sum - l)});        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1751-最多可以参加的会议数目 II","url":"/2025/07/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981751-%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%95%B0%E7%9B%AE-II/","content":"题意给定数组events与整数k，其中event[i] = [startDat_i, endDay_i, value_i]表示第i个会议开始与结束的时间以及其价值。若完整参加某一会议可得其价值，最多参加k个会议，求所能得到的最大总价值。\n思路首先考虑所有会议价值一致且无参加的会议数量限制，那么比较经典是将会议按结束时间排序进行贪心。\n再考虑加入会议价值的影响，也不难想到使用dp，递推或递归地推出每一时刻结束前所能获得的最大价值。\n最后是参加会议数量的限制，在前一思路的基础上加入已参与会议的数量维度即可。\n实现class Solution {public:    int maxValue(vector&lt;vector&lt;int&gt;&gt;&amp; events, int k) {        const int n = events.size();        ranges::sort(events, [&amp;](const auto&amp; x, const auto&amp; y) {            return x[1] &lt; y[1];        });        vector dp(n + 1, vector&lt;int&gt; (k + 1));        for (int i = 0; i &lt; n; i++) {            int p = lower_bound(events.begin(), events.end(), events[i][0], [](const auto&amp; x, int t) {                return x[1] &lt; t;            }) - events.begin();            for (int j = 1; j &lt;= k; j++) {                dp[i + 1][j] = max(dp[i][j], dp[p][j - 1] + events[i][2]);            }        }        return dp[n][k];    }};\n\n\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1353-最多可以参加的会议数目","url":"/2025/07/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981353-%E6%9C%80%E5%A4%9A%E5%8F%AF%E4%BB%A5%E5%8F%82%E5%8A%A0%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%95%B0%E7%9B%AE/","content":"题意给定数组events，其中event[i] = [startDat_i, endDay_i]表示第i个会议开始与结束的时间。每日最多可参加一个会议，求最多可以参加几个会议。（不必完整参加某个会议）\n思路显然是满足贪心性质的，对于每个当前未参加且可参加的会议，应当选择结束时间最早的会议，使用优先队列进行维护可参加的会议即可。\n实现class Solution {public:    int maxEvents(vector&lt;vector&lt;int&gt;&gt;&amp; events) {        int mx = 0;        for (const auto&amp; vec : events) {            mx = max(mx, vec.back());        }        int ans = 0;        const int n = events.size();        vector&lt;vector&lt;int&gt;&gt; cnt(mx + 1);        for (const auto&amp; vec : events) {            cnt[vec.front()].push_back(vec.back());        }        priority_queue&lt;int, vector&lt;int&gt;, greater&lt;&gt;&gt; pq;        for (int i = 0; i &lt;= mx; i++) {            while (!pq.empty() &amp;&amp; pq.top() &lt; i) {                pq.pop();            }            for (const auto&amp; x : cnt[i]) {                pq.push(x);            }            if (!pq.empty()) {                ans++;                pq.pop();            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1865-找出和为指定值的下标对","url":"/2025/07/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981865-%E6%89%BE%E5%87%BA%E5%92%8C%E4%B8%BA%E6%8C%87%E5%AE%9A%E5%80%BC%E7%9A%84%E4%B8%8B%E6%A0%87%E5%AF%B9/","content":"题意给定数组nums1与nums2，实现支持以下功能的数据结构：\n\n将nums2下标为index的值增加val\n求满足nums1[i] + nums2[j] == tot的下标对(i, j)的数量\n\n注意：\n\n1 &lt;= nums1.length &lt;= 1000\n1 &lt;= nums2.length &lt;= 10^5\n\n思路显然该数据结构需要记录nums2以用于实现功能1。同时求和为某定值的下标对数，比较容易想到使用哈希记录某一数组各数值数量然后遍历另一数组实现，此处观察数据范围，不难想到应使用哈希记录nums2遍历nums1有着更好的效率。\n实现class FindSumPairs {private:    unordered_map&lt;int, int&gt; cnt;    vector&lt;int&gt; a, b;public:    FindSumPairs(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        a = nums1;        b = nums2;        for (const auto&amp; x : nums2) cnt[x]++;    }        void add(int index, int val) {        cnt[b[index]]--;        b[index] += val;        cnt[b[index]]++;    }        int count(int tot) {        int res = 0;        for (const auto&amp; x : a) {            if (cnt.count(tot - x)) res += cnt[tot - x];        }        return res;    }};/** * Your FindSumPairs object will be instantiated and called as such: * FindSumPairs* obj = new FindSumPairs(nums1, nums2); * obj-&gt;add(index,val); * int param_2 = obj-&gt;count(tot); */\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1394-找出数组中的幸运数","url":"/2025/07/05/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981394-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%B9%B8%E8%BF%90%E6%95%B0/","content":"题意给定数组arr，若某个数的出现频次与它的大小相等则称该数幸运。求arr中最大的幸运数。\n思路简单哈希记录下各个数出现的频率比较大小即可。\n实现class Solution {public:    int findLucky(vector&lt;int&gt;&amp; arr) {        unordered_map&lt;int, int&gt; cnt;        int ans = -1;        for (const auto&amp; x : arr) cnt[x]++;        for (auto [x, t] : cnt) {            if (x == t) {                ans = max(x, ans);            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3307-找出第 K 个字符 II","url":"/2025/07/04/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983307-%E6%89%BE%E5%87%BA%E7%AC%AC-K-%E4%B8%AA%E5%AD%97%E7%AC%A6-II/","content":"题意给定字符串word = \"a\"以及整数k以及一个操作数组operations，对于每次操作，若operations[i] == 0表示该次操作将当前字符串直接复制加入到当前字符串末尾，若operations[i] == 1表示会将当前字符串复制一遍并将其内每个字符全部变为字母表顺序的下一个字符（其中'z'会变为'a'）后将其插入到当前字符串的末尾，求问第k个字符是什么。\n思路那很显然和昨天题意非常相似，只是多了个操作数组限制，当op[i] == 0时前后两截一致也就是不加，当op[i] == 1时与昨日一致，故不过多赘述。\n实现class Solution {public:    char kthCharacter(long long k, vector&lt;int&gt;&amp; operations) {        const int n = operations.size();        k--;        int t = 0;        for (int i = min(50, n - 1); i &gt;= 0; i--) {            if (k &gt;&gt; i &amp; 1) {                t += operations[i];            }        }        return char('a' + t % 26);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3304-找出第 K 个字符 I","url":"/2025/07/03/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983304-%E6%89%BE%E5%87%BA%E7%AC%AC-K-%E4%B8%AA%E5%AD%97%E7%AC%A6-I/","content":"题意给定字符串word = \"a\"以及整数k，对于每次操作，会将当前字符串复制一遍并将其内每个字符全部变为字母表顺序的下一个字符（其中'z'会变为'a'）后将其插入到当前字符串的末尾，求问第k个字符是什么。\n思路可以模拟一下这个过程有\n初始[a]第一次[a][a+1]第二次[[a][a+1]][[a+1][a+2]]第三次[[a][a+1][a+1][a+2]][[a+1][a+2][a+2][a+3]]...\n\n显然可以观察到字符串的长度是随操作次数成倍增长的，那就可以比较自然的想到对k进行一下二进制的回溯。\n实现class Solution {public:    char kthCharacter(int k) {        int t = 0;        while (k &gt; 1) {            t++;            k -= (1 &lt;&lt; __lg(k - 1));        }        return char(t % 26 + 'a');    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3333-找到初始输入字符串 II","url":"/2025/07/02/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983333-%E6%89%BE%E5%88%B0%E5%88%9D%E5%A7%8B%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2-II/","content":"题意给出字符串word与整数k， Alice 在打这个字符串时可能在某个键停留过久使得该字符被输入多次，已知 Alice 最初所输入的字符串长度不小于k，求 Alice 最初想输入的字符串的可能数量。\n思路先不考虑长度问题，那么就和昨天的题非常类似，仅仅是 Alice 犯错次数变为无限多，那还是很好做的。也就是总的方案数是好求的。\n最终字符串的长度大于某值的方案数似乎不太好做，但不大于某长度的就好做很多，进行一个分组dp即可。\n实现using ll = long long;static constexpr int mod = 1e9 + 7;class Solution {public:    int possibleStringCount(string word, int k) {        const int n = word.size();        if (n &lt; k) return 0;        ll ans = 1;        vector&lt;int&gt; f;        for (int i = 0; i &lt; n; ) {            int j;            for (j = i + 1; j &lt; n &amp;&amp; word[i] == word[j]; j++);            k--;            if (j - i &gt; 1) {                ans = ans * (j - i) % mod;                f.push_back(j - i - 1);            }            i = j;        }        if (k &lt;= 0) return ans;        const int m = f.size();        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt; (k));        vector&lt;int&gt; pre(k + 1);        ranges::fill(dp[0], 1);        for (int i = 0; i &lt; m; i++) {            for (int j = 0; j &lt; k; j++) {                pre[j + 1] = (pre[j] + dp[i][j]) % mod;            }            for (int j = 0; j &lt; k; j++) {                dp[i + 1][j] = (pre[j + 1] - pre[max(j - f[i], 0)]) % mod;            }        }        return (ans - dp[m][k - 1] + mod) % mod;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3330-找到初始输入字符串 I","url":"/2025/07/01/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983330-%E6%89%BE%E5%88%B0%E5%88%9D%E5%A7%8B%E8%BE%93%E5%85%A5%E5%AD%97%E7%AC%A6%E4%B8%B2-I/","content":"题意给出字符串word， Alice 在打这个字符串时可能在某个键停留过久使得该字符被输入多次，但 Alice 最多犯一次这样的错误，求 Alice 最初想输入的字符串的可能数量。\n思路若存在多个相邻相同的字符，则均可拆解为 Alice 失误，寻找所有相邻相同的子串长度即可。\n实现class Solution {public:    int possibleStringCount(string word) {        int ans = 1;        const int n = word.size();        for (int i = 0; i &lt; n; ) {            int j;            for (j = i + 1; j &lt; n &amp;&amp; word[j] == word[i]; j++);            ans += j - i - 1;            i = j;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题594-最长和谐子序列","url":"/2025/06/30/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98594-%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97/","content":"题意给定数组nums。求nums中最大最小值只差为1的最长子序列长度。\n思路令每个数作为最小值，判断其值加一是否存在以及对应数的数量即可。\n实现class Solution {public:    int findLHS(vector&lt;int&gt;&amp; nums) {        unordered_map&lt;int, int&gt; cnt;        for (const auto&amp; x : nums) cnt[x]++;        int mx = 0;        for (auto [x, t] : cnt) {            if (cnt.count(x + 1)) {                mx = max(mx, t + cnt[x + 1]);            }        }        return mx;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1498-满足条件的子序列数目","url":"/2025/06/29/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981498-%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums与整数target，求nums中满足最大最小值之和不超过target的子序列的个数。\n思路需要求的是子序列，所以其顺序是无所谓的，故而考虑直接排序，这样最大最小值就方便直接选择。\n使得最大最小值之和不超过某一定值，若x + y不超过某值，显然若z &lt; y则必有x + z不超过对应值。故而可以直接使用双指针，记录若选出当前最小值，最大值可以选哪个，再计算出对应子序列数量即可。\n实现using ll = long long;static constexpr int mod = 1e9 + 7;ll powMod(ll a, ll b) {    ll res = 1;    while (b) {        if (b &amp; 1) {            res = res * a % mod;        }        a = a * a % mod;        b &gt;&gt;= 1;    }    return res;}static constexpr int N =  1e5;ll p[N + 10];int init = []() {    p[0] = 1;    for (int i = 1; i &lt;= N; i++) {        p[i] = (p[i - 1] &lt;&lt; 1) % mod;    }    return 0;} ();class Solution {public:    int numSubseq(vector&lt;int&gt;&amp; nums, int target) {        ranges::sort(nums);        ll ans = 0;        for (int l = 0, r = int(nums.size()) - 1 ; l &lt;= r; ) {            if (nums[l] + nums[r] &gt; target) {                r--;            } else {                // ans = (ans + powMod(2, r - l)) % mod;                ans += p[r - l];                if (ans &gt; mod) ans -= mod;                l++;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2099-找到和最大的长度为 K 的子序列","url":"/2025/06/28/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982099-%E6%89%BE%E5%88%B0%E5%92%8C%E6%9C%80%E5%A4%A7%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA-K-%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/","content":"题意给定整数数组nums与整数k，求nums中长度为k的和最大的子序列。\n思路贪心选出前k大的数即可。\n实现class Solution {public:    vector&lt;int&gt; maxSubsequence(vector&lt;int&gt;&amp; nums, int k) {        const int n = nums.size();        vector&lt;int&gt; p(n);        ranges::iota(p, 0);        ranges::sort(p, [&amp;](const int&amp; x, const int&amp; y) {            return nums[x] &gt; nums[y];        });        p.resize(k);        ranges::sort(p);        for (auto&amp; i : p) i = nums[i];        return p;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2014-重复 K 次的最长子序列","url":"/2025/06/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982014-%E9%87%8D%E5%A4%8D-K-%E6%AC%A1%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E5%BA%8F%E5%88%97/","content":"题意给定字符串s与整数k，求最长且字典序最大且在s中出现k次的子序列。\n注意到 \n思路好像有点难，但注意到数据范围有暗示s.size() &lt;= 8 * k，那也就是说答案子序列最长为8，进行一个枚举复杂度是可以接受的，故筛出至少出现k次的字符，进行枚举对应子序列即可。\n实现class Solution {public:    string longestSubsequenceRepeatedK(string s, int k) {        const int n = s.size();        vector&lt;array&lt;int, 26&gt;&gt; nxt(n);        array&lt;int, 26&gt; cnt, tmp;        cnt.fill(0); tmp.fill(n);        for (const auto&amp; ch : s) cnt[ch - 'a']++;        for (int i = n - 1; i &gt;= 0; i--) {            tmp[s[i] - 'a'] = i;            nxt[i] = tmp;        }        string a;        for (int i = 25; i &gt;= 0; i--) {            a.insert(a.end(), cnt[i] / k, char(i + 'a'));        }        const int m = a.size();        vector&lt;bool&gt; vis(m);        string ans;        auto check = [&amp;](const string&amp; x) -&gt; void {            if (x.size() &lt; ans.size() || (x.size() == ans.size() &amp;&amp; x &lt;= ans)) return;            int cur = 0, t = k;            while (t--) {                for (const auto&amp; ch : x) {                    if (cur &gt;= n) return;                    cur = nxt[cur][ch - 'a'] + 1;                }            }            if (cur == n + 1) return;            ans = x;        };        string x;        auto dfs = [&amp;](this auto&amp;&amp; self) -&gt; void {            check(x);            if (x.size() == m) return;            for (int i = 0; i &lt; m; i++) {                if (vis[i] || (i &amp;&amp; a[i - 1] == a[i] &amp;&amp; !vis[i - 1])) continue;                x += a[i];                vis[i] = true;                self();                x.pop_back();                vis[i] = false;            }        };        dfs();        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2311-小于等于 K 的最长二进制子序列","url":"/2025/06/26/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982311-%E5%B0%8F%E4%BA%8E%E7%AD%89%E4%BA%8E-K-%E7%9A%84%E6%9C%80%E9%95%BF%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%90%E5%BA%8F%E5%88%97/","content":"题意给定二进制字符串s与整数k，求字符串s子序列的最大长度，要求该子序列的对应二进制数不大于k，允许存在前导零。\n思路显然贪心即可：\n允许存在前导零，那显然应该将所有0加入答案。\n对于1，可以发现最好情况下将其加入答案使得答案加一，最坏情况下需要删除1到多个0才可将其加入答案子序列。\n那么从后往前贪即可得到最长答案，注意别爆数据范围即可。\n实现class Solution {public:    int longestSubsequence(string s, int k) {        const int n = s.size();        int ans = 0;        for (int i = n - 1, cur = 0; i &gt;= 0; i--) {            if (s[i] == '0') ans++;            else {                if (ans &gt;= 30) continue;                if ((cur | (1 &lt;&lt; ans)) &lt;= k) {                    cur |= 1 &lt;&lt; ans;                    ans++;                }            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2040-两个有序数组的第 K 小乘积","url":"/2025/06/25/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982040-%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E7%AC%AC-K-%E5%B0%8F%E4%B9%98%E7%A7%AF/","content":"题意给定两个升序数组nums1与nums2以及一个整数k，求第k小的nums1[i] * nums2[j]。\n思路比较显然是一个二分。\n列出矩阵，其中matrix[i][j]表示nums1[i] * nums2[j]的结果，由于两个数组均为升序排序，故可得一些性质，由此二分答案即可。\n实现class Solution {using ll = long long;public:    long long kthSmallestProduct(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2, long long k) {        const int n = nums1.size(), m = nums2.size();        int x = ranges::lower_bound(nums1, 0) - nums1.begin();        int y = ranges::lower_bound(nums2, 0) - nums2.begin();            auto check = [&amp;](ll mid) -&gt; bool {            ll cnt = 0;            if (mid &lt; 0) {                for (int i = 0, j = y; i &lt; x &amp;&amp; j &lt; m &amp;&amp; cnt &lt; k; ) {                    if (1ll * nums1[i] * nums2[j] &gt; mid) j++;                    else {                        cnt += m - j;                        i++;                    }                }                for (int i = x, j = 0; i &lt; n &amp;&amp; j &lt; y &amp;&amp; cnt &lt; k; ) {                    if (1ll * nums1[i] * nums2[j] &gt; mid) i++;                    else {                        cnt += n - i;                        j++;                    }                }            } else {                cnt = 1ll * x * (m - y) + 1ll * (n - x) * y;                for (int i = 0, j = y - 1; i &lt; x &amp;&amp; j &gt;= 0 &amp;&amp; cnt &lt; k; ) {                    if (1ll * nums1[i] * nums2[j] &gt; mid) i++;                    else {                        cnt += x - i;                        j--;                    }                }                for (int i = x, j = m - 1; i &lt; n &amp;&amp; j &gt;= y &amp;&amp; cnt &lt; k; ) {                    if (1ll * nums1[i] * nums2[j] &gt; mid) j--;                    else {                        cnt += j - y + 1;                        i++;                    }                }            }            return cnt &gt;= k;        };        array&lt;ll, 4&gt; tmp = {1ll * nums1.front() * nums2.front(), 1ll * nums1.front() * nums2.back(), 1ll * nums1.back() * nums2.front(), 1ll * nums1.back() * nums2.back()};        auto [lo, hi] = ranges::minmax(tmp);        while (lo &lt; hi) {            ll mid = lo + hi &gt;&gt; 1;            if (check(mid)) {                hi = mid;            } else {                lo = mid + 1;            }        }        return lo;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2200-找出数组中的所有 K 近邻下标","url":"/2025/06/24/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982200-%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89-K-%E8%BF%91%E9%82%BB%E4%B8%8B%E6%A0%87/","content":"题意给定数组nums与整数key和k。求nums中所有与值为key距离不超过k的下标集合，升序返回。\n思路记录已经加入答案集合的右边界，遍历寻找值为key的下标即可。\n实现class Solution {public:    vector&lt;int&gt; findKDistantIndices(vector&lt;int&gt;&amp; nums, int key, int k) {        const int n = nums.size();        vector&lt;int&gt; ans;        for (int i = 0, l = 0; i &lt; n; i++) {            while (i - l &gt; k) l++;            if (nums[i] == key) {                while (l &lt; n &amp;&amp; abs(i - l) &lt;= k) ans.push_back(l++);            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2081-k 镜像数字的和","url":"/2025/06/23/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982081-k-%E9%95%9C%E5%83%8F%E6%95%B0%E5%AD%97%E7%9A%84%E5%92%8C/","content":"题意定义k镜像数字为在十进制与k进制下均为回文数字的正整数\n对于给定的整数k与n，求出前n小的k镜像数字之和。\n思路注意到n与k的数据范围不大，直接预处理作答即可。\n实现using ll = long long;static constexpr int MX = 30;static constexpr int K = 10;ll ans[K][MX + 10];bool check(ll x, int k) {    string s;    while (x) {        s += char(x % k + '0');        x /= k;    }    for (int l = 0, r = int(s.size()) - 1; l &lt;= r; l++, r--) {        if (s[l] != s[r]) return false;    }    return true;}bool over() {    bool res = true;    for (int i = 2; i &lt; K &amp;&amp; res; i++) {        res &amp;= ans[i][0] &gt;= MX;    }    return res;}int init = []() {    for (int b = 1; ; b *= 10) {        for (int i = b; i &lt; b * 10; i++) {            string s = to_string(i);            string r = s;            reverse(r.begin(), r.end());            s.pop_back();            s += r;            ll u = stoll(s);            for (int k = 2; k &lt; K; k++) {                if (ans[k][0] &gt;= MX) continue;                if (check(u, k)) ans[k][++ans[k][0]] = u;            }        }        for (int i = b; i &lt; b * 10; i++) {            string s = to_string(i);            string r = s;            reverse(r.begin(), r.end());            s += r;            ll u = stoll(s);            for (int k = 2; k &lt; K; k++) {                if (ans[k][0] &gt;= MX) continue;                if (check(u, k)) ans[k][++ans[k][0]] = u;            }        }        if (over()) break;    }    for (int k = 2; k &lt; 10; k++) {        for (int i = 2; i &lt;= MX; i++) {            // cout &lt;&lt; k &lt;&lt; ' ' &lt;&lt; i &lt;&lt; ' ' &lt;&lt; ans[k][i] &lt;&lt; '\\n';            ans[k][i] += ans[k][i - 1];        }    }    return 0;} ();class Solution {public:    long long kMirror(int k, int n) {        return ans[k][n];    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2138-将字符串拆分为若干长度为 k 的组","url":"/2025/06/22/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982138-%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%86%E5%88%86%E4%B8%BA%E8%8B%A5%E5%B9%B2%E9%95%BF%E5%BA%A6%E4%B8%BA-k-%E7%9A%84%E7%BB%84/","content":"题意给定字符串s与整数k与字符fill，需将s分割为长度均为k的子串，长度不足k的用字符fill填充。\n思路简单模拟即可。\n实现class Solution {public:    vector&lt;string&gt; divideString(string s, int k, char fill) {        const int n = s.size();        vector&lt;string&gt; ans;        for (int i = 0; i &lt; n; i += k) {            ans.push_back(s.substr(i, k));            if (i + k &gt;= n) {                while (ans.back().size() &lt; k) ans.back() += fill;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3085-成为 K 特殊字符串需要删除的最少字符数","url":"/2025/06/21/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983085-%E6%88%90%E4%B8%BA-K-%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E5%88%A0%E9%99%A4%E7%9A%84%E6%9C%80%E5%B0%91%E5%AD%97%E7%AC%A6%E6%95%B0/","content":"题意给定字符串word与整数k，可以任意删除word中的字符，需使得word中的任意两种字符出现次数差值不超过k，求需要删除的最小次数。\n思路显然至少存在一种字符不需要删除，进行枚举贪心即可。\n实现class Solution {static constexpr int N = 26;public:    int minimumDeletions(string word, int k) {        array&lt;int, N&gt; cnt;        for (const auto&amp; ch : word) cnt[ch - 'a']++;        ranges::sort(cnt);        int mx = 0;        for (int i = 0; i &lt; N; i++) {            int tmp = 0;            for (int j = i; j &lt; N; j++) {                tmp += min(cnt[j], cnt[i] + k);            }            mx = max(mx, tmp);        }        return word.size() - mx;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3443-K 次修改后的最大曼哈顿距离","url":"/2025/06/20/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983443-K-%E6%AC%A1%E4%BF%AE%E6%94%B9%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E6%9B%BC%E5%93%88%E9%A1%BF%E8%B7%9D%E7%A6%BB/","content":"题意初始位于坐标原点(0, 0)，给定由NSWE组成的字符串，分别表示向北南西东走一格，最多可以修改字符串的k个字符，求移动过程中离原点的最大曼哈顿距离。\n思路贪心地进行模拟即可。\n实现class Solution {public:    int maxDistance(string s, int k) {        int x = 0, y = 0;        const int n = s.size();        int ans = 0;        for (int i = 0; i &lt; n; i++) {            if (s[i] == 'N') {                y++;            } else if (s[i] == 'S') {                y--;            } else if (s[i] == 'E') {                x++;            } else {                x--;            }            ans = max(ans, abs(x) + abs(y) + min(2 * k, i + 1 - abs(x) - abs(y)));        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2294-划分数组使最大差为 K","url":"/2025/06/19/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982294-%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E4%BD%BF%E6%9C%80%E5%A4%A7%E5%B7%AE%E4%B8%BA-K/","content":"题意给定数组nums与整数k，将nums划分为子序列，使得每个子序列最大值与最小值的差值不超过k，求所需划分的最少子序列数。\n思路显然符合贪心性质，直接排序开贪即可。\n实现class Solution {public:    int partitionArray(vector&lt;int&gt;&amp; nums, int k) {        ranges::sort(nums);        const int n = nums.size();        int cnt = 1;        for (int l = 0, i = 0; i &lt; n; i++) {            if (nums[i] - nums[l] &lt;= k) continue;            cnt++;            l = i;        }        return cnt;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2966-划分数组并满足最大差限制","url":"/2025/06/18/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982966-%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84%E5%B9%B6%E6%BB%A1%E8%B6%B3%E6%9C%80%E5%A4%A7%E5%B7%AE%E9%99%90%E5%88%B6/","content":"题意给定长度为3的倍数的数组nums，以及一个正整数k，要求把数组分割为长度均为3的子数组，要求子数组中任意两数差均小于等于k\n思路什么样的子数组满足任意两数差均小于等于k呢，显然是最大最小值差值小于等于k的，因此不难想到首先进行排序，贪心地不断连续选取3个数为一组即可。\n实现class Solution {public:    vector&lt;vector&lt;int&gt;&gt; divideArray(vector&lt;int&gt;&amp; nums, int k) {        const int n = nums.size();        vector&lt;vector&lt;int&gt;&gt; ans;        ranges::sort(nums);        for (int i = 2; i &lt; n; i += 3) {            if (nums[i] - nums[i - 2] &lt;= k) {                ans.push_back({nums[i], nums[i - 1], nums[i - 2]});            } else {                return {};            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3405-统计恰好有 K 个相等相邻元素的数组数目","url":"/2025/06/17/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983405-%E7%BB%9F%E8%AE%A1%E6%81%B0%E5%A5%BD%E6%9C%89-K-%E4%B8%AA%E7%9B%B8%E7%AD%89%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E7%9A%84%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/","content":"题意对于给定的三个正整数n、m、k，称满足以下条件的数组arr为好数组\n\narr的长度为n\narr的元素均为[1, m]\narr中恰好有k对满足arr[i] == arr[i - 1]的下标\n\n求好数组arr的构造数\n思路仔细观察可以发现该题其实就是个数学题，进行一个推式子即可\n首先长为n的数组共有n - 1对相邻元素，要求恰好有k对相邻元素相同，也就是说有n - 1 - k对相邻元素不同。也就是说有会有n - 1 - k个数将整个数组分割为n - k段，每段元素相同。\n计算分割方案与分割后填色数即可。\n实现static constexpr int mod = 1e9 + 7;static constexpr int N = 1e5;int f[N + 1], nf[N + 1];int powMod(int a, int b) {    int res = 1;    while (b) {        if (b &amp; 1) {            res = 1ll * res * a % mod;        }        a = 1ll * a * a % mod;        b &gt;&gt;= 1;    }    return res;}int C(int n, int k) {    return 1ll * f[n] * nf[k] % mod * nf[n - k] % mod;}int init = []() -&gt; int {    f[0] = 1;    for (int i = 1; i &lt;= N; i++) {        f[i] = 1ll * f[i - 1] * i % mod;    }    nf[N] = powMod(f[N], mod - 2);    for (int i = N; i &gt; 0; i--) {        nf[i - 1] = 1ll * nf[i] * i % mod;    }    return 0;} ();class Solution {public:    int countGoodArrays(int n, int m, int k) {        return 1ll * C(n - 1, k) * m % mod * powMod(m - 1, n - k - 1) % mod;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2016-增量元素之间的最大差值","url":"/2025/06/16/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982016-%E5%A2%9E%E9%87%8F%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/","content":"题意给定数组nums，求满足以下条件的nums[j] - nums[i]的最大值\n\n\n\n\n思路对于同一个i显然应该选择其后最大的nums[j]才能使得nums[j] - nums[i]最大，因此不难想到使用后缀最大即可。\n实现class Solution {public:    int maximumDifference(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        int ans = -1;        for (int i = n - 1, mx = -1; i &gt;= 0; i--) {            if (mx &gt; nums[i]) ans = max(ans, mx - nums[i]);            mx = max(mx, nums[i]);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1432-改变一个整数能得到的最大差值","url":"/2025/06/15/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981432-%E6%94%B9%E5%8F%98%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E8%83%BD%E5%BE%97%E5%88%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/","content":"题意给定一个整数num，可以将其中某一个数字全部替换为另一数字，求可以得到的最大值与最小值的差值。但不可以转为有前导0的数\n思路显然就是做题的题加上不能有前导零的条件，进行贪心即可。\n实现class Solution {public:    int maxDiff(int num) {        string s = to_string(num);        string t = s;        const int n = s.size();        for (int i = 0, b = -1; i &lt; n; i++) {            if (s[i] == '9') continue;            if (b == -1) {                b = s[i] - '0';                s[i] = '9';            } else if (b == s[i] - '0') s[i] = '9';        }        if (t.front() != '1') {            for (int i = n - 1; i &gt;= 0; i--) {                if (t[i] == t.front()) t[i] = '1';            }        } else {            for (int i = 0, b = -1; i &lt; n; i++) {                if (t[i] &lt;= '1') continue;                if (b == -1) {                    b = t[i] - '0';                }                if (t[i] - '0' == b) t[i] = '0';            }        }        return stoi(s) - stoi(t);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2566-替换一个数字后的最大差值","url":"/2025/06/14/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982566-%E6%9B%BF%E6%8D%A2%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%97%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/","content":"题意给定一个整数num，可以将其中某一个数字全部替换为另一数字，求可以得到的最大值与最小值的差值。\n思路比较显然是可以贪心的，得最大值应该使得最靠前非9的数变为9，得最小值应该是最靠前非0的数变为0，直接进行模拟即可。\n实现class Solution {public:    int minMaxDifference(int num) {        string s = to_string(num);        string t = s;        const int n = s.size();        for (int i = 0, b = -1; i &lt; n; i++) {            if (s[i] == '9') continue;            if (b == -1) {                b = s[i] - '0';                s[i] = '9';            } else if (b == s[i] - '0') s[i] = '9';        }        for (int i = 0, b = -1; i &lt; n; i++) {            if (t[i] == '0') continue;            if (b == -1) {                b = t[i] - '0';                t[i] = '0';            } else if (b == t[i] - '0') t[i] = '0';        }        return stoi(s) - stoi(t);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2616-最小化数对的最大差值","url":"/2025/06/13/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982616-%E6%9C%80%E5%B0%8F%E5%8C%96%E6%95%B0%E5%AF%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/","content":"题意给定整数数组nums与整数p，找出p对不同下标对(i, j)使得abs(nums[i] - nums[j])最大值最小时的最大值。每个下标在p对下标对中仅出现一次。\n思路使得最大值最小，显然进行二分即可。\n实现class Solution {public:    int minimizeMax(vector&lt;int&gt;&amp; nums, int p) {        ranges::sort(nums);        const int n = nums.size();        auto check = [&amp;](int x) -&gt; bool {            int t = 0;            for (int i = 0; i &lt; n - 1; i++) {                if (nums[i + 1] - nums[i] &lt;= x) {                    t++;                    i++;                }            }            return t &gt;= p;        };        int lo = 0, hi = nums.back() - nums.front();        while (lo &lt; hi) {            int mid = lo + hi &gt;&gt; 1;            if (check(mid)) hi = mid;            else lo = mid + 1;        }        return lo;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3423-循环数组中相邻元素的最大差值","url":"/2025/06/12/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983423-%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9B%B8%E9%82%BB%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC/","content":"题意给定循环数组nums，求相邻元素最大绝对差值。\n思路直接遍历求即可\n实现class Solution {public:    int maxAdjacentDistance(vector&lt;int&gt;&amp; nums) {        int ans = -200;        const int n = nums.size();        for (int i = 1; i &lt;= n; i++) {            ans = max(ans, abs(nums[i % n] - nums[i - 1]));        }        return ans;    }};\n\n\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3345-奇偶频次间的最大差值 II","url":"/2025/06/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983345-%E5%A5%87%E5%81%B6%E9%A2%91%E6%AC%A1%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC-II/","content":"题意给定由['0', '4']组成的字符串s与整数k，求s的子串subs中freq[a] - freq[b]的最大值，其中：\n\nsubs长度至少为k\nfreq表示该字符在subs中出现的次数\nfreq[a]为奇数\nfreq[b]为偶数\n\n思路显然应该使用滑动窗口与前缀最小。\n实现class Solution {static constexpr int inf = 1e9;static constexpr int N = 5;public:    int maxDifference(string s, int k) {        int ans = -inf;        const int n = s.size();        for (int x = 0; x &lt; N; x++) {            for (int y = 0; y &lt; N; y++) {                if (x == y) continue;                array&lt;int, N&gt; cur, pre;                cur.fill(0); pre.fill(0);                array&lt;array&lt;int, 2&gt;, 2&gt; mn;                for (auto&amp; i : mn) i.fill(inf);                int left = 0;                for (int i = 0; i &lt; n; i++) {                    cur[s[i] - '0']++;                    while (i + 1 - left &gt;= k &amp;&amp; cur[x] &gt; pre[x] &amp;&amp; cur[y] &gt; pre[y]) {                        int&amp; t = mn[pre[x] &amp; 1][pre[y] &amp; 1];                        t = min(t, pre[x] - pre[y]);                        pre[s[left++] - '0']++;                    }                    ans = max(ans, cur[x] - cur[y] - mn[cur[x] &amp; 1 ^ 1][cur[y] &amp; 1]);                }            }        }        return  ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3442-奇偶频次间的最大差值 I","url":"/2025/06/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983442-%E5%A5%87%E5%81%B6%E9%A2%91%E6%AC%A1%E9%97%B4%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B7%AE%E5%80%BC-I/","content":"题意给定小写字母字符串s，求diff = a1 - a2的最大值\n其中a1为字符串中任意出现次数为奇数次的字符的出现次数\na2为字符串中任意出现次数为偶数次的字符的出现次数\n思路要使得diff最大，显然应该使得a1取得最大a2取得最小\n也就是选取出现次数为奇数的最大，出现次数为偶数的最大，注意出现0次也就是未出现的字符应不考虑即可。\n实现class Solution {public:    int maxDifference(string s) {        array&lt;int, 26&gt; cnt;        for (const auto&amp; ch : s) {            cnt[ch - 'a']++;        }        int mx = 0, mn = INT_MAX;        for (const auto&amp; i : cnt) {            if (i &amp; 1) mx = max(mx, i);            else if (i) mn = min(mn, i);        }        return mx - mn;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题440-字典序的第K小数字","url":"/2025/06/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98440-%E5%AD%97%E5%85%B8%E5%BA%8F%E7%9A%84%E7%AC%ACK%E5%B0%8F%E6%95%B0%E5%AD%97/","content":"题意给定整数n和k，返回[1, n]中字典序第k小的数字\n思路不妨将数字当作字符串看待，那又比较自然的可以想到字典树。\n是返回[1, n]范围内的数，故而可以得到一颗根节点有9条边其余点有10条边共有n + 1个结点的树。\n将[1, n]的数按照字典序排序，显然是按照先序遍历该树得到，本题数据量较大不太可以直接遍历模拟得到，考虑使用子树结点数进行加速判断：假定当前处于任意结点，需要得到第k小的数，若其第一个子节点子树内所有结点数为x，若 显然所需点不在该子树内，若显然所需点在该子树内。\n实现class Solution {using ll = long long;public:    int findKthNumber(int n, int k) {        int p = 1;        for (int i = n / 10; i &gt; 0; i /= 10) p *= 10;        auto cal = [&amp;](int x) -&gt; int {            int sz = (p - 1) / 9;            ll l = 1ll * p * x, r = 1ll * p * (x + 1);            if (l &lt;= n) {                sz += min(r, n + 1ll) - l;            }            return sz;        };        int x = 1;        k--;        while (k) {            int sz = cal(x);            if (sz &lt;= k) {                k -= sz;                x++;            } else {                p /= 10;                x *= 10;                k--;            }        }        return x;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题386-字典序排数","url":"/2025/06/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98386-%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E6%95%B0/","content":"题意给定整数n，按字典序返回范围[1, n]内所有整数\n思路按字典序进行枚举即可。\n实现class Solution {public:    vector&lt;int&gt; lexicalOrder(int n) {        vector&lt;int&gt; ans(n);        for (int i = 0, num = 1; i &lt; n; i++) {            ans[i] = num;            if (num * 10 &lt;= n) num *= 10;            else {                while (num % 10 == 9 || num + 1 &gt; n) {                    num /= 10;                }                num++;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3170-删除星号以后字典序最小的字符串","url":"/2025/06/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983170-%E5%88%A0%E9%99%A4%E6%98%9F%E5%8F%B7%E4%BB%A5%E5%90%8E%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"题意给定含*的字符串s，要求删除所有*，同时每次删除操作必须删除该*号左侧任意字典序最小的字母，求最终字典序最小的字符串。\n思路对于每次操作，应该删除当前*左侧最右的字典序最小字母，使用栈进行记录即可。\n实现class Solution {static constexpr int N = 26;public:    string clearStars(string s) {        vector&lt;vector&lt;int&gt;&gt; stk(N);        const int n = s.size();        int mask = 0;        for (int i = 0; i &lt; n; i++) {            if (s[i] == '*') {                for (int j = 0; j &lt; 26; j++) {                    if (mask &gt;&gt; j &amp; 1) {                        s[stk[j].back()] = '*';                        stk[j].pop_back();                        if (stk[j].empty()) mask ^= 1 &lt;&lt; j;                        break;                    }                }            } else {                stk[s[i] - 'a'].push_back(i);                mask |= 1 &lt;&lt; (s[i] - 'a');            }        }        s.erase(ranges::remove(s, '*').begin(), s.end());        return s;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2434-使用机器人打印字典序最小的字符串","url":"/2025/06/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982434-%E4%BD%BF%E7%94%A8%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%89%93%E5%8D%B0%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"题意给定字符串s与空白字符串t，以及初始也为空的字符串ans，每次操作可以将s的第一个字符移到t的尾部，或将t最后一个字符移动到ans的尾部，操作直到s和t变为空字符串。求可得到的字典序最小的ans\n思路可以发现这是一个入栈出栈得到字符串的问题，s是原始字符串，t就是栈，移动到t尾部等价于入栈，将t尾加入ans等价于出栈。\n那还是比较经典的，若有还未入栈的字符含有比栈顶小的字符应一路入栈直到当前后缀中最小的字符入栈，再将该最小字符出栈；若未入栈的字符均大于栈顶字符，直接出栈即可。\n加速寻找后缀最小可以使用后缀min。\n实现class Solution {public:    string robotWithString(string s) {        const int n = s.size();        string ans, stk;        vector&lt;int&gt; last(n + 1, n);        for (int i = n - 1; i &gt;= 0; i--) {            if (last[i + 1] == n || s[i] &lt;= s[last[i + 1]]) {                last[i] = i;            } else {                last[i] = last[i + 1];            }        }        for (int cur = 0; cur &lt; n; ) {            if (stk.empty() || stk.back() &gt; s[last[cur]]) {                ans += s[last[cur]];                stk += s.substr(cur, last[cur] - cur);                cur = last[cur] + 1;            } else {                ans += stk.back();                stk.pop_back();            }        }        reverse(stk.begin(), stk.end());        ans += stk;        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1061-按字典序排列最小的等效字符串","url":"/2025/06/05/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981061-%E6%8C%89%E5%AD%97%E5%85%B8%E5%BA%8F%E6%8E%92%E5%88%97%E6%9C%80%E5%B0%8F%E7%9A%84%E7%AD%89%E6%95%88%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":"题意给定两等长字符串s1与s2，以及另一字符串baseStr\ns1与s2相同位置的字符等价，即s1[i]与s2[i]等价\n可将baseStr中的字符任意替换成与其等价的字符\n求baseStr替换后字典序最小的结果。\n思路比较自然可以想到使用并查集，同一集合内的字符是可以互相替换的，要使得字典序最小，应将同一集合内的字符均替换为最小的字符。\n实现class Solution {static constexpr int N = 26;public:    string smallestEquivalentString(string s1, string s2, string baseStr) {        array&lt;int, N&gt; fa;        ranges::iota(fa, 0);        auto find = [&amp;](this auto&amp;&amp; self, int u) -&gt; int {            if (fa[u] == u) return u;            return fa[u] = self(fa[u]);        };        auto merge = [&amp;](int x, int y) -&gt; void {            x = find(x); y = find(y);            if (x == y) return;            if (x &gt; y) swap(x, y);            fa[y] = x;            return;        };        const int n = s1.size();        for (int i = 0; i &lt; n; i++) {            merge(s1[i] - 'a', s2[i] - 'a');        }        for (auto&amp; ch : baseStr) {            ch = char(find(ch - 'a') + 'a');        }        return baseStr;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3403-从盒子中找出字典序最大的字符串 I","url":"/2025/06/04/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983403-%E4%BB%8E%E7%9B%92%E5%AD%90%E4%B8%AD%E6%89%BE%E5%87%BA%E5%AD%97%E5%85%B8%E5%BA%8F%E6%9C%80%E5%A4%A7%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2-I/","content":"题意给定字符串word，要将其划分为numFriends个非空子串，问字典序最大的子串。\n思路数据范围是比较小的，怎么做都可以，直接枚举子串起点进行比较就好。\n实现class Solution {public:    string answerString(string word, int numFriends) {        if (numFriends == 1) return word;        const int n = word.size();        string ans = word.substr(0, n - numFriends + 1);        for (int i = 1; i &lt; n; i++) {            if (word[i] &lt; ans.front()) continue;            else if (word[i] == ans.front()) {                string t = word.substr(i, n - i - max(numFriends - i - 1, 0));                if (t &gt; ans) ans = t;            } else {                ans = word.substr(i, n - i - max(numFriends - i - 1, 0));            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1298-你能从盒子里获得的最大糖果数","url":"/2025/06/03/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981298-%E4%BD%A0%E8%83%BD%E4%BB%8E%E7%9B%92%E5%AD%90%E9%87%8C%E8%8E%B7%E5%BE%97%E7%9A%84%E6%9C%80%E5%A4%A7%E7%B3%96%E6%9E%9C%E6%95%B0/","content":"题意给定n个盒子与盒子的状态，盒子可能开着或关闭若关闭需用对应钥匙打开，同时盒子中有一些糖有一些钥匙甚至一些其他盒子；给出最开始所拥有的盒子，求最多可以获得多少糖果。\n思路就是简单的模拟，没什么思维难度也没什么代码实现难度，不知道为什么标困难，数据范围也小，应该是怎么写都可以的。\n实现class Solution {public:    int maxCandies(vector&lt;int&gt;&amp; status, vector&lt;int&gt;&amp; candies, vector&lt;vector&lt;int&gt;&gt;&amp; keys, vector&lt;vector&lt;int&gt;&gt;&amp; containedBoxes, vector&lt;int&gt;&amp; initialBoxes) {        const int n = status.size();        vector&lt;bool&gt; box(n), key(n), done(n);        vector&lt;int&gt; q;        for (auto&amp; x : initialBoxes) {            box[x] = true;            if (status[x]) q.push_back(x);        }        int ans = 0;        for (int cur = 0; cur &lt; q.size(); cur++) {            int x = q[cur];            if (done[x]) continue;            done[x] = true;            ans += candies[x];            for (auto k : keys[x]) {                key[k] = true;                if (box[k] &amp;&amp; !done[k]) q.push_back(k);            }            for (auto b : containedBoxes[x]) {                box[b] = true;                if ((key[b] || status[b]) &amp;&amp; !done[b]) q.push_back(b);            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题135-分发糖果","url":"/2025/06/02/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98135-%E5%88%86%E5%8F%91%E7%B3%96%E6%9E%9C/","content":"题意给定数组ratings表示小朋友们的分数，小朋友们站成一排，要求给他们每人至少1颗糖果，且若某孩子分数大于相邻的孩子则其糖果数一定大于相邻分数较小的孩子，求最少需要多少糖果。\n思路贪心地想当然是先给最小的一颗糖，然后再慢慢根据大小关系往两边放。\n就比较自然的可以想到建图然后按拓扑序分发糖果。\n但是写完后发现好像没必要，正着跑一趟反着跑一趟与上一个小朋友比较大小关系即可，不知道为什么会标困难，可能也是受这个影响想复杂了。\n实现建图拓扑序：\nclass Solution {public:    int candy(vector&lt;int&gt;&amp; ratings) {        const int n = ratings.size();        vector&lt;vector&lt;int&gt;&gt; e(n);        vector&lt;int&gt; q, d(n), ans(n);        for (int i = 0; i &lt; n; i++) {            if (i &amp;&amp; ratings[i] &lt; ratings[i - 1]) {                e[i].push_back(i - 1);                d[i - 1]++;            }            if (i != n - 1 &amp;&amp; ratings[i] &lt; ratings[i + 1]) {                e[i].push_back(i + 1);                d[i + 1]++;            }        }        for (int i = 0; i &lt; n; i++) {            if (d[i] == 0) q.push_back(i);            ans[i]++;        }        for (int cur = 0; cur &lt; q.size(); cur++) {            int x = q[cur];            for (auto v : e[x]) {                d[v]--;                ans[v] = max(ans[v], ans[x] + 1);                if (d[v] == 0) q.push_back(v);            }        }        return accumulate(ans.begin(), ans.end(), 0);    }};\n\n\n\n直接贪心：\nclass Solution {public:    int candy(vector&lt;int&gt;&amp; ratings) {        const int n = ratings.size();        vector&lt;int&gt; ans(n, 1);        for (int i = 1; i &lt; n; i++) {            if (ratings[i] &gt; ratings[i - 1]) ans[i] = ans[i - 1] + 1;        }        for (int i = n - 2; i &gt;= 0; i--) {            if (ratings[i] &gt; ratings[i + 1]) ans[i] = max(ans[i], ans[i + 1] + 1);        }        return accumulate(ans.begin(), ans.end(), 0);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2929-给小朋友们分糖果 II","url":"/2025/06/01/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982929-%E7%BB%99%E5%B0%8F%E6%9C%8B%E5%8F%8B%E4%BB%AC%E5%88%86%E7%B3%96%E6%9E%9C-II/","content":"题意给定正整数n和limit\n求将n颗糖果分给3个小朋友，每人所得不超过limit颗，有多少种方案数。\n思路正着推好像有点难，可以考虑正难则反。\n求总分配方案数减去有人获得超limit颗的方案数显然比正着推简单一些。\n总分配方案数显然是用隔板法，有种\n有人获得超limit颗需要用到隔板法与一点容斥的想法：\n首先是至少含一人获得超limit，显然应该是首先分配出limit + 1颗糖果再将剩下的分给三人，然后将这limit + 1颗糖果分给任意人即有\n但显然至少一人含超limit的情况包含了至少两人含超与至少三人含超，并且存在重复计数，利用容斥的思想应该减去至少两人含超加上三人含超，由此可得答案。\n至少两人含超limit颗糖果思想同上有\n至少三人含超limit颗糖果有\n至于这个容斥想法怎么来可以简单证明下：\n记三个小朋友分别为 A B C至少一个人含超过 limit 颗糖果有如下情况：\tA 含超过 limit 颗：A AB AC ABC\tB 含超过 limit 颗：B AB BC ABC\tC 含超过 limit 颗：C AC BC ABC显然是存在重复计数的至少两人含超过 limit 颗糖果有如下情况：\tAB 含超过 limit 颗：AB ABC\tAC 含超过 limit 颗：AC ABC\tBC 含超过 limit 颗：BC ABC至少三人含超过 limit 颗糖果有如下情况：\tABC 含超过 limit 颗：ABC\n\n\n\n实现class Solution {using ll = long long;public:    long long distributeCandies(int n, int limit) {        auto cal = [](int x) -&gt; ll {            if (x &lt; 2) return 0;            return 1ll * x * (x - 1) / 2;        };        return cal(n + 2) - 3 * cal(n - limit + 1) + 3 * cal(n - 2 * limit) - cal(n - 3 * limit - 1);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题909-蛇梯棋","url":"/2025/05/31/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98909-%E8%9B%87%E6%A2%AF%E6%A3%8B/","content":"题意给定大小为n * n的矩阵board，初始位于1目标为n * n。每次可走[1, 6]格，若目的格点board值不为-1则传送至目标格点值处，反之若目标格点board值为-1则到达目标格点，不会连续传送即：若通过传送到达点x且x处board值不为-1不会继续进行传送而是停留在x点处。\n求问到达终点最少走几次。\n思路可以考虑直接BFS求出到各点最少移动步数。\n只需注意格点编号类似于’Z’字型，注意进行转换即可。\n实现class Solution {public:    int snakesAndLadders(vector&lt;vector&lt;int&gt;&gt;&amp; board) {        const int n = board.size();                auto cal = [&amp;](int a) -&gt; int {            int x = a / n, y = a % n;            if (x &amp; 1) return board[n - 1 - x][n - 1 - y];            return board[n - 1 - x][y];        };                vector&lt;int&gt; q{0};        vector&lt;bool&gt; vis(n * n);        for (int cur = 0; !q.empty(); cur++) {            vector&lt;int&gt; nq;            for (auto x : q) {                if (x == n * n - 1) return cur;                for (int t = x + 1; t &lt;= x + 6; t++) {                    if (t &gt;= n * n) break;                    int y = cal(t);                    if (y == -1) y = t;                    else y--;                    if (!vis[y]) {                        vis[y] = true;                        nq.push_back(y);                    }                }            }            swap(q, nq);        }        return -1;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2359-找到离给定两个节点最近的节点","url":"/2025/05/30/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982359-%E6%89%BE%E5%88%B0%E7%A6%BB%E7%BB%99%E5%AE%9A%E4%B8%A4%E4%B8%AA%E8%8A%82%E7%82%B9%E6%9C%80%E8%BF%91%E7%9A%84%E8%8A%82%E7%82%B9/","content":"题意给定有向图，每个点至多含一条出边，对于给定两点node1与node2，求这两点均能到达且距两点距离较大值最小的点。\n思路求两点均可达且较大距离最小，可以考虑先求出两点到所有其他点所需距离，再遍历所有点判断即可；\n求两点到其他点距离可以考虑bfs，但注意到该题每个点至多一条出边，那简单循环一下即可。\n实现class Solution {public:    int closestMeetingNode(vector&lt;int&gt;&amp; edges, int node1, int node2) {        const int n = edges.size();        vector&lt;int&gt; dis1(n, n), dis2(n, n);        for (int cur = 0; node1 != -1 &amp;&amp; dis1[node1] == n; node1 = edges[node1]) {            dis1[node1] = cur++;        }        for (int cur = 0; node2 != -1 &amp;&amp; dis2[node2] == n; node2 = edges[node2]) {            dis2[node2] = cur++;        }        int mn = n, ans = -1;        for (int i = 0; i &lt; n; i++) {            if (max(dis1[i], dis2[i]) &lt; mn) {                mn = max(dis1[i], dis2[i]);                ans = i;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3373-连接两棵树后最大目标节点数目 II","url":"/2025/05/29/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983373-%E8%BF%9E%E6%8E%A5%E4%B8%A4%E6%A3%B5%E6%A0%91%E5%90%8E%E6%9C%80%E5%A4%A7%E7%9B%AE%E6%A0%87%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE-II/","content":"题意给定两棵大小分别为n和m的树\n若两点间距离为偶数则称两点互为目标结点。\n求数组answer，其中answer[i]表示将第一二棵树的任意结点相连，第一棵树的结点i的最大目标结点数。\n思路那好像，和昨天的也没什么太大区别啊，不知道为什么昨天给标中等今天标困难了。\n同样的，对第一棵树的每个节点 第一棵树内的目标结点数是固定的，这个可以简单的用类似换根的思路求出来：若结点u目标结点即距离为偶数的点数目为x个，距u距离为奇数的点数应为n - x个，因所有点离它的距离非奇即偶；若v与u直接相邻，所有点离v的距离相对离u的距离一定是加减一的，故离v奇距离的点数为x个，偶距离的为n - x个。\n再考虑连接第二棵树造成的影响，同理，以任意点为根求出距其奇偶距离的点数，显然与其直接相连目标结点可增加距其奇距离数，与其相邻结点相连可增加其偶距离数。\n实现class Solution {public:    vector&lt;int&gt; maxTargetNodes(vector&lt;vector&lt;int&gt;&gt;&amp; edges1, vector&lt;vector&lt;int&gt;&gt;&amp; edges2) {        const int n = edges1.size() + 1, m = edges2.size() + 1;        vector&lt;vector&lt;int&gt;&gt; adj1(n), adj2(m);        for (const auto&amp; e : edges1) {            adj1[e.front()].push_back(e.back());            adj1[e.back()].push_back(e.front());        }        for (const auto&amp; e : edges2) {            adj2[e.front()].push_back(e.back());            adj2[e.back()].push_back(e.front());        }        int cnt = 0;        auto dfs1 = [&amp;](this auto&amp;&amp; self, int u, int fa, int tag) -&gt; void {            if (tag) cnt++;            for (auto v : adj2[u]) {                if (v == fa) continue;                self(v, u, tag ^ 1);            }        };        dfs1(0, -1, 1);        cnt = max(cnt, m - cnt);        vector&lt;int&gt; ans(n);        auto dfs = [&amp;](this auto&amp;&amp; self, int u, int fa, int tag) -&gt; void {            if (tag) ans[0]++;            for (auto v : adj1[u]) {                if (v == fa) continue;                self(v, u, tag ^ 1);            }        };        auto dfs2 = [&amp;](this auto&amp;&amp; self, int u, int fa) -&gt; void {            for (auto v : adj1[u]) {                if (v == fa) continue;                ans[v] = n - ans[u];                self(v, u);            }            ans[u] += cnt;        };        dfs(0, -1, 1);        dfs2(0, -1);        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3372-连接两棵树后最大目标节点数目 I","url":"/2025/05/28/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983372-%E8%BF%9E%E6%8E%A5%E4%B8%A4%E6%A3%B5%E6%A0%91%E5%90%8E%E6%9C%80%E5%A4%A7%E7%9B%AE%E6%A0%87%E8%8A%82%E7%82%B9%E6%95%B0%E7%9B%AE-I/","content":"题意给定两棵大小分别为n和m的树，以及正整数k\n若两点间距离不超过k则称两点互为目标结点。\n求数组answer，其中answer[i]表示将第一二棵树的任意结点相连，第一棵树的结点i的最大目标结点数。\n思路对于给定的某点应该如何连接两棵树使得其目标结点数最大呢\n显然第一棵树应选择该点；而第二棵树所选择的点与第一棵树选取的点无关，应都选择含距离不超过k - 1点最多的点。\n使用bfs求对应距离的点数即可。\n实现class Solution {public:    vector&lt;int&gt; maxTargetNodes(vector&lt;vector&lt;int&gt;&gt;&amp; edges1, vector&lt;vector&lt;int&gt;&gt;&amp; edges2, int k) {        const int n = edges1.size() + 1, m = edges2.size() + 1;        vector&lt;vector&lt;int&gt;&gt; adj1(n), adj2(m);        for (const auto&amp; vec : edges1) {            adj1[vec.front()].push_back(vec.back());            adj1[vec.back()].push_back(vec.front());        }        for (const auto&amp; vec : edges2) {            adj2[vec.front()].push_back(vec.back());            adj2[vec.back()].push_back(vec.front());        }        if (k == 0) return vector&lt;int&gt; (n, 1);        int mx = 0;        for (int i = 0; i &lt; m; i++) {            int t = 0;            vector&lt;array&lt;int, 3&gt;&gt; q {{i, -1, 0}}; int cur = 0;            for ( ; cur &lt; q.size(); cur++) {                auto [u, fa, d] = q[cur];                if (d &gt;= k) break;                t++;                for (auto v : adj2[u]) {                    if (v == fa) continue;                    q.push_back({v, u, d + 1});                }            }            mx = max(mx, t);        }        vector&lt;int&gt; ans(n, mx);        for (int i = 0; i &lt; n; i++) {            int t = 0;            vector&lt;array&lt;int, 3&gt;&gt; q {{i, -1, 0}}; int cur = 0;            for ( ; cur &lt; q.size(); cur++) {                auto [u, fa, d] = q[cur];                if (d &gt; k) break;                t++;                for (auto v : adj1[u]) {                    if (v == fa) continue;                    q.push_back({v, u, d + 1});                }            }            ans[i] += t;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2894-分类求和并作差","url":"/2025/05/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982894-%E5%88%86%E7%B1%BB%E6%B1%82%E5%92%8C%E5%B9%B6%E4%BD%9C%E5%B7%AE/","content":"题意给定整数n与m\n记num1为[1, n]无法被m整除的数的和\n记num2为[1, n]被m整除的数的和\n求num1 - num2\n思路可以发现本题的数据范围很小可以直接继续暴力求解。\n但同时也可以直接进行数学推导：\n注意到[1, n]的数不是被m整除就是无法被m整除\n也就是\n同时,被m整除的数均形如\n故而\n不难得出结果\n\n实现class Solution {public:    int differenceOfSums(int n, int m) {        int ans = (1 + n) * n &gt;&gt; 1;        int t = n / m;        ans -= (1 + t) * t * m;        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1857-有向图中最大颜色值","url":"/2025/05/26/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981857-%E6%9C%89%E5%90%91%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E9%A2%9C%E8%89%B2%E5%80%BC/","content":"题意给定一个有向图，以及图上各节点的颜色colors，若图有环返回-1；\n记路径颜色值为路径中出现次数最多的颜色的出现次数。\n求各合法路径的最大颜色值。\n思路首先假定图无环，该怎么求路径最大颜色值呢；\n若有一条路径可得最大颜色值，且存在一个不在该路径上的点可达该路径起点，显然将路径起点改为该点一定不劣。也就是说从各入度为0的点出发一定不劣，比较自然的可以想到使用拓扑排序。\n拓扑排序同时也可以解决判断有无环问题，由此可解。\n实现class Solution {static constexpr int N = 26;public:    int largestPathValue(string colors, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {        const int n = colors.size();        vector&lt;int&gt; d(n);        vector&lt;vector&lt;int&gt;&gt; e(n);        for (const auto&amp; vec : edges) {            e[vec.front()].push_back(vec.back());            d[vec.back()]++;        }        vector&lt;int&gt; q; int cur = 0;        for (int i = 0; i &lt; n; i++) {            if (d[i] == 0) q.push_back(i);        }        vector&lt;array&lt;int, N&gt;&gt; f(n);        int ans = 0;        for ( ; cur &lt; q.size(); cur++) {            int x = q[cur];            f[x][colors[x] - 'a']++;            ans = max(ans, f[x][colors[x] - 'a']);            for (const auto&amp; v : e[x]) {                for (int i = 0; i &lt; N; i++) {                    f[v][i] = max(f[v][i], f[x][i]);                }                d[v]--;                if (d[v] == 0) {                    q.push_back(v);                }            }        }        if (count(d.begin(), d.end(), 0) != n) return -1;        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2131-连接两字母单词得到的最长回文串","url":"/2025/05/25/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982131-%E8%BF%9E%E6%8E%A5%E4%B8%A4%E5%AD%97%E6%AF%8D%E5%8D%95%E8%AF%8D%E5%BE%97%E5%88%B0%E7%9A%84%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/","content":"题意给定由长度为2的字符串组成的字符串数组words，可任选并按任意顺序连接其中字符串，求所能组成最长回文串长度。\n思路给定一个回文串，显然往两边同时添加相反字符串是不会破坏回文性质的。\n所有可选字符串长度均为2，那首先考虑回文对称轴在不同字符串之间，显然是贪心的将相反的字符串不断添加到已有回文串左右；\n再考虑如果存在可选回文串即s[0] == s[1]，显然可以将其加入回文串的中间，使回文串对称轴位于该字符串中间。\n进行一个贪心模拟就好。\n实现class Solution {static constexpr int N = 26;public:    int longestPalindrome(vector&lt;string&gt;&amp; words) {        vector f(N, vector&lt;int&gt; (N));        int ans = 0;        for (const auto&amp; s : words) {            f[s.front() - 'a'][s.back() - 'a']++;        }        int t = 0;        for (int i = 0; i &lt; N; i++) {            for (int j = 0; j &lt; N; j++) {                if (i == j) {                    ans += (f[i][j] - (f[i][j] &amp; 1)) &lt;&lt; 1;                    if (f[i][j] &amp; 1) t = 2;                } else {                    ans += min(f[i][j], f[j][i]) &lt;&lt; 1;                }            }        }        return ans + t;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2942-查找包含给定字符的单词","url":"/2025/05/24/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982942-%E6%9F%A5%E6%89%BE%E5%8C%85%E5%90%AB%E7%BB%99%E5%AE%9A%E5%AD%97%E7%AC%A6%E7%9A%84%E5%8D%95%E8%AF%8D/","content":"题意给定字符串数组words与字符x，寻找所有含x的字符串下标\n思路进行一个暴力即可。\n实现class Solution {public:    vector&lt;int&gt; findWordsContaining(vector&lt;string&gt;&amp; words, char x) {        vector&lt;int&gt; ans;        for (int i = 0; i &lt; words.size(); i++) {            if (words[i].find(x) != string::npos) ans.push_back(i);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3068-最大节点价值之和","url":"/2025/05/23/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983068-%E6%9C%80%E5%A4%A7%E8%8A%82%E7%82%B9%E4%BB%B7%E5%80%BC%E4%B9%8B%E5%92%8C/","content":"题意给定一棵树及其结点权值nums与正整数k，每次操作可以任选一条边使其两端点权值异或k，可以进行任意次操作，求问最大权值和。\n思路比较自然是可以想到树形dp的，但是仔细一想异或的性质可以发现存在更加简单的写法：\n只要两点间存在路径，一定存在操作使得仅两点权值异或k而其余值不受影响，故而可以简单地为结点权值异或前后大小差排序进行贪心。\n实现class Solution {using ll = long long;public:    long long maximumValueSum(vector&lt;int&gt;&amp; nums, int k, vector&lt;vector&lt;int&gt;&gt;&amp; edges) {        const int n = nums.size();        ll ans = 0;        for (int i = 0; i &lt; n; i++) {            ans += nums[i];            nums[i] = (nums[i] ^ k) - nums[i];        }        ranges::sort(nums, greater());        for (int i = 1; i &lt; n; i += 2) {            if (nums[i] + nums[i - 1] &gt; 0) {                ans += nums[i] + nums[i - 1];            } else {                break;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3362-零数组变换 III","url":"/2025/05/22/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983362-%E9%9B%B6%E6%95%B0%E7%BB%84%E5%8F%98%E6%8D%A2-III/","content":"题意给定非负整数数组nums与二维操作数组queries，对于每次操作给出范围[l, r]，每次操作可任选构成下标子集，使得选中的nums[i]减1，求问最多可删除多少操作仍能将nums转换为零数组。\n思路删除操作好像不太好处理，那么可以考虑正难则反：最少选择多少操作可使得nums转换为零数组呢\n显然是可以满足贪心性质的，对于每个仍大于零的数，我们希望选择左端在其左而右端尽可能右的操作，那么可以使用优先队列维护满足条件的右端点，使用差分维护当前数值。\n实现class Solution {public:    int maxRemoval(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {        ranges::sort(queries, [&amp;](const auto&amp; x, const auto&amp; y) {            return x.front() &lt; y.front();        });        const int n = nums.size(), q = queries.size();        vector&lt;int&gt; f(n + 1);        priority_queue&lt;int&gt; pq;        int cnt = 0, cur = 0;        for (int i = 0; i &lt; n; i++) {            if (i) f[i] += f[i - 1];            while (cur &lt; q &amp;&amp; queries[cur].front() &lt;= i) {                pq.push(queries[cur++].back());            }            while (f[i] &lt; nums[i] &amp;&amp; !pq.empty()) {                int r = pq.top();                pq.pop();                if (r &lt; i) continue;                f[i]++;                f[r + 1]--;                cnt++;            }            if (f[i] &lt; nums[i]) return -1;        }        return q - cnt;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3356-零数组变换 II","url":"/2025/05/21/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983356-%E9%9B%B6%E6%95%B0%E7%BB%84%E5%8F%98%E6%8D%A2-II/","content":"题意给定非负整数数组nums与二维操作数组queries，对于每次操作给出范围[l, r, val]，每次操作可将[l, r]内的每个数独立地减[0, val]，求问若顺序地执行操作queries最少多少次操作可以使得nums变为零数组或判断不可能。\n思路二分可以发现当操作次数越多时越有可能将nums转变为零数组，那么求最小次数显然可以进行一个二分。直接使用昨日代码进行 check 即可。\n线段树若想在线的做这道题，显然需要的操作是不断进行区间减与区间最大值查询，那就自然地想到使用带懒标记的线段树。\n实现二分实现\nclass Solution {public:    int minZeroArray(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {        const int n = nums.size(), q = queries.size();        vector&lt;int&gt; f(n + 1);        auto check = [&amp;](int x) -&gt; bool {            fill(f.begin(), f.end(), 0);            for (int i = 0; i &lt; x; i++) {                f[queries[i][0]] += queries[i].back();                f[queries[i][1] + 1] -= queries[i].back();            }            for (int i = 0; i &lt; n; i++) {                if (i) f[i] += f[i - 1];                if (f[i] &lt; nums[i]) return false;            }            return true;        };        int lo = 0, hi = q + 1;        while (lo &lt; hi) {            int mid = lo + hi &gt;&gt; 1;            if (check(mid)) {                hi = mid;            } else {                lo = mid + 1;            }        }        return lo &gt; q ? -1 : lo;    }};\n\n线段树实现\ntemplate&lt;class Info, class Tag&gt;struct SegmentTree {    int n;    vector&lt;Info&gt; info;    vector&lt;Tag&gt; tag;    SegmentTree() : n(0) {}    SegmentTree(int n_, Info v_ = Info()) {        init(n_, v_);    }    template&lt;class T&gt;    SegmentTree(vector&lt;T&gt; init_) {        init(init_);    }    void init(int n_, Info v_ = Info()) {        init(vector&lt;Info&gt;(n_, v_));    }    template&lt;class T&gt;    void init(vector&lt;T&gt; init_) {        n = init_.size();        info.assign(4 &lt;&lt; __lg(n), Info());        tag.assign(4 &lt;&lt; __lg(n), Tag());        auto build = [&amp;](this auto&amp;&amp; self, int p, int l, int r) -&gt; void {            if (r - l == 1) {                info[p] = init_[l];                return;            }            int m = (l + r) / 2;            self(2 * p, l, m);            self(2 * p + 1, m, r);            pull(p);        };        build(1, 0, n);    }    void pull(int p) {        info[p] = info[2 * p] + info[2 * p + 1];    }    void apply(int p, const Tag &amp;v) {        info[p].apply(v);        tag[p].apply(v);    }    void push(int p) {        apply(2 * p, tag[p]);        apply(2 * p + 1, tag[p]);        tag[p] = Tag();    }    void set(int p, int l, int r, int x, const Info &amp;v) {        if (r - l == 1) {            info[p] = v;            return;        }        int m = (l + r) / 2;        push(p);        if (x &lt; m) {            set(2 * p, l, m, x, v);        } else {            set(2 * p + 1, m, r, x, v);        }        pull(p);    }    void set(int p, const Info &amp;v) {        set(1, 0, n, p, v);    }    Info query(int p, int l, int r, int x, int y) {        if (l &gt;= y || r &lt;= x) {            return Info();        }        if (l &gt;= x &amp;&amp; r &lt;= y) {            return info[p];        }        int m = (l + r) / 2;        push(p);        return query(2 * p, l, m, x, y) + query(2 * p + 1, m, r, x, y);    }    Info query(int l, int r) {        return query(1, 0, n, l, r);    }    void update(int p, int l, int r, int x, int y, const Tag &amp;v) {        if (l &gt;= y || r &lt;= x) {            return;        }        if (l &gt;= x &amp;&amp; r &lt;= y) {            apply(p, v);            return;        }        int m = (l + r) / 2;        push(p);        update(2 * p, l, m, x, y, v);        update(2 * p + 1, m, r, x, y, v);        pull(p);    }    void update(int l, int r, const Tag &amp;v) {        return update(1, 0, n, l, r, v);        }};struct Tag {    int add = 0;    void apply(Tag t) {        add += t.add;    }};struct Info {    int mi = 0;    void apply(Tag t) {        mi -= t.add;    }};Info operator+(const Info &amp;a, const Info &amp;b) {    if (a.mi &gt;= b.mi) {        return a;    } else {        return b;    }}using S = SegmentTree&lt;Info, Tag&gt;;class Solution {public:    int minZeroArray(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {        const int n = nums.size(), q = queries.size();        S StT(n);        for (int i = 0; i &lt; n; i++) {            StT.set(i, {nums[i]});        }        if (StT.query(0, n).mi &lt;= 0) return 0;        for (int i = 0; i &lt; q; i++) {            const auto&amp; vec = queries[i];            StT.update(vec[0], vec[1] + 1, {vec[2]});            if (StT.query(0, n).mi &lt;= 0) return i + 1;        }        return -1;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3355-零数组变换 I","url":"/2025/05/20/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983355-%E9%9B%B6%E6%95%B0%E7%BB%84%E5%8F%98%E6%8D%A2-I/","content":"题意给定非负整数数组nums与二维操作数组queries，对于每次操作给出范围[l, r]，每次操作可任选构成下标子集，使得选中的nums[i]减1，求问是否可使得nums转换为零数组。\n思路首先我们可以想到对于每个操作都贪心地对范围所有元素进行减一操作，若元素可减至小于等于0显然是可行的，只需减至0后不再选取其即可。\n那么什么情况是不合法的呢，显然是操作覆盖次数小于nums[i]的。\n对于区间加减，覆盖次数大小，可以自然的想到使用差分。\n实现class Solution {public:    bool isZeroArray(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; queries) {        const int n = nums.size();        vector&lt;int&gt; f(n + 1);        for (const auto&amp; vec : queries) {            f[vec.front()]++;            f[vec.back() + 1]--;        }        for (int i = 0; i &lt; n; i++) {            if (i) f[i] += f[i - 1];            if (f[i] &lt; nums[i]) return false;        }        return true;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3024-三角形类型","url":"/2025/05/19/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983024-%E4%B8%89%E8%A7%92%E5%BD%A2%E7%B1%BB%E5%9E%8B/","content":"题意给定三条边长度，判断其是否可构成三角形可构造成什么三角形。\n思路简单的数学判断，if-else一下就好。\n实现class Solution {public:    string triangleType(vector&lt;int&gt;&amp; nums) {        ranges::sort(nums);        if (nums[0] + nums[1] &lt;= nums.back()) return \"none\";        if (nums.front() == nums.back()) return \"equilateral\";        if (nums.front() == nums[1] || nums[1] == nums.back()) return \"isosceles\";        return \"scalene\";    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1931-用三种不同颜色为网格涂色","url":"/2025/05/18/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981931-%E7%94%A8%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E9%A2%9C%E8%89%B2%E4%B8%BA%E7%BD%91%E6%A0%BC%E6%B6%82%E8%89%B2/","content":"题意给定m  *  n的网格，使用三种不同的颜色进行涂色，要求无相邻的网格颜色相同，求合法涂色的方案数。\n思路注意到m的范围是比较小的而，可以考虑一次填一列的色，那么每次填色的方案数显然是的。\n可以通过预处理得到所有合法同时填一列颜色的方案，并得出哪些方案是不可以相邻的，问题就转换为了经典的一维填色方案数，使用dp即可。\n实现class Solution {static constexpr int mod = 1e9 + 7;using ll = long long;public:    int colorTheGrid(int m, int n) {        int pm = 1;        for (int i = 0; i &lt; m; i++) pm *= 3;        vector&lt;int&gt; a;        for (int i = 0; i &lt; pm; i++) {            bool ok = true;            for (int j = 0, last = -1, x = i; j &lt; m; j++) {                if (last == x % 3) {                    ok = false;                    break;                }                last = x % 3;                x /= 3;            }            if (ok) a.push_back(i);        }        const int an = a.size();        vector&lt;vector&lt;int&gt;&gt; adj(an);        for (int i = 0; i &lt; an; i++) {            for (int j = i + 1; j &lt; an; j++) {                bool ok = true;                for (int k = 0, x = a[i], y = a[j]; k &lt; m; k++) {                    if (x % 3 == y % 3) {                        ok = false;                        break;                    }                    x /= 3; y /= 3;                }                if (ok) {                    adj[i].push_back(j);                    adj[j].push_back(i);                }            }        }        vector f(an, vector&lt;int&gt; (n));        for (int i = 0; i &lt; an; i++) f[i][0]++;        for (int i = 1; i &lt; n; i++) {            for (int j = 0; j &lt; an; j++) {                for (const auto&amp; v : adj[j]) {                    f[j][i] += f[v][i - 1];                    if (f[j][i] &gt;= mod) f[j][i] -= mod;                }            }        }        ll ans = 0;        for (int i = 0; i &lt; an; i++) ans += f[i].back();        return ans % mod;    }};\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题75-颜色分类","url":"/2025/05/17/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%9875-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB/","content":"题意给定数组nums表示小球序列，其中红白蓝球分别用0、1、2表示，希望使用原地排序使小球按红白蓝顺序摆放。\n思路原地排序，有且仅有3种不同元素，那么维护中间元素即1区间的左右端点枚举一下即可。\n实现class Solution {public:    void sortColors(vector&lt;int&gt;&amp; nums) {        int p1 = 0, p2 = 0;        for (int i = 0; i &lt; nums.size(); i++) {            if (nums[i] == 1) {                swap(nums[i], nums[p2++]);            } else if (nums[i] == 0) {                swap(nums[i], nums[p1]);                if (p1 &lt; p2) {                    swap(nums[i], nums[p2]);                }                p1++;                p2++;            }        }    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2901-最长相邻不相等子序列 II","url":"/2025/05/16/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982901-%E6%9C%80%E9%95%BF%E7%9B%B8%E9%82%BB%E4%B8%8D%E7%9B%B8%E7%AD%89%E5%AD%90%E5%BA%8F%E5%88%97-II/","content":"题意给定等长的字符串数组words与整数数组groups；\n求任意最长递增序列I满足以下条件：\n\ngroups[I[i]] != groups[I[i + 1]]\nwords[I[i]]与words[I[i + 1]]的汉明距离为1\n\n返回word[I]\n思路数组的长度范围并不大，最大仅有\n因此其实怎么写基本都是可以的，进行一个的dp即可\n实现class Solution {public:    vector&lt;string&gt; getWordsInLongestSubsequence(vector&lt;string&gt;&amp; words, vector&lt;int&gt;&amp; groups) {        auto check = [](const string&amp; x, const string&amp; y) -&gt; bool {            if (x.size() != y.size()) return false;            int dif = 0;            for (int i = 0; i &lt; x.size(); i++) {                if (x[i] != y[i]) dif++;            }            return dif == 1;        };        const int n = words.size();        vector&lt;int&gt; len(n, 1), from(n, -1);        int mxloc = 0;        for (int i = n - 1; i &gt;= 0; i--) {            for (int j = i + 1; j &lt; n; j++) {                if (len[i] &lt;= len[j] &amp;&amp; groups[i] != groups[j] &amp;&amp; check(words[i], words[j])) {                    len[i] = len[j] + 1;                    from[i] = j;                }            }            if (len[i] &gt; len[mxloc]) mxloc = i;        }        vector&lt;string&gt; ans;        for (int i = mxloc; i != -1; i = from[i]) {            ans.push_back(words[i]);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2900最长相邻不相等子序列 I","url":"/2025/05/15/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982900%E6%9C%80%E9%95%BF%E7%9B%B8%E9%82%BB%E4%B8%8D%E7%9B%B8%E7%AD%89%E5%AD%90%E5%BA%8F%E5%88%97-I/","content":"题意给定等长的字符串数组words与二进制数组groups；\n求任意最长递增序列I满足groups[I[i]] != groups[I[i + 1]]返回word[I]\n思路显然满足贪心性质，进行一趟遍历即可。\n实现class Solution {public:    vector&lt;string&gt; getLongestSubsequence(vector&lt;string&gt;&amp; words, vector&lt;int&gt;&amp; groups) {        vector&lt;string&gt; ans;        const int n = groups.size();        for (int i = 0, cur = -1; i &lt; n; i++) {            if (cur != groups[i]) {                cur = groups[i];                ans.push_back(words[i]);            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3337-字符串转换后的长度 II","url":"/2025/05/14/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983337-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E9%95%BF%E5%BA%A6-II/","content":"题意给定小写字符串s与变换次数t以及长度为26的变换规则nums\n每次比那换为将s[i]变换为字母表中后续的nums[s[i] - 'a']各连续字符，如若有nums[0] = 2; nums[25] = 3则有：\na -&gt; bc\nz -&gt; abc\n求t次变换后s 的长度\n思路注意到此题为昨日题目的升级版，区别在于变换规则不定且t最大可为1e9\n我们且先不考虑完整的26个字母，考虑下仅有abc三个字符互相变换的情况，记与分别为某次变换前后a的的数量\n我们设变换规则为\na -&gt; bcb -&gt; ac -&gt; ac\n\n那么显然有\n\n\n​\n不难将其转换为矩阵乘法的形式：那么聪明的你显然不难发现，t次变换不过如下：那么显然可以使用快速幂的知识将这个运算进行优化。\n同时也不难将这个计算方法推广到26个字母与给定的任意变换规则。\n实现class Solution {static constexpr int mod = 1e9 + 7;static constexpr int sz = 26;using ll = long long;using Matrix = array&lt;array&lt;int, sz&gt;, sz&gt;;Matrix mul(const Matrix&amp; x, const Matrix&amp; y) {    Matrix res;    for (auto&amp; arr : res) arr.fill(0);    for (int i = 0; i &lt; sz; i++) {        for (int j = 0; j &lt; sz; j++) {            if (x[i][j] == 0) continue;            for (int k = 0; k &lt; sz; k++) {                res[i][k] = (res[i][k] + 1ll * x[i][j] * y[j][k]) % mod;            }        }    }    return res;}Matrix powMod(Matrix a, int b) {    Matrix res;    for (int i = 0; i &lt; sz; i++) {        res[i].fill(0);        res[i][i] = 1;    }    while (b) {        if (b &amp; 1) {            res = mul(res, a);        }        a = mul(a, a);        b &gt;&gt;= 1;    }    return res;}public:    int lengthAfterTransformations(string s, int t, vector&lt;int&gt;&amp; nums) {        Matrix m;        for (auto&amp; arr : m) arr.fill(0);        for (int i = 0; i &lt; sz; i++) {            for (int j = 1; j &lt;= nums[i]; j++) {                m[(i + j) % sz][i]++;            }        }        Matrix mt = powMod(m, t);        array&lt;int, sz&gt; cnt;        cnt.fill(0);        for (const auto&amp; ch : s) cnt[ch - 'a']++;        int ans = 0;        for (int i = 0; i &lt; sz; i++) {            ll res = 0;            for (int j = 0; j &lt; sz; j++) {                res += 1ll * mt[i][j] * cnt[j];            }            ans = (ans + res) % mod;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","矩阵快速幂"]},{"title":"力扣每日一题3335-字符串转换后的长度 I","url":"/2025/05/13/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983335-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E9%95%BF%E5%BA%A6-I/","content":"题意给定小写字符串s与变换次数t，每次变换会使s中各字符发生如下变化:\na -&gt; b\nb -&gt; c\n…\n唯有z特殊\nz -&gt; ab\n求解t次变换之后字符串s的最终长度。\n思路我们仅关心字符串的最终长度而不关心其最终形态，且相同字符的变换是相同的，故可以简单的开个数组对各个字符的数量进行模拟计算。\n同时本题是数据削弱版  故而可以直接模拟即可。\n若数据范围较大，可以将操作转换为矩阵乘法，采用矩阵快速幂即可。\n实现class Solution {static constexpr int mod = 1e9 + 7;public:    int lengthAfterTransformations(string s, int t) {        array&lt;int, 26&gt; f;        f.fill(0);        for (const auto&amp; ch : s) {            f[ch - 'a']++;        }        for (int i = 0; i &lt; t; i++) {            int x = f.back();            for (int i = 25; i &gt; 0; i--) {                f[i] = f[i - 1];            }            f[0] = x;            f[1] = f[1] + x;            if (f[1] &gt;= mod) f[1] -= mod;        }        return accumulate(f.begin(), f.end(), 0ll) % mod;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2094-找出 3 位偶数","url":"/2025/05/12/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982094-%E6%89%BE%E5%87%BA-3-%E4%BD%8D%E5%81%B6%E6%95%B0/","content":"题意给定个位数数组digits，可从中任选3个数，按任意顺序排序并组成一个三位数，求所有满足以下条件的不同整数\n\n无前导零\n为偶数\n\n思路三位偶数的个数并不多，可以考虑枚举三位偶数，再判断给出的digits是否可以拼出该数即可。\n实现class Solution {public:    vector&lt;int&gt; findEvenNumbers(vector&lt;int&gt;&amp; digits) {        array&lt;int, 10&gt; cnt;        cnt.fill(0);        for (const auto&amp; x : digits) {            cnt[x]++;        }        auto check = [&amp;](int x) -&gt; bool {            array&lt;int, 3&gt; t;            bool res = true;            for (int i = 0; i &lt; 3; i++) {                t[i] = x % 10;                x /= 10;                res &amp;= (--cnt[t[i]] &gt;= 0);            }            for (int i = 0; i &lt; 3; i++) cnt[t[i]]++;            return res;        };        vector&lt;int&gt; ans;        for (int i = 100; i &lt; 1000; i += 2) {            if (check(i)) ans.push_back(i);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1550-存在连续三个奇数的数组","url":"/2025/05/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981550-%E5%AD%98%E5%9C%A8%E8%BF%9E%E7%BB%AD%E4%B8%89%E4%B8%AA%E5%A5%87%E6%95%B0%E7%9A%84%E6%95%B0%E7%BB%84/","content":"题意给定数组arr，判断其内是否包含连续三个奇数。\n思路比较简单，遍历一遍判断一下就好。\n实现class Solution {public:    bool threeConsecutiveOdds(vector&lt;int&gt;&amp; arr) {        const int n = arr.size();        for (int i = 1; i &lt; n - 1; i++) {            if (!(arr[i] &amp; 1)) continue;            if (arr[i - 1] &amp; arr[i + 1] &amp; 1) return true;        }        return false;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2918-数组的最小相等和","url":"/2025/05/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982918-%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E7%9B%B8%E7%AD%89%E5%92%8C/","content":"题意给定两由非负整数组成的数组nums1与nums2\n必须将两数组中的所有0替换为正整数，且使得两数组之和相同。\n求最小相等和，或表明其无法实现。\n思路可以发现当两个数组均有0时是一定可以实现的，最小和应贪心地使所有0替换为1取较大数组和；\n若均无0则简单比较两数组和即可；\n若仅有某一数组含0，且0均转换为最小正整数1后含0数组和仍大于另一数组则无解。\n实现class Solution {using ll = long long;public:    long long minSum(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        ll sum1 = 0, sum2 = 0;        int cnt1 = 0, cnt2 = 0;        for (const auto&amp; x : nums1) {            sum1 += x;            if (x == 0) cnt1++;        }        for (const auto&amp; x : nums2) {            sum2 += x;            if (x == 0) cnt2++;        }        if ((cnt1 == 0 &amp;&amp; sum2 + cnt2 &gt; sum1) || (cnt2 == 0 &amp;&amp; sum1 + cnt1 &gt; sum2)) return -1;        return max(sum1 + cnt1, sum2 + cnt2);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3343-统计平衡排列的数目","url":"/2025/05/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983343-%E7%BB%9F%E8%AE%A1%E5%B9%B3%E8%A1%A1%E6%8E%92%E5%88%97%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意若一个数字字符串奇数位和与偶数位和相同，则称其平衡。\n给定一数字字符串num，求其有多少种排列平衡。\n答案mod 1e9 + 7， 2 &lt;= num.size() &lt;= 80\n思路记有n个数，和为sum，数位为i的个数有\n显然奇数位与偶数位分别有与个\n要使得奇数位和与偶数位和相等即将n个数分为大小为与的两个和为的集合，再对集合进行排序\n记数位为i的数有个放进了第一个集合，则另一个集合有个数位为i的数放进来第二个集合\n假定每个数均不同则共有种排列方式\n再考虑去掉数位相同造成的重复排列有\n那么有几种划分集合的方法呢，比较自然可以想到dp(以前感觉这种话就是懒得详写，轮到自己写了发现真的是\n记为待划分的数为i，第一个集合还缺j个数，第一个集合的和还差k有\n\n显然有递推式\n其中t表示数i有t个填到集合一，剩余填到集合二\n\n接着进行一个dp计数即可。\n实现using ll = long long;constexpr int mod = 1e9 + 7;constexpr int mx = 40;ll powMod(ll a, ll b) {    ll res = 1;    while (b) {        if (b &amp; 1) {            res = res * a % mod;        }        a = a * a % mod;        b &gt;&gt;= 1;    }    return res;}ll fac[mx + 1], nfac[mx + 1];auto init = []() -&gt; int {    fac[0] = 1;    for (int i = 1; i &lt;= mx; i++) {        fac[i] = fac[i - 1] * i % mod;    }    nfac[mx] = powMod(fac[mx], mod - 2);    for (int i = mx - 1; i &gt;= 0; i--) {        nfac[i] = nfac[i + 1] * (i + 1) % mod;    }    return 0;} ();class Solution {public:    int countBalancedPermutations(string num) {        array&lt;int, 10&gt; cnt;        cnt.fill(0);        int sum = 0;        for (const auto&amp; ch : num) {            cnt[ch - '0']++;            sum += ch - '0';        }        if (sum &amp; 1) return 0;        const int n = num.size();        const int t = n / 2, tot = sum / 2;        vector dp(t + 1, vector&lt;ll&gt; (tot + 1));        dp[t][tot] = 1;        for (int i = 0; i &lt; 10; i++) {            vector ndp(t + 1, vector&lt;ll&gt; (tot + 1));            for (int j = 0; j &lt;= t; j++) {                for (int k = 0; k &lt;= tot; k++) {                    int tmx = min({j, cnt[i], i &gt; 0 ? (k / i) : cnt[i]});                    for (int x = 0; x &lt;= tmx; x++) {                        if (cnt[i] - x &gt; mx) continue;                        ndp[j - x][k - x * i] += dp[j][k] * nfac[x] % mod * nfac[cnt[i] - x] % mod;                        ndp[j - x][k - x * i] %= mod;                    }                }            }            swap(dp, ndp);        }        return dp[0][0] * fac[t] % mod * fac[n - t] % mod;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","dp"]},{"title":"力扣每日一题3342-到达最后一个房间的最少时间 II","url":"/2025/05/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983342-%E5%88%B0%E8%BE%BE%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%88%BF%E9%97%B4%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4-II/","content":"题意给定n * m的方格，格子(i, j)必须在时刻moveTime[i][j]之后才可往其移动，第奇数次移动耗时1第偶数次移动耗时2，初始处于时刻0与左上角(0, 0)，求解到达右下角(n - 1, m - 1)的最早时刻。\n思路就是昨日题目的变种，移动耗时不再固定为1而是与当前移动次数的奇偶性有关。\n那还是比较经典的最短路问题，比较朴素的思想是额外增加一个变量用以记录当前移动的次数。\n稍加观察可以注意到，初始位于(0, 0)则移动到(i, j)所需步数奇偶性一定是与i + j相同的，即记当前步数为t一定有：\n\n实现class Solution {static constexpr array&lt;int, 2&gt; nxt[] = {    {1, 0}, {-1, 0}, {0, 1}, {0, -1}};public:    int minTimeToReach(vector&lt;vector&lt;int&gt;&gt;&amp; moveTime) {        const int n = moveTime.size(), m = moveTime.back().size();        const int e = n * m - 1;        auto cal1 = [&amp;](int x, int y) -&gt; int {            return x * m + y;        };        auto cal2 = [&amp;](int x) -&gt; pair&lt;int, int&gt; {            return {x / m, x % m};        };        auto across = [&amp;](int x, int y) -&gt; bool {            return x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m;        };        vector&lt;bool&gt; vis(n * m);        priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;&gt;&gt; pq;        pq.push({0, 0});        while (!pq.empty()) {            auto [c, t] = pq.top();            pq.pop();            if (vis[t]) continue;            if (t == e) return c;            vis[t] = true;            auto [x, y] = cal2(t);            for (auto [tx, ty] : nxt) {                int nx = tx + x, ny = ty + y;                if (across(nx, ny)) continue;                int nt = cal1(nx, ny);                pq.push({max(c, moveTime[nx][ny]) + 1 + ((x + y) &amp; 1), nt});            }        }        return -1;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3341-到达最后一个房间的最少时间 I","url":"/2025/05/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983341-%E5%88%B0%E8%BE%BE%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E6%88%BF%E9%97%B4%E7%9A%84%E6%9C%80%E5%B0%91%E6%97%B6%E9%97%B4-I/","content":"题意给定n * m的方格，格子(i, j)必须在时刻moveTime[i][j]之后才可往其移动，每次移动耗时1，初始处于时刻0与左上角(0, 0)，求解到达右下角(n - 1, m - 1)的最早时刻。\n思路比较经典的最短路题，只需把当前时刻t与目的方格最小时刻moveTime[i][j]取max加一即max(t, moveTime[i][j]) + 1作为边权然后跑一下迪杰斯特拉即可。\n实现class Solution {using ll = long long;static constexpr array&lt;int, 2&gt; nxt[] = {    {1, 0}, {-1, 0}, {0, 1}, {0, -1}};public:    int minTimeToReach(vector&lt;vector&lt;int&gt;&gt;&amp; moveTime) {        const int n = moveTime.size(), m = moveTime.back().size();        const int e = n * m - 1;        auto cal1 = [&amp;](int x, int y) -&gt; int {            return x * m + y;        };        auto cal2 = [&amp;](int x) -&gt; pair&lt;int, int&gt; {            return {x / m, x % m};        };        auto across = [&amp;](int x, int y) -&gt; bool {            return x &lt; 0 || x &gt;= n || y &lt; 0 || y &gt;= m;        };        vector&lt;bool&gt; vis(n * m);        priority_queue&lt;pair&lt;ll, int&gt;, vector&lt;pair&lt;ll, int&gt;&gt;, greater&lt;&gt;&gt; pq;        pq.push({0, 0});        while (!pq.empty()) {            auto [c, t] = pq.top();            pq.pop();            if (vis[t]) continue;            if (t == e) return c;            vis[t] = true;            auto [x, y] = cal2(t);            for (auto [tx, ty] : nxt) {                int nx = tx + x, ny = ty + y;                if (across(nx, ny)) continue;                int nt = cal1(nx, ny);                pq.push({max(c, 1ll * moveTime[nx][ny]) + 1, nt});            }        }        return -1;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1920-基于排列构建数组","url":"/2025/05/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981920-%E5%9F%BA%E4%BA%8E%E6%8E%92%E5%88%97%E6%9E%84%E5%BB%BA%E6%95%B0%E7%BB%84/","content":"题意给定排列nums，希望返回满足以下条件的ans\nans[i] = nums[nums[i]], 0 &lt;= i &lt; nums.size()\n思路开个ans简单地遍历一遍模拟一下即可，空间复杂度为O(n)，没什么难度\n进阶：是否可以用O(1)的空间复杂度解决问题呢\n如此只能是在nums上原地操作变换，即令nums[i] = nums[nums[i]]\n但显然是不可以直接这么做的，因为直接替换nums[i]可能会影响后续的其他操作结果\n但由于nums为排列即无重复数，可以注意到nums[i]与要替换nums[i]的nums[nums[i]]、nums[nums[i]]与要替换nums[nums[i]]的nums[nums[nums[i]]]…等等是必定会形成一个环的\n即nums变换前后其实是由多个环组成的\n那么仅需考虑同时操作变换同一个环内的数字，并记录标记哪些数操作过即可。\n实现简单实现\nclass Solution {public:    vector&lt;int&gt; buildArray(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        vector&lt;int&gt; ans(n);        for (int i = 0; i &lt; n; i++) {            ans[i] = nums[nums[i]];        }        return ans;    }};\n\n空间O(1)实现\nclass Solution {public:    vector&lt;int&gt; buildArray(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        for (int i = 0; i &lt; n; i++) {            if (nums[i] &lt; 0) continue;            int x = nums[i], cur = i;            while (nums[cur] != i) {                int nxt = nums[cur];                nums[cur] = ~nums[nxt];                cur = nxt;            }            nums[cur] = ~x;        }        for (int i = 0; i &lt; n; i++) {            nums[i] = ~nums[i];        }        return nums;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题790-多米诺和托米诺平铺","url":"/2025/05/05/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98790-%E5%A4%9A%E7%B1%B3%E8%AF%BA%E5%92%8C%E6%89%98%E7%B1%B3%E8%AF%BA%E5%B9%B3%E9%93%BA/","content":"题意有两种瓷砖，形如：\n种类1..种类2...\n\n两种瓷砖均可以任意旋转，求一个2 * n的的面板可以有几种不同的铺法。\n思路一个很经典的dp问题，为方便讨论，记以下称呼\n平：..上凸：...下凸：...\n\n记\n第i列为平有几种铺法\n​为第i列为上凸有几种铺法\n为第i列为下凸有几种铺法\n显然有：具体原因可以简单手绘得出，故不过多赘述。\n仅需注意边界、溢出问题即可。\n实现class Solution {static constexpr int mod = 1e9 + 7;public:    int numTilings(int n) {        vector&lt;int&gt; f(n + 1), g(n + 1), h(n + 1);        f[0] = 1;        for (int i = 1; i &lt;= n; i++) {            f[i] = (1ll * f[i - 1] + g[i - 1] + h[i - 1]) % mod;            if (i &gt; 1) {                f[i] = (f[i] + f[i - 2]) % mod;                g[i] = (f[i - 2] + h[i - 1]) % mod;                h[i] = (f[i - 2] + g[i - 1]) % mod;            }        }        return f[n];    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"部分条件下幂次的期望可以转换为元组个数","url":"/2025/05/04/%E9%83%A8%E5%88%86%E6%9D%A1%E4%BB%B6%E4%B8%8B%E5%B9%82%E6%AC%A1%E7%9A%84%E6%9C%9F%E6%9C%9B%E5%8F%AF%E4%BB%A5%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%85%83%E7%BB%84%E4%B8%AA%E6%95%B0/","content":"结论\n抛n次硬币，记x为正面朝上次数，求x的k次幂的期望\n有m张不同的牌，随机洗牌并取牌顶，重复n次，记x为取到某特定牌的次数，求x的k次幂的期望\n\n形如以上，满足以下条件的问题：\n\n随机变量是指标函数之和\n每个指标函数有明确定义的期望，最好互相独立\n允许多重元组并考虑重复时的概率\n\n可以将问题转换为求k元组的个数。\n思路以有m张不同的牌，随机洗牌并取牌顶，重复n次，记x为取到某特定牌的次数，求x的k次幂的期望为例子：\n记  为指示函数，表示第i次洗牌是否为好，其中  ：\n\n 表示该次洗牌所需特定牌在牌顶\n 表示其他情况\n\n那么可以将x表示为\n\n所求期望转换为  \n将其展开\n\n故而有\n\n每一个    元组   ，我们关心的是这  个编号是否都是好编号，故可以认为：\n\n每个元组贡献的期望值为这组编号全是好编号的概率\n把所有可能的元组的概率加起来，就等于 ​\n\n而k元组个数可以通过dp简单求得\n简单例子有2张牌，抽取3次，求的期望\n设  是每次洗牌是否为“好”的指示变量：  \n展开\n\n转换为元组考虑\n考虑所有  的 2 元组，共  个：\n\n\n\n元组\n\n\n\n\n(1,1)\n\n\n\n(1,2), (2,1)\n\n\n\n(1,3), (3,1)\n\n\n\n(2,2)\n\n\n\n(2,3), (3,2)\n\n\n\n(3,3)\n\n\n\n其他写CF1278F时学到的新东西，觉得好神奇又好像有点典，故而记录\nCF1278F\n","categories":["学习笔记"],"tags":["dp","概率论"]},{"title":"力扣每日一题1128-等价多米诺骨牌对的数量","url":"/2025/05/04/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981128-%E7%AD%89%E4%BB%B7%E5%A4%9A%E7%B1%B3%E8%AF%BA%E9%AA%A8%E7%89%8C%E5%AF%B9%E7%9A%84%E6%95%B0%E9%87%8F/","content":"题意给一组多米诺骨牌，每张牌上有两个数，可以任意次旋转使某张牌上数顺序交换，求相同牌的对数。\n思路可以任意次改变某牌上数的顺序，即牌上数顺序无关紧要，判断时令较小数在前或在后统一标准即可。\n遍历一趟使用哈希记录各个牌型数量即可。\n实现class Solution {public:    int numEquivDominoPairs(vector&lt;vector&lt;int&gt;&gt;&amp; dominoes) {        array&lt;int, 100&gt; cnt;        cnt.fill(0);        int ans = 0;        for (const auto&amp; vec : dominoes) {            int t = min(vec[0], vec[1]) * 10 + max(vec[0], vec[1]);            ans += cnt[t];            cnt[t]++;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1007-行相等的最少多米诺旋转","url":"/2025/05/03/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981007-%E8%A1%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E6%9C%80%E5%B0%91%E5%A4%9A%E7%B1%B3%E8%AF%BA%E6%97%8B%E8%BD%AC/","content":"题意有一排可分上下部分的多米诺骨牌，每张牌上下部分均分别写着[1, 6]的数字，每次操作可使得某张牌上下颠倒，求使得上部/下部所有数字相同的最小操作次数或判断其不可能。\n思路注意到牌上数字的范围很小，可以考虑直接枚举是哪个数可以满足条件及最小操作次数；但这样常数，呃也不算大但不够优，可以再考虑开个数组记录各个数字出现次数及使其在上部或下部满足同排均相同的操作次数，如此遍历一趟即可。\n没什么特别需要注意的地方。\n实现class Solution {public:    int minDominoRotations(vector&lt;int&gt;&amp; tops, vector&lt;int&gt;&amp; bottoms) {        array&lt;int, 7&gt; num, tcnt, bcnt;        num.fill(0); tcnt.fill(0); bcnt.fill(0);        const int n = tops.size();        for (int i = 0; i &lt; n; i++) {            if (tops[i] == bottoms[i]) {                num[tops[i]]++;            } else {                num[tops[i]]++;                num[bottoms[i]]++;                tcnt[bottoms[i]]++;                bcnt[tops[i]]++;            }        }        int mn = n;        for (int i = 1; i &lt; 7; i++) {            if (num[i] == n) mn = min({mn, tcnt[i], bcnt[i]});        }        return mn == n ? -1 : mn;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题838-推多米诺","url":"/2025/05/02/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98838-%E6%8E%A8%E5%A4%9A%E7%B1%B3%E8%AF%BA/","content":"题意给出字符串dominoes表示第0时刻排成一排的多米诺骨牌，其中：\n\ndominoes[i] = 'L'表示初始时该牌向左倒\ndominoes[i] = 'R'表示初始时刻该牌向右倒\ndominoes[i] = '.'表示初始时刻该牌直立\n\n每过一秒倒下的牌会使其倒下方向的下一张牌向同方向倒下（若下一张牌未倒下）；但若一张未倒下的牌同时收到左右两边相反方向的影响，其不会倒下。\n求问给定牌的最终情况。\n思路比较简单的模拟题，第一想法是开个数组time记录其受到左右影响的时刻，哪个小往哪边倒，从左到右再从右到左模拟两趟即可。\n但再观察一下发现，一片连续的未倒牌，其最终状态只受其两侧两个牌的状态影响：\n\nL...L-&gt;LLLLL\nL...R-&gt;L...R\nR...R-&gt;RRRRR\nR...L-&gt;RR.LL\n\n那只需遍历一趟找到连续未倒牌，比较其左右两侧牌的状态即可。\n实现记录比较时间模拟：\nclass Solution {public:    string pushDominoes(string dominoes) {        const int n = dominoes.size();        vector&lt;int&gt; time(n);        for (int i = 0, t = 0; i &lt; n; i++) {            if (dominoes[i] == 'R') {                t = 1;            } else if (dominoes[i] == '.') {                if (t &gt; 0) {                    time[i] = t++;                }            } else {                t = 0;            }        }        for (int i = n - 1, t = 0; i &gt;= 0; i--) {            if (dominoes[i] == 'R') {                t = 0;            } else if (dominoes[i] == 'L') {                t = 1;            } else {                if (t == 0) {                    if (time[i]) dominoes[i] = 'R';                    continue;                }                if (time[i] == 0) {                    dominoes[i] = 'L';                    t++;                } else {                    if (time[i] == t) {                        t = 0;                    } else if (time[i] &gt; t) {                        dominoes[i] = 'L';                        t++;                    } else {                        dominoes[i] = 'R';                        t = 0;                    }                }            }        }        return dominoes;    }};\n\n\n\n比较未倒牌左右：\nclass Solution {public:    string pushDominoes(string dominoes) {        const int n = dominoes.size();        for (int i = 0; i &lt; n; i++) {            if (dominoes[i] != '.') continue;            int j = i + 1;            for ( ; j &lt; n &amp;&amp; dominoes[j] == '.'; j++);            if (i == 0 &amp;&amp; j == n) continue;            else if (i == 0 &amp;&amp; dominoes[j] == 'L') {                for ( ; i &lt; j; i++) dominoes[i] = 'L';            } else if (j == n &amp;&amp; dominoes[i - 1] == 'R') {                for ( ; i &lt; j; i++) dominoes[i] = 'R';            } else if (i != 0 &amp;&amp; j != n) {                if (dominoes[i - 1] == dominoes[j]) {                    for ( ; i &lt; j; i++) dominoes[i] = dominoes[j];                } else if (dominoes[i - 1] == 'R' &amp;&amp; dominoes[j] == 'L') {                    int m1 = i + j + 1 &gt;&gt; 1, m2 = i + j &gt;&gt; 1;                    for ( ; i &lt; m2; i++) dominoes[i] = 'R';                    for (i = m1; i &lt; j; i++) dominoes[i] = 'L';                }            }            i = j;        }        return dominoes;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2071-你可以安排的最多任务数目","url":"/2025/05/01/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982071-%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%AE%89%E6%8E%92%E7%9A%84%E6%9C%80%E5%A4%9A%E4%BB%BB%E5%8A%A1%E6%95%B0%E7%9B%AE/","content":"题意给定n个任务m名工人，第i个任务完成需要力量tasks[i]，第j名工人力量为workers[j]；同时拥有pills个药丸，每个药丸可使一个工人力量提高strengh；每个工人最多可以完成一个任务使用一个药丸，求最多可以完成多少任务。\n思路我们首先考虑在不使用药丸的前提下，若需完成任意x个任务，是否可以完成。\n显然应当选出前x小的任务与前x大的工人，若能一一对应完成即可。\n那应当对workers与tasks进行排序，取出x个任务与工人，贪心地使最小的工人与最小的任务匹配。\n如果加入k个药丸的条件呢？是否可以完成任意x个任务如何判断\n那么一个工人所能完成的任务应该是一个区间[workers[i], workers[i] + strengh]，如果不使用药丸，该工人应该依旧选择与所能完成的最小任务匹配；如果使用药丸，贪心地应该选择能完成的最大任务匹配，使得药丸发挥最大作用，这个是基于直觉的guess，需要证明应该也不难。\n如果可以考虑明白上面的事，那么你已经知道如何check给定的任务数x了！接下来就可以进行一个二分查找得到答案。\n实现class Solution {public:    int maxTaskAssign(vector&lt;int&gt;&amp; tasks, vector&lt;int&gt;&amp; workers, int pills, int strength) {        ranges::sort(tasks);        ranges::sort(workers);        const int n = tasks.size(), m = workers.size();        auto check = [&amp;](int x) -&gt; bool {            int cnt = 0, cur = 0;            deque&lt;int&gt; q;            for (int i = m - x; i &lt; m; i++) {                for ( ; cur &lt; n &amp;&amp; tasks[cur] &lt;= workers[i] + strength; cur++) {                    q.push_back(tasks[cur]);                }                if (q.empty()) return false;                if (q.front() &lt;= workers[i]) {                    q.pop_front();                    continue;                }                if (cnt &gt;= pills) return false;                cnt++;                q.pop_back();            }            return true;        };        int lo = 0, hi = min(n, m);        while (lo &lt; hi) {            int mid = lo + hi + 1 &gt;&gt; 1;            if (check(mid)) {                lo = mid;            } else {                hi = mid - 1;            }        }        return lo;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1295-统计位数为偶数的数字","url":"/2025/04/30/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981295-%E7%BB%9F%E8%AE%A1%E4%BD%8D%E6%95%B0%E4%B8%BA%E5%81%B6%E6%95%B0%E7%9A%84%E6%95%B0%E5%AD%97/","content":"题意给定数组nums，求nums中数位个数为偶数的数的个数。\n思路直接遍历nums求每个数的位数即可。\n实现class Solution {public:    int findNumbers(vector&lt;int&gt;&amp; nums) {        int ans = 0;        for (const auto&amp; x : nums) {            ans += (to_string(x).size() &amp; 1) == 0;        }        return ans;    }};\n\n其他也是顺利拿下2025-04的力扣全勤了，也是结束了写博客的第一个月。\n做下来后感觉其实也没什么特别难的题，琢磨琢磨、看看别人题解琢磨琢磨总是能做出来的；以及感觉这个月好多都是给定数组求满足条件的子区间个数，有点写闷了。\n以前看别人题解，总是嫌别人写得太简单跳步太多，后来轮到自己写，会犯懒不想写得太详细，会有我都会了大家应该也会的想法；这确实是不太好的，但我有点把握不好啰嗦和详细清晰的度，也有点平衡不好花费的时间与详实程度。争取在未来的博客中得到改进吧。\n目前为止，我的博客还是没什么人看的，虽然主要原因是我还没买域名也没配置可以在搜索引擎检索到更没和多少人讲；博客配置也还存在些问题，比如多行Latex公式还是会挤在一起，图片还贴不上，争取下个月折腾完善一下吧。\n然后好像就没什么特别的感想了，五一将至，祝大家节日快乐假期愉快，love。\n文末是当前博客访问人数与四月徽章留作纪念，至于贴图问题，应该可能大概2025-05可以解决吧。（报告，贴图问题已于2025-05-03解决）\n\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2962-统计最大元素出现至少 K 次的子数组","url":"/2025/04/29/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982962-%E7%BB%9F%E8%AE%A1%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E5%87%BA%E7%8E%B0%E8%87%B3%E5%B0%91-K-%E6%AC%A1%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/","content":"题意给定数组nums与定值k，求nums最大值至少出现k次的子数组个数。\n思路这个月全是这种类似的题啊，完全没有什么讲的想法与必要。\n找满足条件的子区间个数，滑动窗口，枚举右端点找最左不满足的左端点就好。\n实现class Solution {using ll = long long;public:    long long countSubarrays(vector&lt;int&gt;&amp; nums, int k) {        ll ans = 0;        const int n = nums.size();        int mx = ranges::max(nums);        for (int l = 0, r = 0, cur = 0; r &lt; n; r++) {            cur += nums[r] == mx;            while (l &lt;= r &amp;&amp; cur &gt;= k) {                cur -= nums[l++] == mx;            }            ans += l;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2302-统计得分小于 K 的子数组数目","url":"/2025/04/28/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982302-%E7%BB%9F%E8%AE%A1%E5%BE%97%E5%88%86%E5%B0%8F%E4%BA%8E-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums与整数上界k\n求nums内区间和乘区间长度严格小于k的非空子数组个数\n思路又又又是求数组内满足条件的子区间个数\n那写了这么多相似的题，应该很自然的可以想到使用滑动窗口，枚举右端点\n唯一差异是先前的多是区间越长越可能合法，这题是区间越小越可能合法，那就是改 寻第一个不满足的左端点 为 寻第一个满足的左端点，统计方向改变即可。\n仅需维护当前窗口和即可。\n实现class Solution {using ll = long long;public:    long long countSubarrays(vector&lt;int&gt;&amp; nums, long long k) {        ll ans = 0;        ll cur = 0;        for (int l = 0, r = 0; r &lt; nums.size(); r++) {            cur += nums[r];            while (l &lt;= r &amp;&amp; cur * (r - l + 1) &gt;= k) {                cur -= nums[l++];            }            ans += r - l + 1;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3392-统计符合条件长度为 3 的子数组数目","url":"/2025/04/27/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983392-%E7%BB%9F%E8%AE%A1%E7%AC%A6%E5%90%88%E6%9D%A1%E4%BB%B6%E9%95%BF%E5%BA%A6%E4%B8%BA-3-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums，求长度为3且第一个数与第三个数的和为第二个数的一半的子数组个数。\n思路很明显就是求nums[i] == (nums[i - 1] + nums[i + 1]) * 2的个数，直接暴力即可，稍微注意以下边界就好。\n实现class Solution {public:    int countSubarrays(vector&lt;int&gt;&amp; nums) {        int ans = 0;        const int n = nums.size();        for (int i = 1; i &lt; n - 1; i++) {            if (nums[i] &amp; 1) continue;            ans += nums[i] / 2 == nums[i - 1] + nums[i + 1];        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2444-统计定界子数组的数目","url":"/2025/04/26/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982444-%E7%BB%9F%E8%AE%A1%E5%AE%9A%E7%95%8C%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums与两整数minK与maxK\n若某数组满足以下条件则称其为定界子数组\n\n\n\n\n求nums中定界子数组个数\n思路又是求满足条件的子数组个数，最近的每日一题都是这种题，那写到这应该还是比较熟悉的。比较自然的可以想到使用滑动窗口求解。\n枚举右端点，那么有多少个左端点是可以符合条件的呢？\n首先区间的最大值需要为maxK且最小值需为minK故而左端点一定是在当前右端点左侧离右端点最近的值为minK的左侧与最近的值为maxK的左侧，即两者取min\n同时区间内不能存在[minK, maxK]的值，所以合法左端点最远可以取到当前右端左侧最近的不属于[minK, maxK]的位置。\n实现class Solution {using ll = long long;public:    long long countSubarrays(vector&lt;int&gt;&amp; nums, int minK, int maxK) {        ll ans = 0;        for (int i = 0, mx = -1, mn = -1, no = -1; i &lt; nums.size(); i++) {            if (nums[i] == minK) mn = i;            if (nums[i] == maxK) mx = i;            if (nums[i] &gt; maxK || nums[i] &lt; minK) no = i;            ans += max(min(mx, mn) - no, 0);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2845-统计趣味子数组的数目","url":"/2025/04/25/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982845-%E7%BB%9F%E8%AE%A1%E8%B6%A3%E5%91%B3%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定整数数组nums，以及整数modulo和k。\n记数组内满足x % modulo == k的个数为cnt\n若nums的某子数组满足cnt % modulo == k则称其为趣味子数组，求nums内的趣味子数组个数。\n思路首先可以发现我们仅关注满足x % modulo == k的x的个数，因此我们可以将所有nums内模modulo为k的数记为1其他数则记为0;\n完成转换后什么样的子数组满足cnt % modulo == k呢，显然需要满足\n\n那么是不是可以联想到前缀和，再结合一下模运算的性质，可以得出结果。\n实现class Solution {using ll = long long;public:    long long countInterestingSubarrays(vector&lt;int&gt;&amp; nums, int modulo, int k) {        ll ans = 0;        unordered_map&lt;int, int&gt; cnt;        int pre = 0;        for (const auto&amp; x : nums) {            cnt[pre]++;            pre += x % modulo == k;            if (pre &gt;= modulo) pre -= modulo;            ans += cnt[(pre - k + modulo) % modulo];        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2799-统计完全子数组的数目","url":"/2025/04/24/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982799-%E7%BB%9F%E8%AE%A1%E5%AE%8C%E5%85%A8%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums，称不同元素的数目与整个nums不同元素的个数相同的子数组为完全子数组。求nums中完全子数组个数。\n思路思路与2025-04-16的2537-统计好子数组的数目其实是高度类似的\n进行一个滑动窗口，枚举窗口的右端点，对于每个右端点其最左不满足条件的位置左侧所有位置均满足条件。\n使用哈希简单计数即可。\n实现class Solution {public:    int countCompleteSubarrays(vector&lt;int&gt;&amp; nums) {        unordered_set&lt;int&gt; st(nums.begin(), nums.end());        int cnt = st.size();        int ans = 0, cur = 0;        unordered_map&lt;int, int&gt; f;        for (int l = 0, r = 0; r &lt; nums.size(); r++) {            f[nums[r]]++;            if (f[nums[r]] == 1) cur++;            while (l &lt;= r &amp;&amp; cur == cnt) {                f[nums[l]]--;                if (f[nums[l]] == 0) cur--;                l++;            }            ans += l;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1399-统计最大组的数目","url":"/2025/04/23/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981399-%E7%BB%9F%E8%AE%A1%E6%9C%80%E5%A4%A7%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定整数n，将[1, n]中所有数位和相同的分作一组，求大小并列最大的组的数目\n思路首先这道题的数据范围很小\n\n可以考虑直接暴力枚举[1, n]计算其数位和然后统计对应组的大小。\n进阶一些可以考虑数位dp，但比较常规便不过多赘述，仅列出递推公式：\n记为递推到第位数位和为前几位是（）否（）等于对应数位的方案个数\n为十进制下第位的数\n为第位所填的数\n\n\n\n实现数位dp实现\nclass Solution {public:    int countLargestGroup(int n) {        string s = to_string(n);        reverse(s.begin(), s.end());        const int N = s.size();        vector dp(2, vector&lt;vector&lt;int&gt;&gt; (N + 1, vector&lt;int&gt; (9 * N + 1)));        dp[1][N][0] = 1;        for (int i = N; i &gt; 0; i--) {            for (int j = 0; j &lt;= (N - i) * 9; j++) {                if (dp[0][i][j] == 0 &amp;&amp; dp[1][i][j] == 0) continue;                for (int k = 0; k &lt;= 9; k++) {                    if (k &lt; s[i - 1] - '0') {                        dp[0][i - 1][j + k] += dp[0][i][j] + dp[1][i][j];                    } else if (k == s[i - 1] - '0') {                        dp[1][i - 1][j + k] += dp[1][i][j];                        dp[0][i - 1][j + k] += dp[0][i][j];                    } else {                        dp[0][i - 1][j + k] += dp[0][i][j];                    }                }            }        }        int mx = 0, ans = 0;        for (int i = 1; i &lt;= 9 * N; i++) {            int t = dp[0][0][i] + dp[1][0][i];            if (mx &lt; t) {                mx = t;                ans = 1;            } else if (mx == t) {                ans++;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","dp"]},{"title":"力扣每日一题2338-统计理想数组的数目","url":"/2025/04/22/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982338-%E7%BB%9F%E8%AE%A1%E7%90%86%E6%83%B3%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定值n与maxValue\n称满足以下条件的数组arr为理想数组：\n\n长度为n\n每个元素在[1, maxValue]\n每个元素均可被前一个元素整除即arr[i] % arr[i - 1] == 0\n\n求不同理想数组数目\n思路每个元素均可被前一个元素整除，也就是每个数均为上一个元素的倍数。\n当数组内的最大值即最后一个元素固定时，有多少个满足条件的理想数组呢。可以考虑将最大值质因数分解得到：\n\n那么是不是在数组的n个位置中相对前一个元素，分别乘了\n次次次\n那么问题就转化为了在n个盒子放a个红球，b个黄球...k个蓝球允许有盒子空出，允许多个球在同一盒子的问题。\n显然不同颜色的球的方法是互相独立的互相之间可以直接乘算。\n那么在n个盒子中放x个同样的球允许放空有多少种方法呢，这里我参考了灵茶山艾府大佬的题解，讲的非常好\n可以转化为在n个盒子中放x + n个相同的球，不允许放空；在放完结束后从每个盒子中各拿出一个球即为n个盒子放x个球允许放空。\n那么如何做在n个盒子中放x + n个相同的球，不允许放空呢，显然是有x + n个球x + n - 1个空隙中插入n - 1个挡板的方案即\n\n故只需预处理出组合数与质因式分解的结果再进行方案数计算即可。\n实现constexpr int mod = 1e9 + 7;constexpr int MX = 1e4;vector&lt;int&gt; primes;int minp[MX + 1];vector&lt;vector&lt;int&gt;&gt; pi(MX + 1);constexpr int MK = __lg(MX) + 1;int C[MX + MK + 1][MX + 1];int init = []() {    for (int i = 2; i &lt;= MX; i++) {        if (minp[i] == 0) {            minp[i] = i;            primes.push_back(i);        }        for (const auto&amp; p : primes) {            if (p * i &gt; MX) break;            minp[p * i] = p;            if (minp[i] == p) break;        }    }    for (int i = 2; i &lt;= MX; i++) {        int x = i, mp = minp[i];        while (x != 1) {            int cnt = 0;            for ( ; x % mp == 0; x /= mp, cnt++);            pi[i].push_back(cnt);            mp = minp[x];        }    }    for (int i = 0; i &lt;= MX + MK; i++) {        C[i][0] = 1;        for (int j = 1; j &lt;= min(i, MX); j++) {            C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % mod;        }    }    return 0;} ();class Solution {public:    int idealArrays(int n, int maxValue) {        int ans = 0;        for (int i = 1; i &lt;= maxValue; i++) {            int res = 1;            for (const auto&amp; x : pi[i]) {                res = 1ll * res * C[x + n - 1][n - 1] % mod;            }            ans = (ans + res) % mod;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","组合数学"]},{"title":"力扣每日一题2145-统计隐藏数组数目","url":"/2025/04/21/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982145-%E7%BB%9F%E8%AE%A1%E9%9A%90%E8%97%8F%E6%95%B0%E7%BB%84%E6%95%B0%E7%9B%AE/","content":"题意给定某隐藏数组的差分数组differences与定值上界upper及定值lower，求满足最大最小值不超过给定上下界的合法隐藏数组的个数。\n思路对差分数组求前缀和即可获知隐藏数组各数与第一个数的差值，也因此易得隐藏数组最大最小值的相对差值。\n又对于给定的差分结果，确定一个数即可确定整个隐藏数组。\n根据给定的上下界upper与lower计算结果即可。\n实现class Solution {using ll = long long;public:    int numberOfArrays(vector&lt;int&gt;&amp; differences, int lower, int upper) {        ll mn = 0, mx = 0;        ll cur = 0;        for (const auto&amp; x : differences) {            cur += x;            mn = min(mn, cur);            mx = max(mx, cur);        }        return max(upper - lower - (mx - mn) + 1, 0ll);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题781-森林中的兔子","url":"/2025/04/20/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98781-%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90/","content":"题意给定整数数组answers,其中answers[i]表示第i只兔子回答问题\"还有多少只兔子与你颜色相同\"的答案。\n求问兔子总数量的最小可能值\n思路并没有什么算法上的知识，就是一个比较简单的数学思维题。\n如果有1只兔子回答1，显然答案是2，因为问题是还有多少只也就是除你外有多少只与你同色\n如果有2只兔子回答1，显然答案是2，因为2只同色的问同样的问题答案相同是符合题意的\n如果有3只兔子回答1，显然答案是4，若3只兔子颜色相同那么它们的回答是不可能为1的，使得总数最小可以贪心的将其中两只配对，另一只独立，问题就变为了前两个问题的和\n…\n不难推出，回答为x的兔子，只可能与回答x的其他兔子同色，最多可以与另外x只回答均为x的兔子组成一个有x + 1只兔子的同色组\n记录各个回答的兔子个数，然后贪心地计算答案即可。\n实现class Solution {public:    int numRabbits(vector&lt;int&gt;&amp; answers) {        unordered_map&lt;int, int&gt; cnt;        for (const auto&amp; x : answers) {            cnt[x]++;        }        int ans = 0;        for (const auto&amp; [x, t] : cnt) {            ans += (t + x) / (x + 1) * (x + 1);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2563-统计公平数对的数目","url":"/2025/04/19/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982563-%E7%BB%9F%E8%AE%A1%E5%85%AC%E5%B9%B3%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums与定值lower和upper，求满足以下条件的数对(i, j)个数\n\n\n思路考虑固定nums[j]那么什么样的nums[i]满足条件呢，移项发现\n\n不难发现nums[i]越大lower - nums[i]与upper - nums[i]越小\n那么比较好实现的就是二分得到第一个满足条件的与最后一个不满足条件的\n实现class Solution {using ll = long long;public:    long long countFairPairs(vector&lt;int&gt;&amp; nums, int lower, int upper) {        ranges::sort(nums);        ll ans = 0;        const int n = nums.size();        for (int i = 0; i &lt; n; i++) {            int r = upper_bound(nums.begin(), nums.begin() + i, upper - nums[i]) - nums.begin();            int l = lower_bound(nums.begin(), nums.begin() + i, lower - nums[i]) - nums.begin();            ans += r - l;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2364-统计坏数对的数目","url":"/2025/04/18/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982364-%E7%BB%9F%E8%AE%A1%E5%9D%8F%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums，求满足以下条件的数对(i, j)个数\n\n思路这几天的每日一题都是类似的求数对或求三元组个数，应该可以感受到求不等于是没有求等于对数方便的。\n那么可以考虑正难则反，求出满足下列条件的数对(i, j)个数，再取补集即可。\n\n好像还是不是很好做，对于给定的i 或 j还是需要枚举另一个数进行筛选\n但是发现可以将式子移项变形\n\n就可以发现此时比较好做了，只需枚举每个数，记录其下标与其值之差即可。\n实现class Solution {using ll = long long;public:    long long countBadPairs(vector&lt;int&gt;&amp; nums) {        unordered_map&lt;int, int&gt; cnt;        ll ans = ll(nums.size()) * (ll(nums.size()) - 1) / 2;        for (int i = 0; i &lt; nums.size(); i++) {            ans -= cnt[i - nums[i]];            cnt[i - nums[i]]++;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2176-统计数组中相等且可以被整除的数对","url":"/2025/04/17/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982176-%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9B%B8%E7%AD%89%E4%B8%94%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%95%B4%E9%99%A4%E7%9A%84%E6%95%B0%E5%AF%B9/","content":"题意给定数组nums与定值k，求满足以下条件的下标 (i, j) 对数\n0 &lt;= i &lt; j &lt; nums.size()\nnums[i] == nums[j]\ni * j % k == 0\n思路首先这道题的数据范围比较小，是可以直接暴力进行的（没有预处理等操作暴力反而还更快些）\n但这样不太优雅，我们假定数据范围比较大时应该如何做呢\n首先考虑什么情况下 i * j % k == 0呢\n显然若i % k == 0 || j % k == 0时等式是成立的\n但若i、j均不为k的倍数呢，是否有可能乘积被k 整除，举例发现是可行的比如6 % 4 != 0, 10 % 4 != 0, 6 * 10 % 4 == 0 \n可以发现：\n\n若j % t == 0 可得i * j % k == 0\n那么枚举j再计算符合nums[i] == nums[j] 且 i % t == 0的条件的i个数即可\n此处使用哈希记录j之前的值为nums[j]及其对应下标的因数，如此只需统计cnt[(nums[j], t)]即可\n注意unordered_map的键值不能直接使用pair&lt;&gt;需要重载其运算符，或将nums[j] 与 t合并为一个数再进行哈希计算\n实现暴力实现\nclass Solution {public:    int countPairs(vector&lt;int&gt;&amp; nums, int k) {        int ans = 0;        for (int i = 0; i &lt; nums.size(); i++) {            for (int j = i + 1; j &lt; nums.size(); j++) {                if (nums[i] == nums[j] &amp;&amp; i * j % k == 0) ans++;            }        }        return ans;    }};\n\n\n\n其他实现\nconstexpr int N = 100;vector&lt;vector&lt;int&gt;&gt; factors(N + 1);int init = []() {    for (int i = 1; i &lt;= N; i++) {        for (int j = i; j &lt;= N; j += i) {            factors[j].push_back(i);        }    }    return 0;} ();class Solution {public:    int countPairs(vector&lt;int&gt;&amp; nums, int k) {        int ans = 0;        auto cal = [](int x, int f) -&gt; int {            return x &lt;&lt; 8 | f;        };        unordered_map&lt;int, int&gt; cnt;        for (int i = 0; i &lt; nums.size(); i++) {            int t = k / gcd(i, k);            ans += cnt[cal(nums[i], t)];            if (i &amp;&amp; nums[i] == nums[0]) ans++;            for (auto f : factors[i]) {                cnt[cal(nums[i], f)]++;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2537-统计好子数组的数目","url":"/2025/04/16/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982537-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums与定值k，求该nums中至少有k对相等数的子数组数目\n即有多少子数组arr至少含有k对(i, j)满足i &lt; j 且 arr[i]==arr[j]\n思路求满足条件的子数组个数，比较经典的思路就是双指针进行一个滑动窗口。\n维护区间内相等数的对数可以考虑使用哈希记录各个数出现的次数。\n枚举窗口的右端点，对于每个右端点其最左不满足条件的位置左侧所有位置均满足条件。\n实现class Solution {using ll = long long;public:    long long countGood(vector&lt;int&gt;&amp; nums, int k) {        ll ans = 0;        unordered_map&lt;int, int&gt; cnt;        for (int l = 0, r = 0, p = 0; r &lt; nums.size(); r++) {            p += cnt[nums[r]];            cnt[nums[r]]++;            while (p &gt;= k) {                cnt[nums[l]]--;                p -= cnt[nums[l]];                l++;            }            ans += l;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2179-统计数组中好三元组数目","url":"/2025/04/15/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982179-%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%BB%84%E4%B8%AD%E5%A5%BD%E4%B8%89%E5%85%83%E7%BB%84%E6%95%B0%E7%9B%AE/","content":"题意给定两[0, n - 1] 的排列nums1与nums2，求满足下列条件的三元组(i, j, k)的个数\ni, j, k的出现顺序在nums1与nums2中均一致为顺序出现，记p1_i 为i在nums1中出现的位置，p2_i为i在nums2中出现的位置，即：\n\n思路注意到此处三元组仅关注数出现的顺序而与数的具体值无关，可以考虑将nums1 中的各个数值映射到其对应的出现顺序。\n对于统计合法的三元组问题，可以考虑枚举中间值j再判断其前后满足条件的i与k数量，此处枚举j那么对于同一个j其合法的三元组个数即为：nums1 与 nums2 中均出现在 j 前的数的个数 * nums1 与 nums2 中均出现在 j 之后的数的个数\n那么枚举nums2中的元素，将每个元素视作三元组的j，使用与nums1相同的映射函数P：\n\n小于P(nums2[j])的数即为在nums1中，于nums2[j]之前所出现过的数；\n\n而i &lt; j | nums2[i]即是在nums2中，于nums2[j] 之前所出现过的数；\n\n大于P(nums2[j])的数即为在nums1中，于nums2[j]之后将出现的数；\n\n而i &gt; j | nums2[i]即是在nums2中，于nums2[j] 之后将出现的数；\n\n\n取并操作即可得到nums1 与 nums2 中均出现在 nums2[j] 前的数的个数 与 nums1 与 nums2 中均出现在 nums2[j] 之后的数的个数\n如何快速维护得到小于某个值且在之前出现过的值的个数呢，比较自然的可以想到树状数组，当然线段树等其他数据结构也是可行的。\n实现template&lt;typename T&gt;class Fenwick {private:    int n;    vector&lt;T&gt; a;public:    Fenwick(int x) {        n = x;        a.resize(x + 1);    }    void add(int x, T val) {        for ( ; x &lt;= n; x += (x &amp; -x)) {            a[x] += val;        }    }    T query(int x) {        T res = 0;        for ( ; x &gt; 0; x -= (x &amp; -x)) {            res += a[x];        }        return res;    }};class Solution {using ll = long long;public:    long long goodTriplets(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        ll ans = 0;        const int n = nums1.size();        vector&lt;int&gt; p(n);        for (int i = 0; i &lt; n; i++) {            p[nums1[i]] = i;        }        Fenwick&lt;int&gt; f(n);        for (int i = 0; i &lt; n; i++) {            int t = f.query(p[nums2[i]]);            ans += 1ll * t * (n - 1 - p[nums2[i]] - i + t);            f.add(p[nums2[i]] + 1, 1);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","fenwick"]},{"title":"力扣每日一题1534-统计好三元组","url":"/2025/04/14/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981534-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E4%B8%89%E5%85%83%E7%BB%84/","content":"题意给定数组arr，与三整数a、b、c，求满足以下条件的三元组(i, j, k)个数\n\n​\n\n\n思路注意到数组大小范围很小仅有1e2，直接暴力即可。\n当然也存在更加高效的做法，但我有点犯懒了，详细还是请见他人博客（\n实现class Solution {public:    int countGoodTriplets(vector&lt;int&gt;&amp; arr, int a, int b, int c) {        int ans = 0;        for (int i = 0; i &lt; arr.size(); i++) {            for (int j = i + 1; j &lt; arr.size(); j++) {                if (abs(arr[i] - arr[j]) &gt; a) continue;                for (int k = j + 1; k &lt; arr.size(); k++) {                    if (abs(arr[j] - arr[k]) &gt; b) continue;                    if (abs(arr[i] - arr[k]) &gt; c) continue;                    ans++;                }            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1922-统计好数字的数目","url":"/2025/04/13/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981922-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意若一个数字串满足偶数位均位偶数奇数位均为质数，则称其为好数字。\n问长度为给定n的好数字个数（可前导零）。\n思路个位数的偶数共有5个0, 2, 4, 6, 8\n个位数的质数共有4个2, 3, 5, 7\n且允许存在前导零，那么显然这是一个简单的数学问题\n记为even偶数位个数，odd为奇数位个数则有\n方案数\n唯一需要注意的是n较大 , 需用上快速幂，且答案较大需对1e9 + 7取模\n实现class Solution {using ll = long long;static constexpr ll mod = 1e9 + 7;public:    ll powMod(ll a, ll b) {        ll res = 1;        while (b) {            if (b &amp; 1) {                res = res * a % mod;            }            a = a * a % mod;            b &gt;&gt;= 1;        }        return res;    }    int countGoodNumbers(long long n) {        ll even = n / 2 + (n &amp; 1), odd = n / 2;        return powMod(5, even) * powMod(4, odd) % mod;    }};\n\n","categories":["做题笔记"],"tags":["cpp","math"]},{"title":"力扣每日一题3272-统计好整数的数目","url":"/2025/04/12/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983272-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意若一个数x是回文整数且被k整除则称其为k回文整数。\n若一个数y可以对其数位进行重排后变为k回文整数则称其为好整数（无前导零）。\n对于给定的数位n与个位数k，求问有多少个n位数为好整数。\n思路首先考虑得到k回文整数再将其重排得到好整数\n对于回文数，因为其前半部分与其后半部分反转后相同，故可以考虑枚举其前半部分。\n能否整除k仅需计算一下即可。\n而对于一个k回文整数有多少种合法重排方式，则是一个较为简单的排列组合问题，首先是第一位数不能为0,剩余位数可任意排序，又相同的数之间互换是相同的，故而可以推导出：\n记为该数为i的数位个数\n合法重排方案数\n显然当均相等时得到的方案数相同，再考虑对其使用哈希去重即可\n实现array&lt;int, 11&gt; f;int init = []() {    f[0] = 1;    for (int i = 1; i &lt;= 10; i++) {        f[i] = i * f[i - 1];    }    return 0;}();class Solution {using ll = long long;public:    long long countGoodIntegers(int n, int k) {        ll ans = 0;        int b = pow(10, (n + 1) / 2 - 1);        unordered_set&lt;string&gt; vis;        array&lt;int, 10&gt; cnt;        for (int i = b; i &lt; b * 10; i++) {            string s = to_string(i), t = s;            if (n &amp; 1) t.pop_back();            reverse(t.begin(), t.end());            s += t;            if (stoll(s) % k) continue;            ranges::sort(s);            if (vis.count(s)) continue;            vis.insert(s);            cnt.fill(0);            for (const auto&amp; ch : s) cnt[ch - '0']++;            ll res = (n - cnt[0]) * f[n - 1];            for (int i = 0; i &lt; 10; i++) {                res /= f[cnt[i]];            }            ans += res;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","组合数学"]},{"title":"力扣每日一题2843-统计对称整数的数目","url":"/2025/04/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982843-%E7%BB%9F%E8%AE%A1%E5%AF%B9%E7%A7%B0%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意2 * n位数字组成的整数x，若其前n与后n位数位和相等，则称其对称。\n求给定范围[low, high]内对称数的个数。\n思路注意到数据范围很小 直接遍历计数即可。\n但这样太不优雅了，若数据范围扩大该如何做呢，显然和昨天一样是可以通过数位dp来解决的，但尝试了一下感觉好麻烦哦，不想写，easy题有easy题的解法，摆了。\n实现class Solution {public:    static constexpr int mx = 20;    int countSymmetricIntegers(int low, int high) {        auto check = [](int x) -&gt; bool {            string s = to_string(x);            int n = s.size();            if (n &amp; 1) return false;            int sum = 0;            for (int i = 0; i &lt; n; i++) {                sum += (i &lt; n / 2 ? 1 : -1) * (s[i] - ' 0');            }            return sum == 0;        };        int ans = 0;        for (int i = low; i &lt;= high; i++) {            if (check(i)) ans++;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2999-统计强大整数的数目","url":"/2025/04/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982999-%E7%BB%9F%E8%AE%A1%E5%BC%BA%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定区间[start, finish] 、数位限制limit与后缀s，求区间范围内满足每一位数不超过limit且以s为后缀的数的个数。\n思路比较经典的数位dp。\n首先考虑如何计算区间[0, finish]即 满足条件 的x个数。\n在不考虑s为后缀仅考虑每一位限制为limit的条件情况下，从高位向低位递推\n记表示finish第j位\n 当i=0时表示到第j位严格小于finish且满足限制limit的方案个数，当i=1时表示到第j位严格等于finish且满足限制limit的方案个数，可以推到出以下转移方程$$\\left{\\right.$$再考虑如何满足以s为后缀\n记 为s的第j位\n同理可有$$\\left{\\right.$$最终即为所求。\n同理再求出范围[0, start)即[0, start - 1]内的方案数，两者相减即可得到[start, finish]内的方案数。\n实现class Solution {public:    using ll = long long;    long long numberOfPowerfulInt(long long start, long long finish, int limit, string s) {        reverse(s.begin(), s.end());        auto cal = [&amp;](ll t) -&gt; ll {            string num = to_string(t);            reverse(num.begin(), num.end());            vector dp(2, vector&lt;ll&gt; (max(num.size(), s.size()) + 1));            dp[1][max(num.size(), s.size())] = 1;            for (int i = num.size() - 1; i &gt;= 0; i--) {                int x = num[i] - '0';                if (i &gt;= s.size()) {                    if (x &gt; limit) {                        dp[0][i] += (limit + 1) * (dp[0][i + 1] + dp[1][i + 1]);                    } else {                        dp[1][i] += dp[1][i + 1];                        dp[0][i] += x * dp[1][i + 1] + (limit + 1) * dp[0][i + 1];                    }                } else {                    int y = s[i] - '0';                    if (x &gt; y) {                        dp[0][i] += dp[1][i + 1] + dp[0][i + 1];                    } else if (x == y) {                        dp[1][i] += dp[1][i + 1];                        dp[0][i] += dp[0][i + 1];                    } else {                        dp[0][i] += dp[0][i + 1];                    }                }            }            return dp[0][0] + dp[1][0];        };        return cal(finish) - cal(start - 1);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","数位dp"]},{"title":"网络学习","url":"/2025/04/09/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/","content":"由于我个人仍在学习当中，所学内容可能较为零散不成体系更多是以学习时间记录而非内容体系记录，所写可能也因此显得有些杂乱无章，当我建立起一个较为完整的知识体系框架后也许会回来整理吧。\n所记录的问题可能来自我网上冲浪所见或面试所遇我认为值得记录学习的，回答可能来自于网络资料、各路大模型回答以及一些我个人的理解，可能准确率并不太高，若有错漏还望不吝赐教。\n","categories":["学习笔记"],"tags":["note","network"]},{"title":"cpp学习","url":"/2025/04/09/cpp%E5%AD%A6%E4%B9%A0/","content":"由于我个人仍在学习当中，所学内容可能较为零散不成体系更多是以学习时间记录而非内容体系记录，所写可能也因此显得有些杂乱无章，当我建立起一个较为完整的知识体系框架后也许会回来整理吧。\n所记录的问题可能来自我网上冲浪所见或面试所遇我认为值得记录学习的，回答可能来自于网络资料、各路大模型回答以及一些我个人的理解，可能准确率并不太高，若有错漏还望不吝赐教。\n智能指针引用计数概念防止内存泄露。\n基本想法：对于动态分配的对象进行引用计数每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次， 每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。\nc++11引入智能指针概念，包含std::shared_ptr/std::unique_ptr/std::weak_ptr,头文件为&lt;memory&gt;\nshared_ptr可自动记录有多少个shared_ptr共同指向同一对象，当计数归零时自动释放对应对象内存\nstd::make_shared&lt;T&gt; (Args&amp;&amp;... args); // 创建对应对象并返回其指针.get(); // 获得原始指针.use_count(); // 查看对象引用计数\tauto p = ptr.get(); // 不会增加计数\tauto p = ptr; // 会增加计数.reset(); // 置空\n\nunique_ptr独占的智能指针, 禁止其他智能指针与其共享同一个对象\n\ncpp11没有提供std::make_unique, cpp委员会说是忘记了\n\nunique_ptr 用法shared_ptr与类似，但无法通过赋值拷贝给另一智能指针，但可以通过std::move将其转移给另一unique_ptr\n同时还可以通过.get()获取其原始指针后直接赋值给普通指针，但这样显然并不安全。\n","categories":["学习笔记"],"tags":["cpp","note"]},{"title":"力扣每日一题3375-使数组的值全部为K的最少操作次数","url":"/2025/04/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983375-%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%BC%E5%85%A8%E9%83%A8%E4%B8%BAK%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","content":"题意数h对于数组nums,若满足,则称h合法，即数组中大于h的数均相等。\n每次操作可以选择任意合法h使得nums中所有大于h的元素变为h\n求问将nums中所有数变为给定k值所需最少操作次数。\n思路当nums最小值小于k时显然是不存在合法操作的，因为不存在将元素值变大的操作。\n可以发现每次操作使得最大值变为次大值时有最优，此题本质可转化为数组中大于k的元素种类数。\n实现class Solution {public:    int minOperations(vector&lt;int&gt;&amp; nums, int k) {        ranges::sort(nums);        if (nums.front() &lt; k) return -1;        nums.erase(unique(nums.begin(), nums.end()), nums.end());        return nums.size() - (nums.front() == k);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3396-使数组元素互不相同所需的最少操作次数","url":"/2025/04/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983396-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%90%8C%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","content":"题意给出一数组，每次操作可以删除数组头三个元素，问使得数组元素互不相同所需最少操作次数。\n思路注意到数据范围很小，数组大小与元素大小均在[1, 100]\n可以考虑正着模拟删除操作，计算删除次数。\n也可以考虑反着操作，从尾开始添加元素，得到最长无重后缀，未添加的元素个数即为要删除的元素个数。\n实现正着模拟删除\nclass Solution {array&lt;int, 101&gt; vis;public:    int minimumOperations(vector&lt;int&gt;&amp; nums) {        vis.fill(0);        int ans = 0, cnt = 0;        for (const auto&amp; x : nums) {            if (vis[x] == 1) cnt++;            vis[x]++;        }        for (int i = 0; cnt &amp;&amp; i &lt; nums.size() - 2; i += 3) {            ans++;            cnt -= (--vis[nums[i]]) == 1;            cnt -= (--vis[nums[i + 1]]) == 1;            cnt -= (--vis[nums[i + 2]]) == 1;        }        ans += cnt &gt; 0;        return ans;    }};\n\n\n\n反着模拟添加\nclass Solution {array&lt;int, 101&gt; vis;public:    int minimumOperations(vector&lt;int&gt;&amp; nums) {        vis.fill(0);        for (int i = nums.size() - 1; i &gt;= 0; i--) {            if (vis[nums[i]]) {                return (i + 1 + 2) / 3;            }            vis[nums[i]]++;        }        return 0;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题416-分割等和子集","url":"/2025/04/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/","content":"题意给出整数数组nums，判断其是否可分割为两个和相等的子集\n思路分割为两个等和数组，换言而止就是将 nums分割为子集a 与b使得：\n\n注意到数据范围很小：\n\n\n即满足\n可以考虑使用dp判断是否存在子集和为 \n实现代码class Solution {public:    bool canPartition(vector&lt;int&gt;&amp; nums) {        int sum = accumulate(nums.begin(), nums.end(), 0);        if (sum &amp; 1) return false;        sum &gt;&gt;= 1;        vector&lt;bool&gt; dp(sum + 1);        dp[0] = true;        for (const auto&amp; x : nums) {            for (int i = sum - x; i &gt;= 0; i--) {                if (!dp[i])continue;                dp[i + x] = true;            }            if (dp.back()) return true;        }        return dp.back();    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","dp"]},{"title":"力扣每日一题368.最大整除子集","url":"/2025/04/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98368-%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86/","content":"题意给一个整数集合nums，找最大子集，满足子集元素两两之间一数为另一数的倍数。\n形式化：找出nums子集ans满足 使得ans大小最大\n思路注意到\n可以想到将集合升序排序后再进一步处理。\n又注意到\n即只需满足子集排序后相邻两数互为倍数可满足题设条件。\n可以考虑使用dp记录当前数为子集最大值时满足条件的子集最大大小\n\n实现代码class Solution {public:    vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        ranges::sort(nums);        vector&lt;int&gt; dp(n, 1), from(n);        iota(from.begin(), from.end(), 0);        int mx = 0, mxloc;        for (int i = 0; i &lt; n; i++) {            for (int j = i + 1; j &lt; n; j++) {                if (nums[j] % nums[i]) continue;                if (dp[j] &lt; dp[i] + 1) {                    dp[j] = dp[i] + 1;                    from[j] = i;                }            }            if (dp[i] &gt; mx) {                mx = dp[i];                mxloc = i;            }        }        vector&lt;int&gt; ans;        for (int i = mxloc; ; i = from[i]) {            ans.push_back(nums[i]);            if (i == from[i]) break;        }        return ans;    }};\n\n其他搭建博客后担心实在无东西可写，于是想到了写写力扣的每日一题。\n之前遇到较为麻烦的每日一题就会懒得写，在博客写这个也许既能让博客每日更新又能push我每天写题。\n当前目标就先定为拿下四月全勤徽章吧。\n","categories":["做题笔记"],"tags":["cpp","leetcode","dp"]},{"title":"第一篇博客","url":"/2025/04/06/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","content":"我是sfiisf，这是我兴趣使然创建的博客，现在还什么都没有，也不知道将来会有些什么。\n防止这个新生的博客太空，于是有了这篇自我介绍。\nsfiisf，这个名字是中二时期一拍大腿想出的名字，其中的内涵有些令人害羞尚且不好意思详细介绍，虽然有些后悔但回过神来时已经在很多地方留下这个名字了，只好延用至今。\n仔细想想，我是个乏善可陈且无趣的人，搜肠刮肚自我介绍到这就有点写不下去了。\n虽然不知道将来是我的分享欲先战胜我的懒惰，还是我的懒惰先战胜我的分享欲，但我是个怎么样的人，还是从我将来的文章来认识我吧！\nLove!\n","categories":["杂谈"],"tags":[]}]