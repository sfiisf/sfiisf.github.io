[{"title":"力扣每日一题3272-统计好整数的数目","url":"/2025/04/12/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983272-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意若一个数x是回文整数且可以整除k则称其为k回文整数。\n若一个数y可以对其数位进行重排后变为k回文整数则称其为好整数（无前导零）。\n对于给定的数位n与个位数k，求问有多少个n位数为好整数。\n思路首先考虑得到k回文整数再将其重排得到好整数\n对于回文数，因为其前半部分与其后半部分反转后相同，故可以考虑枚举其前半部分。\n能否整除k仅需计算一下即可。\n而对于一个k回文整数有多少种合法重排方式，则是一个较为简单的排列组合问题，首先是第一位数不能为0,剩余位数可任意排序，又相同的数之间互换是相同的，故而可以推导出：\n记为该数为i的数位个数\n合法重排方案数\n显然当均相等时得到的方案数相同，再考虑对其使用哈希去重即可\n实现array&lt;int, 11&gt; f;int init = []() {    f[0] = 1;    for (int i = 1; i &lt;= 10; i++) {        f[i] = i * f[i - 1];    }    return 0;}();class Solution {using ll = long long;public:    long long countGoodIntegers(int n, int k) {        ll ans = 0;        int b = pow(10, (n + 1) / 2 - 1);        unordered_set&lt;string&gt; vis;        array&lt;int, 10&gt; cnt;        for (int i = b; i &lt; b * 10; i++) {            string s = to_string(i), t = s;            if (n &amp; 1) t.pop_back();            reverse(t.begin(), t.end());            s += t;            if (stoll(s) % k) continue;            ranges::sort(s);            if (vis.count(s)) continue;            vis.insert(s);            cnt.fill(0);            for (const auto&amp; ch : s) cnt[ch - '0']++;            ll res = (n - cnt[0]) * f[n - 1];            for (int i = 0; i &lt; 10; i++) {                res /= f[cnt[i]];            }            ans += res;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","组合数学"]},{"title":"力扣每日一题2843-统计对称整数的数目","url":"/2025/04/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982843-%E7%BB%9F%E8%AE%A1%E5%AF%B9%E7%A7%B0%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意2 * n位数字组成的整数x，若其前n与后n位数位和相等，则称其对称。\n求给定范围[low, high]内对称数的个数。\n思路注意到数据范围很小 直接遍历计数即可。\n但这样太不优雅了，若数据范围扩大该如何做呢，显然和昨天一样是可以通过数位dp来解决的，但尝试了一下感觉好麻烦哦，不想写，easy题有easy题的解法，摆了。\n实现class Solution {public:    static constexpr int mx = 20;    int countSymmetricIntegers(int low, int high) {        auto check = [](int x) -&gt; bool {            string s = to_string(x);            int n = s.size();            if (n &amp; 1) return false;            int sum = 0;            for (int i = 0; i &lt; n; i++) {                sum += (i &lt; n / 2 ? 1 : -1) * (s[i] - ' 0');            }            return sum == 0;        };        int ans = 0;        for (int i = low; i &lt;= high; i++) {            if (check(i)) ans++;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2999-统计强大整数的数目","url":"/2025/04/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982999-%E7%BB%9F%E8%AE%A1%E5%BC%BA%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定区间[start, finish] 、数位限制limit与后缀s，求区间范围内满足每一位数不超过limit且以s为后缀的数的个数。\n思路比较经典的数位dp。\n首先考虑如何计算区间[0, finish]即 满足条件 的x个数。\n在不考虑s为后缀仅考虑每一位限制为limit的条件情况下，从高位向低位递推\n记表示finish第j位\n 当i=0时表示到第j位严格小于finish且满足限制limit的方案个数，当i=1时表示到第j位严格等于finish且满足限制limit的方案个数，可以推到出以下转移方程$$\\begin{equation}\\left{\\right.\\end{equation}$$再考虑如何满足以s为后缀\n记 为s的第j位\n同理可有$$\\begin{equation}\\left{\\right.\\end{equation}$$最终即为所求。\n同理再求出范围[0, start)即[0, start - 1]内的方案数，两者相减即可得到[start, finish]内的方案数。\n实现class Solution {public:    using ll = long long;    long long numberOfPowerfulInt(long long start, long long finish, int limit, string s) {        reverse(s.begin(), s.end());        auto cal = [&amp;](ll t) -&gt; ll {            string num = to_string(t);            reverse(num.begin(), num.end());            vector dp(2, vector&lt;ll&gt; (max(num.size(), s.size()) + 1));            dp[1][max(num.size(), s.size())] = 1;            for (int i = num.size() - 1; i &gt;= 0; i--) {                int x = num[i] - '0';                if (i &gt;= s.size()) {                    if (x &gt; limit) {                        dp[0][i] += (limit + 1) * (dp[0][i + 1] + dp[1][i + 1]);                    } else {                        dp[1][i] += dp[1][i + 1];                        dp[0][i] += x * dp[1][i + 1] + (limit + 1) * dp[0][i + 1];                    }                } else {                    int y = s[i] - '0';                    if (x &gt; y) {                        dp[0][i] += dp[1][i + 1] + dp[0][i + 1];                    } else if (x == y) {                        dp[1][i] += dp[1][i + 1];                        dp[0][i] += dp[0][i + 1];                    } else {                        dp[0][i] += dp[0][i + 1];                    }                }            }            return dp[0][0] + dp[1][0];        };        return cal(finish) - cal(start - 1);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","数位dp"]},{"title":"网络学习","url":"/2025/04/09/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/","content":"由于我个人仍在学习当中，所学内容可能较为零散不成体系更多是以学习时间记录而非内容体系记录，所写可能也因此显得有些杂乱无章，当我建立起一个较为完整的知识体系框架后也许会回来整理吧。\n所记录的问题可能来自我网上冲浪所见或面试所遇我认为值得记录学习的，回答可能来自于网络资料、各路大模型回答以及一些我个人的理解，可能准确率并不太高，若有错漏还望不吝赐教。\n","categories":["学习笔记"],"tags":["note","network"]},{"title":"cpp学习","url":"/2025/04/09/cpp%E5%AD%A6%E4%B9%A0/","content":"由于我个人仍在学习当中，所学内容可能较为零散不成体系更多是以学习时间记录而非内容体系记录，所写可能也因此显得有些杂乱无章，当我建立起一个较为完整的知识体系框架后也许会回来整理吧。\n所记录的问题可能来自我网上冲浪所见或面试所遇我认为值得记录学习的，回答可能来自于网络资料、各路大模型回答以及一些我个人的理解，可能准确率并不太高，若有错漏还望不吝赐教。\n智能指针引用计数概念防止内存泄露。\n基本想法：对于动态分配的对象进行引用计数每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次， 每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。\nc++11引入智能指针概念，包含std::shared_ptr/std::unique_ptr/std::weak_ptr,头文件为&lt;memory&gt;\nshared_ptr可自动记录有多少个shared_ptr共同指向同一对象，当计数归零时自动释放对应对象内存\nstd::make_shared&lt;T&gt; (Args&amp;&amp;... args); // 创建对应对象并返回其指针.get(); // 获得原始指针.use_count(); // 查看对象引用计数\tauto p = ptr.get(); // 不会增加计数\tauto p = ptr; // 会增加计数.reset(); // 置空\n\nunique_ptr独占的智能指针, 禁止其他智能指针与其共享同一个对象\n\ncpp11没有提供std::make_unique, cpp委员会说是忘记了\n\nunique_ptr 用法shared_ptr与类似，但无法通过赋值拷贝给另一智能指针，但可以通过std::move将其转移给另一unique_ptr\n同时还可以通过.get()获取其原始指针后直接赋值给普通指针，但这样显然并不安全。\n","categories":["学习笔记"],"tags":["cpp","note"]},{"title":"力扣每日一题3375-使数组的值全部为K的最少操作次数","url":"/2025/04/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983375-%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%BC%E5%85%A8%E9%83%A8%E4%B8%BAK%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","content":"题意数h对于数组nums,若满足,则称h合法，即数组中大于h的数均相等。\n每次操作可以选择任意合法h使得nums中所有大于h的元素变为h\n求问将nums中所有数变为给定k值所需最少操作次数。\n思路当nums最小值小于k时显然是不存在合法操作的，因为不存在将元素值变大的操作。\n可以发现每次操作使得最大值变为次大值时有最优，此题本质可转化为数组中大于k的元素种类数。\n实现class Solution {public:    int minOperations(vector&lt;int&gt;&amp; nums, int k) {        ranges::sort(nums);        if (nums.front() &lt; k) return -1;        nums.erase(unique(nums.begin(), nums.end()), nums.end());        return nums.size() - (nums.front() == k);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3396-使数组元素互不相同所需的最少操作次数","url":"/2025/04/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983396-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%90%8C%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","content":"题意给出一数组，每次操作可以删除数组头三个元素，问使得数组元素互不相同所需最少操作次数。\n思路注意到数据范围很小，数组大小与元素大小均在[1, 100]\n可以考虑正着模拟删除操作，计算删除次数。\n也可以考虑反着操作，从尾开始添加元素，得到最长无重后缀，未添加的元素个数即为要删除的元素个数。\n实现正着模拟删除\nclass Solution {array&lt;int, 101&gt; vis;public:    int minimumOperations(vector&lt;int&gt;&amp; nums) {        vis.fill(0);        int ans = 0, cnt = 0;        for (const auto&amp; x : nums) {            if (vis[x] == 1) cnt++;            vis[x]++;        }        for (int i = 0; cnt &amp;&amp; i &lt; nums.size() - 2; i += 3) {            ans++;            cnt -= (--vis[nums[i]]) == 1;            cnt -= (--vis[nums[i + 1]]) == 1;            cnt -= (--vis[nums[i + 2]]) == 1;        }        ans += cnt &gt; 0;        return ans;    }};\n\n\n\n反着模拟添加\nclass Solution {array&lt;int, 101&gt; vis;public:    int minimumOperations(vector&lt;int&gt;&amp; nums) {        vis.fill(0);        for (int i = nums.size() - 1; i &gt;= 0; i--) {            if (vis[nums[i]]) {                return (i + 1 + 2) / 3;            }            vis[nums[i]]++;        }        return 0;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题416-分割等和子集","url":"/2025/04/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/","content":"题意给出整数数组nums，判断其是否可分割为两个和相等的子集\n思路分割为两个等和数组，换言而止就是将 nums分割为子集a 与b使得：\n\n注意到数据范围很小：\n\n\n即满足\n可以考虑使用dp判断是否存在子集和为 \n实现代码class Solution {public:    bool canPartition(vector&lt;int&gt;&amp; nums) {        int sum = accumulate(nums.begin(), nums.end(), 0);        if (sum &amp; 1) return false;        sum &gt;&gt;= 1;        vector&lt;bool&gt; dp(sum + 1);        dp[0] = true;        for (const auto&amp; x : nums) {            for (int i = sum - x; i &gt;= 0; i--) {                if (!dp[i])continue;                dp[i + x] = true;            }            if (dp.back()) return true;        }        return dp.back();    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","dp"]},{"title":"力扣每日一题368.最大整除子集","url":"/2025/04/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98368-%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86/","content":"题意给一个整数集合nums，找最大子集，满足子集元素两两之间一数为另一数的倍数。\n形式化：找出nums子集ans满足 使得ans大小最大\n思路注意到\n可以想到将集合升序排序后再进一步处理。\n又注意到\n即只需满足子集排序后相邻两数互为倍数可满足题设条件。\n可以考虑使用dp记录当前数为子集最大值时满足条件的子集最大大小\n\n实现代码class Solution {public:    vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        ranges::sort(nums);        vector&lt;int&gt; dp(n, 1), from(n);        iota(from.begin(), from.end(), 0);        int mx = 0, mxloc;        for (int i = 0; i &lt; n; i++) {            for (int j = i + 1; j &lt; n; j++) {                if (nums[j] % nums[i]) continue;                if (dp[j] &lt; dp[i] + 1) {                    dp[j] = dp[i] + 1;                    from[j] = i;                }            }            if (dp[i] &gt; mx) {                mx = dp[i];                mxloc = i;            }        }        vector&lt;int&gt; ans;        for (int i = mxloc; ; i = from[i]) {            ans.push_back(nums[i]);            if (i == from[i]) break;        }        return ans;    }};\n\n其他搭建博客后担心实在无东西可写，于是想到了写写力扣的每日一题。\n之前遇到较为麻烦的每日一题就会懒得写，在博客写这个也许既能让博客每日更新又能push我每天写题。\n当前目标就先定为拿下四月全勤徽章吧。\n","categories":["做题笔记"],"tags":["cpp","leetcode","dp"]},{"title":"第一篇博客","url":"/2025/04/06/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","content":"我是sfiisf，这是我兴趣使然创建的博客，现在还什么都没有，也不知道将来会有些什么。\n防止这个新生的博客太空，于是有了这篇自我介绍。\nsfiisf，这个名字是中二时期一拍大腿想出的名字，其中的内涵有些令人害羞尚且不好意思详细介绍，虽然有些后悔但回过神来时已经在很多地方留下这个名字了，只好延用至今。\n仔细想想，我是个乏善可陈且无趣的人，搜肠刮肚自我介绍到这就有点写不下去了。\n虽然不知道将来是我的分享欲先战胜我的懒惰，还是我的懒惰先战胜我的分享欲，但我是个怎么样的人，还是从我将来的文章来认识我吧！\nLove!\n","categories":["杂谈"],"tags":[]}]