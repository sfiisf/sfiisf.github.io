[{"title":"力扣每日一题781-森林中的兔子","url":"/2025/04/20/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98781-%E6%A3%AE%E6%9E%97%E4%B8%AD%E7%9A%84%E5%85%94%E5%AD%90/","content":"题意给定整数数组answers,其中answers[i]表示第i只兔子回答问题\"还有多少只兔子与你颜色相同\"的答案。\n求问兔子总数量的最小可能值\n思路并没有什么算法上的知识，就是一个比较简单的数学思维题。\n如果有1只兔子回答1，显然答案是2，因为问题是还有多少只也就是除你外有多少只与你同色\n如果有2只兔子回答1，显然答案是2，因为2只同色的问同样的问题答案相同是符合题意的\n如果有3只兔子回答1，显然答案是4，若3只兔子颜色相同那么它们的回答是不可能为1的，使得总数最小可以贪心的将其中两只配对，另一只独立，问题就变为了前两个问题的和\n…\n不难推出，回答为x的兔子，只可能与回答x的其他兔子同色，最多可以与另外x只回答均为x的兔子组成一个有x + 1只兔子的同色组\n记录各个回答的兔子个数，然后贪心地计算答案即可。\n实现class Solution {public:    int numRabbits(vector&lt;int&gt;&amp; answers) {        unordered_map&lt;int, int&gt; cnt;        for (const auto&amp; x : answers) {            cnt[x]++;        }        int ans = 0;        for (const auto&amp; [x, t] : cnt) {            ans += (t + x) / (x + 1) * (x + 1);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2563-统计公平数对的数目","url":"/2025/04/19/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982563-%E7%BB%9F%E8%AE%A1%E5%85%AC%E5%B9%B3%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums与定值lower和upper，求满足以下条件的数对(i, j)个数\n\n\n思路考虑固定nums[j]那么什么样的nums[i]满足条件呢，移项发现\n\n不难发现nums[i]越大lower - nums[i]与upper - nums[i]越小\n那么比较好实现的就是二分得到第一个满足条件的与最后一个不满足条件的\n实现class Solution {using ll = long long;public:    long long countFairPairs(vector&lt;int&gt;&amp; nums, int lower, int upper) {        ranges::sort(nums);        ll ans = 0;        const int n = nums.size();        for (int i = 0; i &lt; n; i++) {            int r = upper_bound(nums.begin(), nums.begin() + i, upper - nums[i]) - nums.begin();            int l = lower_bound(nums.begin(), nums.begin() + i, lower - nums[i]) - nums.begin();            ans += r - l;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2364-统计坏数对的数目","url":"/2025/04/18/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982364-%E7%BB%9F%E8%AE%A1%E5%9D%8F%E6%95%B0%E5%AF%B9%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums，求满足以下条件的数对(i, j)个数\n\n思路这几天的每日一题都是类似的求数对或求三元组个数，应该可以感受到求不等于是没有求等于对数方便的。\n那么可以考虑正难则反，求出满足下列条件的数对(i, j)个数，再取补集即可。\n\n好像还是不是很好做，对于给定的i 或 j还是需要枚举另一个数进行筛选\n但是发现可以将式子移项变形\n\n就可以发现此时比较好做了，只需枚举每个数，记录其下标与其值之差即可。\n实现class Solution {using ll = long long;public:    long long countBadPairs(vector&lt;int&gt;&amp; nums) {        unordered_map&lt;int, int&gt; cnt;        ll ans = ll(nums.size()) * (ll(nums.size()) - 1) / 2;        for (int i = 0; i &lt; nums.size(); i++) {            ans -= cnt[i - nums[i]];            cnt[i - nums[i]]++;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2176-统计数组中相等且可以被整除的数对","url":"/2025/04/17/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982176-%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9B%B8%E7%AD%89%E4%B8%94%E5%8F%AF%E4%BB%A5%E8%A2%AB%E6%95%B4%E9%99%A4%E7%9A%84%E6%95%B0%E5%AF%B9/","content":"题意给定数组nums与定值k，求满足以下条件的下标 (i, j) 对数\n0 &lt;= i &lt; j &lt; nums.size()\nnums[i] == nums[j]\ni * j % k == 0\n思路首先这道题的数据范围比较小，是可以直接暴力进行的（没有预处理等操作暴力反而还更快些）\n但这样不太优雅，我们假定数据范围比较大时应该如何做呢\n首先考虑什么情况下 i * j % k == 0呢\n显然若i % k == 0 || j % k == 0时等式是成立的\n但若i、j均不为k的倍数呢，是否有可能乘积被k 整除，举例发现是可行的比如6 % 4 != 0, 10 % 4 != 0, 6 * 10 % 4 == 0 \n可以发现：\n\n若j % t == 0 可得i * j % k == 0\n那么枚举j再计算符合nums[i] == nums[j] 且 i % t == 0的条件的i个数即可\n此处使用哈希记录j之前的值为nums[j]及其对应下标的因数，如此只需统计cnt[(nums[j], t)]即可\n注意unordered_map的键值不能直接使用pair&lt;&gt;需要重载其运算符，或将nums[j] 与 t合并为一个数再进行哈希计算\n实现暴力实现\nclass Solution {public:    int countPairs(vector&lt;int&gt;&amp; nums, int k) {        int ans = 0;        for (int i = 0; i &lt; nums.size(); i++) {            for (int j = i + 1; j &lt; nums.size(); j++) {                if (nums[i] == nums[j] &amp;&amp; i * j % k == 0) ans++;            }        }        return ans;    }};\n\n\n\n其他实现\nconstexpr int N = 100;vector&lt;vector&lt;int&gt;&gt; factors(N + 1);int init = []() {    for (int i = 1; i &lt;= N; i++) {        for (int j = i; j &lt;= N; j += i) {            factors[j].push_back(i);        }    }    return 0;} ();class Solution {public:    int countPairs(vector&lt;int&gt;&amp; nums, int k) {        int ans = 0;        auto cal = [](int x, int f) -&gt; int {            return x &lt;&lt; 8 | f;        };        unordered_map&lt;int, int&gt; cnt;        for (int i = 0; i &lt; nums.size(); i++) {            int t = k / gcd(i, k);            ans += cnt[cal(nums[i], t)];            if (i &amp;&amp; nums[i] == nums[0]) ans++;            for (auto f : factors[i]) {                cnt[cal(nums[i], f)]++;            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2537-统计好子数组的数目","url":"/2025/04/16/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982537-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定数组nums与定值k，求该nums中至少有k对相等数的子数组数目\n即有多少子数组arr至少含有k对(i, j)满足i &lt; j 且 arr[i]==arr[j]\n思路求满足条件的子数组个数，比较经典的思路就是双指针进行一个滑动窗口。\n维护区间内相等数的对数可以考虑使用哈希记录各个数出现的次数。\n枚举窗口的右端点，对于每个右端点其最左不满足条件的位置左侧所有位置均满足条件。\n实现class Solution {using ll = long long;public:    long long countGood(vector&lt;int&gt;&amp; nums, int k) {        ll ans = 0;        unordered_map&lt;int, int&gt; cnt;        for (int l = 0, r = 0, p = 0; r &lt; nums.size(); r++) {            p += cnt[nums[r]];            cnt[nums[r]]++;            while (p &gt;= k) {                cnt[nums[l]]--;                p -= cnt[nums[l]];                l++;            }            ans += l;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2179-统计数组中好三元组数目","url":"/2025/04/15/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982179-%E7%BB%9F%E8%AE%A1%E6%95%B0%E7%BB%84%E4%B8%AD%E5%A5%BD%E4%B8%89%E5%85%83%E7%BB%84%E6%95%B0%E7%9B%AE/","content":"题意给定两[0, n - 1] 的排列nums1与nums2，求满足下列条件的三元组(i, j, k)的个数\ni, j, k的出现顺序在nums1与nums2中均一致为顺序出现，记p1_i 为i在nums1中出现的位置，p2_i为i在nums2中出现的位置，即：\n\n思路注意到此处三元组仅关注数出现的顺序而与数的具体值无关，可以考虑将nums1 中的各个数值映射到其对应的出现顺序。\n对于统计合法的三元组问题，可以考虑枚举中间值j再判断其前后满足条件的i与k数量，此处枚举j那么对于同一个j其合法的三元组个数即为：nums1 与 nums2 中均出现在 j 前的数的个数 * nums1 与 nums2 中均出现在 j 之后的数的个数\n那么枚举nums2中的元素，将每个元素视作三元组的j，使用与nums1相同的映射函数P：\n\n小于P(nums2[j])的数即为在nums1中，于nums2[j]之前所出现过的数；\n\n而i &lt; j | nums2[i]即是在nums2中，于nums2[j] 之前所出现过的数；\n\n大于P(nums2[j])的数即为在nums1中，于nums2[j]之后将出现的数；\n\n而i &gt; j | nums2[i]即是在nums2中，于nums2[j] 之后将出现的数；\n\n\n取并操作即可得到nums1 与 nums2 中均出现在 nums2[j] 前的数的个数 与 nums1 与 nums2 中均出现在 nums2[j] 之后的数的个数\n如何快速维护得到小于某个值且在之前出现过的值的个数呢，比较自然的可以想到树状数组，当然线段树等其他数据结构也是可行的。\n实现template&lt;typename T&gt;class Fenwick {private:    int n;    vector&lt;T&gt; a;public:    Fenwick(int x) {        n = x;        a.resize(x + 1);    }    void add(int x, T val) {        for ( ; x &lt;= n; x += (x &amp; -x)) {            a[x] += val;        }    }    T query(int x) {        T res = 0;        for ( ; x &gt; 0; x -= (x &amp; -x)) {            res += a[x];        }        return res;    }};class Solution {using ll = long long;public:    long long goodTriplets(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        ll ans = 0;        const int n = nums1.size();        vector&lt;int&gt; p(n);        for (int i = 0; i &lt; n; i++) {            p[nums1[i]] = i;        }        Fenwick&lt;int&gt; f(n);        for (int i = 0; i &lt; n; i++) {            int t = f.query(p[nums2[i]]);            ans += 1ll * t * (n - 1 - p[nums2[i]] - i + t);            f.add(p[nums2[i]] + 1, 1);        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","fenwick"]},{"title":"力扣每日一题1534-统计好三元组","url":"/2025/04/14/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981534-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E4%B8%89%E5%85%83%E7%BB%84/","content":"题意给定数组arr，与三整数a、b、c，求满足以下条件的三元组(i, j, k)个数\n\n​\n\n\n思路注意到数组大小范围很小仅有1e2，直接暴力即可。\n当然也存在更加高效的做法，但我有点犯懒了，详细还是请见他人博客（\n实现class Solution {public:    int countGoodTriplets(vector&lt;int&gt;&amp; arr, int a, int b, int c) {        int ans = 0;        for (int i = 0; i &lt; arr.size(); i++) {            for (int j = i + 1; j &lt; arr.size(); j++) {                if (abs(arr[i] - arr[j]) &gt; a) continue;                for (int k = j + 1; k &lt; arr.size(); k++) {                    if (abs(arr[j] - arr[k]) &gt; b) continue;                    if (abs(arr[i] - arr[k]) &gt; c) continue;                    ans++;                }            }        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题1922-统计好数字的数目","url":"/2025/04/13/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%981922-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意若一个数字串满足偶数位均位偶数奇数位均为质数，则称其为好数字。\n问长度为给定n的好数字个数（可前导零）。\n思路个位数的偶数共有5个0, 2, 4, 6, 8\n个位数的质数共有4个2, 3, 5, 7\n且允许存在前导零，那么显然这是一个简单的数学问题\n记为even偶数位个数，odd为奇数位个数则有\n方案数\n唯一需要注意的是n较大 , 需用上快速幂，且答案较大需对1e9 + 7取模\n实现class Solution {using ll = long long;static constexpr ll mod = 1e9 + 7;public:    ll powMod(ll a, ll b) {        ll res = 1;        while (b) {            if (b &amp; 1) {                res = res * a % mod;            }            a = a * a % mod;            b &gt;&gt;= 1;        }        return res;    }    int countGoodNumbers(long long n) {        ll even = n / 2 + (n &amp; 1), odd = n / 2;        return powMod(5, even) * powMod(4, odd) % mod;    }};\n\n","categories":["做题笔记"],"tags":["cpp","math"]},{"title":"力扣每日一题3272-统计好整数的数目","url":"/2025/04/12/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983272-%E7%BB%9F%E8%AE%A1%E5%A5%BD%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意若一个数x是回文整数且被k整除则称其为k回文整数。\n若一个数y可以对其数位进行重排后变为k回文整数则称其为好整数（无前导零）。\n对于给定的数位n与个位数k，求问有多少个n位数为好整数。\n思路首先考虑得到k回文整数再将其重排得到好整数\n对于回文数，因为其前半部分与其后半部分反转后相同，故可以考虑枚举其前半部分。\n能否整除k仅需计算一下即可。\n而对于一个k回文整数有多少种合法重排方式，则是一个较为简单的排列组合问题，首先是第一位数不能为0,剩余位数可任意排序，又相同的数之间互换是相同的，故而可以推导出：\n记为该数为i的数位个数\n合法重排方案数\n显然当均相等时得到的方案数相同，再考虑对其使用哈希去重即可\n实现array&lt;int, 11&gt; f;int init = []() {    f[0] = 1;    for (int i = 1; i &lt;= 10; i++) {        f[i] = i * f[i - 1];    }    return 0;}();class Solution {using ll = long long;public:    long long countGoodIntegers(int n, int k) {        ll ans = 0;        int b = pow(10, (n + 1) / 2 - 1);        unordered_set&lt;string&gt; vis;        array&lt;int, 10&gt; cnt;        for (int i = b; i &lt; b * 10; i++) {            string s = to_string(i), t = s;            if (n &amp; 1) t.pop_back();            reverse(t.begin(), t.end());            s += t;            if (stoll(s) % k) continue;            ranges::sort(s);            if (vis.count(s)) continue;            vis.insert(s);            cnt.fill(0);            for (const auto&amp; ch : s) cnt[ch - '0']++;            ll res = (n - cnt[0]) * f[n - 1];            for (int i = 0; i &lt; 10; i++) {                res /= f[cnt[i]];            }            ans += res;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","组合数学"]},{"title":"力扣每日一题2843-统计对称整数的数目","url":"/2025/04/11/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982843-%E7%BB%9F%E8%AE%A1%E5%AF%B9%E7%A7%B0%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意2 * n位数字组成的整数x，若其前n与后n位数位和相等，则称其对称。\n求给定范围[low, high]内对称数的个数。\n思路注意到数据范围很小 直接遍历计数即可。\n但这样太不优雅了，若数据范围扩大该如何做呢，显然和昨天一样是可以通过数位dp来解决的，但尝试了一下感觉好麻烦哦，不想写，easy题有easy题的解法，摆了。\n实现class Solution {public:    static constexpr int mx = 20;    int countSymmetricIntegers(int low, int high) {        auto check = [](int x) -&gt; bool {            string s = to_string(x);            int n = s.size();            if (n &amp; 1) return false;            int sum = 0;            for (int i = 0; i &lt; n; i++) {                sum += (i &lt; n / 2 ? 1 : -1) * (s[i] - ' 0');            }            return sum == 0;        };        int ans = 0;        for (int i = low; i &lt;= high; i++) {            if (check(i)) ans++;        }        return ans;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题2999-统计强大整数的数目","url":"/2025/04/10/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%982999-%E7%BB%9F%E8%AE%A1%E5%BC%BA%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E7%9B%AE/","content":"题意给定区间[start, finish] 、数位限制limit与后缀s，求区间范围内满足每一位数不超过limit且以s为后缀的数的个数。\n思路比较经典的数位dp。\n首先考虑如何计算区间[0, finish]即 满足条件 的x个数。\n在不考虑s为后缀仅考虑每一位限制为limit的条件情况下，从高位向低位递推\n记表示finish第j位\n 当i=0时表示到第j位严格小于finish且满足限制limit的方案个数，当i=1时表示到第j位严格等于finish且满足限制limit的方案个数，可以推到出以下转移方程$$\\left{\\right.$$再考虑如何满足以s为后缀\n记 为s的第j位\n同理可有$$\\left{\\right.$$最终即为所求。\n同理再求出范围[0, start)即[0, start - 1]内的方案数，两者相减即可得到[start, finish]内的方案数。\n实现class Solution {public:    using ll = long long;    long long numberOfPowerfulInt(long long start, long long finish, int limit, string s) {        reverse(s.begin(), s.end());        auto cal = [&amp;](ll t) -&gt; ll {            string num = to_string(t);            reverse(num.begin(), num.end());            vector dp(2, vector&lt;ll&gt; (max(num.size(), s.size()) + 1));            dp[1][max(num.size(), s.size())] = 1;            for (int i = num.size() - 1; i &gt;= 0; i--) {                int x = num[i] - '0';                if (i &gt;= s.size()) {                    if (x &gt; limit) {                        dp[0][i] += (limit + 1) * (dp[0][i + 1] + dp[1][i + 1]);                    } else {                        dp[1][i] += dp[1][i + 1];                        dp[0][i] += x * dp[1][i + 1] + (limit + 1) * dp[0][i + 1];                    }                } else {                    int y = s[i] - '0';                    if (x &gt; y) {                        dp[0][i] += dp[1][i + 1] + dp[0][i + 1];                    } else if (x == y) {                        dp[1][i] += dp[1][i + 1];                        dp[0][i] += dp[0][i + 1];                    } else {                        dp[0][i] += dp[0][i + 1];                    }                }            }            return dp[0][0] + dp[1][0];        };        return cal(finish) - cal(start - 1);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","数位dp"]},{"title":"网络学习","url":"/2025/04/09/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/","content":"由于我个人仍在学习当中，所学内容可能较为零散不成体系更多是以学习时间记录而非内容体系记录，所写可能也因此显得有些杂乱无章，当我建立起一个较为完整的知识体系框架后也许会回来整理吧。\n所记录的问题可能来自我网上冲浪所见或面试所遇我认为值得记录学习的，回答可能来自于网络资料、各路大模型回答以及一些我个人的理解，可能准确率并不太高，若有错漏还望不吝赐教。\n","categories":["学习笔记"],"tags":["note","network"]},{"title":"cpp学习","url":"/2025/04/09/cpp%E5%AD%A6%E4%B9%A0/","content":"由于我个人仍在学习当中，所学内容可能较为零散不成体系更多是以学习时间记录而非内容体系记录，所写可能也因此显得有些杂乱无章，当我建立起一个较为完整的知识体系框架后也许会回来整理吧。\n所记录的问题可能来自我网上冲浪所见或面试所遇我认为值得记录学习的，回答可能来自于网络资料、各路大模型回答以及一些我个人的理解，可能准确率并不太高，若有错漏还望不吝赐教。\n智能指针引用计数概念防止内存泄露。\n基本想法：对于动态分配的对象进行引用计数每当增加一次对同一个对象的引用，那么引用对象的引用计数就会增加一次， 每删除一次引用，引用计数就会减一，当一个对象的引用计数减为零时，就自动删除指向的堆内存。\nc++11引入智能指针概念，包含std::shared_ptr/std::unique_ptr/std::weak_ptr,头文件为&lt;memory&gt;\nshared_ptr可自动记录有多少个shared_ptr共同指向同一对象，当计数归零时自动释放对应对象内存\nstd::make_shared&lt;T&gt; (Args&amp;&amp;... args); // 创建对应对象并返回其指针.get(); // 获得原始指针.use_count(); // 查看对象引用计数\tauto p = ptr.get(); // 不会增加计数\tauto p = ptr; // 会增加计数.reset(); // 置空\n\nunique_ptr独占的智能指针, 禁止其他智能指针与其共享同一个对象\n\ncpp11没有提供std::make_unique, cpp委员会说是忘记了\n\nunique_ptr 用法shared_ptr与类似，但无法通过赋值拷贝给另一智能指针，但可以通过std::move将其转移给另一unique_ptr\n同时还可以通过.get()获取其原始指针后直接赋值给普通指针，但这样显然并不安全。\n","categories":["学习笔记"],"tags":["cpp","note"]},{"title":"力扣每日一题3375-使数组的值全部为K的最少操作次数","url":"/2025/04/09/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983375-%E4%BD%BF%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%BC%E5%85%A8%E9%83%A8%E4%B8%BAK%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","content":"题意数h对于数组nums,若满足,则称h合法，即数组中大于h的数均相等。\n每次操作可以选择任意合法h使得nums中所有大于h的元素变为h\n求问将nums中所有数变为给定k值所需最少操作次数。\n思路当nums最小值小于k时显然是不存在合法操作的，因为不存在将元素值变大的操作。\n可以发现每次操作使得最大值变为次大值时有最优，此题本质可转化为数组中大于k的元素种类数。\n实现class Solution {public:    int minOperations(vector&lt;int&gt;&amp; nums, int k) {        ranges::sort(nums);        if (nums.front() &lt; k) return -1;        nums.erase(unique(nums.begin(), nums.end()), nums.end());        return nums.size() - (nums.front() == k);    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题3396-使数组元素互不相同所需的最少操作次数","url":"/2025/04/08/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%983396-%E4%BD%BF%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%90%8C%E6%89%80%E9%9C%80%E7%9A%84%E6%9C%80%E5%B0%91%E6%93%8D%E4%BD%9C%E6%AC%A1%E6%95%B0/","content":"题意给出一数组，每次操作可以删除数组头三个元素，问使得数组元素互不相同所需最少操作次数。\n思路注意到数据范围很小，数组大小与元素大小均在[1, 100]\n可以考虑正着模拟删除操作，计算删除次数。\n也可以考虑反着操作，从尾开始添加元素，得到最长无重后缀，未添加的元素个数即为要删除的元素个数。\n实现正着模拟删除\nclass Solution {array&lt;int, 101&gt; vis;public:    int minimumOperations(vector&lt;int&gt;&amp; nums) {        vis.fill(0);        int ans = 0, cnt = 0;        for (const auto&amp; x : nums) {            if (vis[x] == 1) cnt++;            vis[x]++;        }        for (int i = 0; cnt &amp;&amp; i &lt; nums.size() - 2; i += 3) {            ans++;            cnt -= (--vis[nums[i]]) == 1;            cnt -= (--vis[nums[i + 1]]) == 1;            cnt -= (--vis[nums[i + 2]]) == 1;        }        ans += cnt &gt; 0;        return ans;    }};\n\n\n\n反着模拟添加\nclass Solution {array&lt;int, 101&gt; vis;public:    int minimumOperations(vector&lt;int&gt;&amp; nums) {        vis.fill(0);        for (int i = nums.size() - 1; i &gt;= 0; i--) {            if (vis[nums[i]]) {                return (i + 1 + 2) / 3;            }            vis[nums[i]]++;        }        return 0;    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode"]},{"title":"力扣每日一题416-分割等和子集","url":"/2025/04/07/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98416-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86/","content":"题意给出整数数组nums，判断其是否可分割为两个和相等的子集\n思路分割为两个等和数组，换言而止就是将 nums分割为子集a 与b使得：\n\n注意到数据范围很小：\n\n\n即满足\n可以考虑使用dp判断是否存在子集和为 \n实现代码class Solution {public:    bool canPartition(vector&lt;int&gt;&amp; nums) {        int sum = accumulate(nums.begin(), nums.end(), 0);        if (sum &amp; 1) return false;        sum &gt;&gt;= 1;        vector&lt;bool&gt; dp(sum + 1);        dp[0] = true;        for (const auto&amp; x : nums) {            for (int i = sum - x; i &gt;= 0; i--) {                if (!dp[i])continue;                dp[i + x] = true;            }            if (dp.back()) return true;        }        return dp.back();    }};\n\n","categories":["做题笔记"],"tags":["cpp","leetcode","dp"]},{"title":"力扣每日一题368.最大整除子集","url":"/2025/04/06/%E5%8A%9B%E6%89%A3%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98368-%E6%9C%80%E5%A4%A7%E6%95%B4%E9%99%A4%E5%AD%90%E9%9B%86/","content":"题意给一个整数集合nums，找最大子集，满足子集元素两两之间一数为另一数的倍数。\n形式化：找出nums子集ans满足 使得ans大小最大\n思路注意到\n可以想到将集合升序排序后再进一步处理。\n又注意到\n即只需满足子集排序后相邻两数互为倍数可满足题设条件。\n可以考虑使用dp记录当前数为子集最大值时满足条件的子集最大大小\n\n实现代码class Solution {public:    vector&lt;int&gt; largestDivisibleSubset(vector&lt;int&gt;&amp; nums) {        const int n = nums.size();        ranges::sort(nums);        vector&lt;int&gt; dp(n, 1), from(n);        iota(from.begin(), from.end(), 0);        int mx = 0, mxloc;        for (int i = 0; i &lt; n; i++) {            for (int j = i + 1; j &lt; n; j++) {                if (nums[j] % nums[i]) continue;                if (dp[j] &lt; dp[i] + 1) {                    dp[j] = dp[i] + 1;                    from[j] = i;                }            }            if (dp[i] &gt; mx) {                mx = dp[i];                mxloc = i;            }        }        vector&lt;int&gt; ans;        for (int i = mxloc; ; i = from[i]) {            ans.push_back(nums[i]);            if (i == from[i]) break;        }        return ans;    }};\n\n其他搭建博客后担心实在无东西可写，于是想到了写写力扣的每日一题。\n之前遇到较为麻烦的每日一题就会懒得写，在博客写这个也许既能让博客每日更新又能push我每天写题。\n当前目标就先定为拿下四月全勤徽章吧。\n","categories":["做题笔记"],"tags":["cpp","leetcode","dp"]},{"title":"第一篇博客","url":"/2025/04/06/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","content":"我是sfiisf，这是我兴趣使然创建的博客，现在还什么都没有，也不知道将来会有些什么。\n防止这个新生的博客太空，于是有了这篇自我介绍。\nsfiisf，这个名字是中二时期一拍大腿想出的名字，其中的内涵有些令人害羞尚且不好意思详细介绍，虽然有些后悔但回过神来时已经在很多地方留下这个名字了，只好延用至今。\n仔细想想，我是个乏善可陈且无趣的人，搜肠刮肚自我介绍到这就有点写不下去了。\n虽然不知道将来是我的分享欲先战胜我的懒惰，还是我的懒惰先战胜我的分享欲，但我是个怎么样的人，还是从我将来的文章来认识我吧！\nLove!\n","categories":["杂谈"],"tags":[]}]