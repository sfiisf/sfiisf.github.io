---
title: 力扣每日一题3272-统计好整数的数目
mathjax: true
date: 2025-04-12 22:04:37
tags:
- cpp
- leetcode
- 组合数学
categories:
- 做题笔记
---

## 题意

若一个数`x`是回文整数且可以整除`k`则称其为`k回文整数`。

若一个数`y`可以对其数位进行重排后变为`k回文整数`则称其为`好整数`（无前导零）。

对于给定的数位`n`与个位数`k`，求问有多少个`n`位数为`好整数`。

## 思路

首先考虑得到`k回文整数`再将其重排得到`好整数`

对于回文数，因为其前半部分与其后半部分反转后相同，故可以考虑枚举其前半部分。

能否整除`k`仅需计算一下即可。

而对于一个`k回文整数`有多少种合法重排方式，则是一个较为简单的排列组合问题，首先是第一位数不能为`0`,剩余位数可任意排序，又相同的数之间互换是相同的，故而可以推导出：

记$cnt_i$为该数为`i`的数位个数

$合法重排方案数=\frac{(n-cnt_0)*(n-1)!}{\prod_{i=0}^{9}cnt_i!}$

显然当$cnt_{i=0}^{9}$均相等时得到的方案数相同，再考虑对其使用哈希去重即可

## 实现

```cpp
array<int, 11> f;
int init = []() {
    f[0] = 1;
    for (int i = 1; i <= 10; i++) {
        f[i] = i * f[i - 1];
    }
    return 0;
}();
class Solution {
using ll = long long;
public:
    long long countGoodIntegers(int n, int k) {
        ll ans = 0;
        int b = pow(10, (n + 1) / 2 - 1);
        unordered_set<string> vis;
        array<int, 10> cnt;
        for (int i = b; i < b * 10; i++) {
            string s = to_string(i), t = s;
            if (n & 1) t.pop_back();
            reverse(t.begin(), t.end());
            s += t;
            if (stoll(s) % k) continue;
            ranges::sort(s);
            if (vis.count(s)) continue;
            vis.insert(s);
            cnt.fill(0);
            for (const auto& ch : s) cnt[ch - '0']++;
            ll res = (n - cnt[0]) * f[n - 1];
            for (int i = 0; i < 10; i++) {
                res /= f[cnt[i]];
            }
            ans += res;
        }
        return ans;
    }
};
```

